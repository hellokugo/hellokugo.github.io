{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[],"Cache":[{"_id":"source/google1e7021b63d98f365.html","hash":"30026aa5dd6a80abb69c5952d913ae486f531ca9","modified":1517153974394},{"_id":"source/baidu_verify_KRpXHI1roq.html","hash":"288a6cafd2d2b8142b1790f9bd5b202dcd497366","modified":1517153974394},{"_id":"source/_posts/65536问题生成多dex处理.md","hash":"68660fb97277fe24980c3eb1a621105499186bb7","modified":1517153974389},{"_id":"source/_posts/Android冗余or重复资源处理.md","hash":"3aa23066f97d43828f52c8d380a487bb2c3d364d","modified":1517153974389},{"_id":"source/_posts/Android多渠道包处理.md","hash":"9bf1d78861b4fcaddad013717eec8cfc7b386e7d","modified":1517153974390},{"_id":"source/_posts/MQTT源码解析之connect.md","hash":"a6fd62addb0724f1b037754f32d14a80d7167ee7","modified":1517153974390},{"_id":"source/_posts/Hexo搭建优化部署.md","hash":"a33e45bcbefd5bb38b113ac396f8ee2f71bc8b00","modified":1517153974390},{"_id":"source/_posts/MQTT源码解析之心跳ping.md","hash":"22507101abf3248a78f3802de36c2b5865e11187","modified":1517153974391},{"_id":"source/_posts/Resource.arsc文件格式.md","hash":"cf68dd304edaff1fd6d06d901b286b2b515ce1a6","modified":1517153974391},{"_id":"source/_posts/python脚本实现图片压缩.md","hash":"16322849fd19060f3d9c375902b20fa44773b9bd","modified":1517153974391},{"_id":"source/_posts/优化动态加载方案.md","hash":"8754b10d40af77e83d01a34461dabb4abe549959","modified":1517153974392},{"_id":"source/_posts/微信Tinker资源热修复解析.md","hash":"00284d14d6583fc2dc44bde72e4922c74bf80197","modified":1517153974392},{"_id":"source/_posts/简析Android组件安全.md","hash":"3b38044b6d889cc91d881ec4e49eaa412bdfd0ce","modified":1517153974393},{"_id":"source/_posts/简析DroidPlugin之Hook.md","hash":"a8a1e71e4cfd0c6e65ee58760b356497c2c396b0","modified":1517153974393},{"_id":"public/baidusitemap.xml","hash":"21951c5ddfa9b457a41a4bc5425eea83034f3929","modified":1517154219483},{"_id":"public/sitemap.xml","hash":"e6ca190b2f54c2b8d2efb1ec897b636f21c87f65","modified":1517154219483},{"_id":"public/baidu_verify_KRpXHI1roq.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1517154219493},{"_id":"public/google1e7021b63d98f365.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1517154219493},{"_id":"public/archives/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1517154219493},{"_id":"public/categories/Android/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1517154219493},{"_id":"public/categories/Others/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1517154219493},{"_id":"public/categories/Mobile/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1517154219493},{"_id":"public/categories/Python/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1517154219493},{"_id":"public/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1517154219493},{"_id":"public/tags/Android，多dex，65536/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1517154219493},{"_id":"public/tags/Android，，多渠道，pyqt/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1517154219493},{"_id":"public/tags/Android，MQTT/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1517154219493},{"_id":"public/tags/other/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1517154219494},{"_id":"public/tags/android/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1517154219494},{"_id":"public/tags/python/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1517154219494},{"_id":"public/2018/01/28/简析Android组件安全/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1517154219498},{"_id":"public/2018/01/28/简析DroidPlugin之Hook/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1517154219498},{"_id":"public/2018/01/28/微信Tinker资源热修复解析/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1517154219498},{"_id":"public/2018/01/28/Resource.arsc文件格式/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1517154219499},{"_id":"public/2018/01/28/优化动态加载方案/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1517154219499},{"_id":"public/2018/01/28/MQTT源码解析之心跳ping/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1517154219499},{"_id":"public/2018/01/28/python脚本实现图片压缩/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1517154219499},{"_id":"public/2018/01/28/Hexo搭建优化部署/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1517154219499},{"_id":"public/2018/01/28/MQTT源码解析之connect/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1517154219499},{"_id":"public/2018/01/28/Android多渠道包处理/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1517154219499},{"_id":"public/2018/01/28/Android冗余or重复资源处理/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1517154219499},{"_id":"public/2018/01/28/65536问题生成多dex处理/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1517154219499},{"_id":"public/archives/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1517154219499},{"_id":"public/archives/2018/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1517154219499},{"_id":"public/archives/2018/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1517154219499},{"_id":"public/archives/2018/01/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1517154219499},{"_id":"public/archives/2018/01/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1517154219499},{"_id":"public/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1517154219499},{"_id":"public/tags/Android，AndResguard/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1517154219499},{"_id":"public/tags/Android，MQTT，ping/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1517154219499},{"_id":"public/tags/Android，Tinker/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1517154219500}],"Category":[{"name":"Android","_id":"cjcyyg7jj0004niusdy23act6"},{"name":"Others","_id":"cjcyyg7kf000mnius00vwqlmh"},{"name":"Mobile","_id":"cjcyyg7ko000tniusphb8gny1"},{"name":"Python","_id":"cjcyyg7kr000xniusw5wudfrk"}],"Data":[],"Page":[{"_content":"google-site-verification: google1e7021b63d98f365.html","source":"google1e7021b63d98f365.html","raw":"google-site-verification: google1e7021b63d98f365.html","date":"2018-01-28T15:39:34.394Z","updated":"2018-01-28T15:39:34.394Z","path":"google1e7021b63d98f365.html","title":"","comments":1,"layout":"page","_id":"cjcyyg7io0000nius89s6e2ml","content":"google-site-verification: google1e7021b63d98f365.html","site":{"data":{}},"excerpt":"","more":"google-site-verification: google1e7021b63d98f365.html"},{"_content":"KRpXHI1roq","source":"baidu_verify_KRpXHI1roq.html","raw":"KRpXHI1roq","date":"2018-01-28T15:39:34.394Z","updated":"2018-01-28T15:39:34.394Z","path":"baidu_verify_KRpXHI1roq.html","title":"","comments":1,"layout":"page","_id":"cjcyyg7is0001nius7u1bbetl","content":"KRpXHI1roq","site":{"data":{}},"excerpt":"","more":"KRpXHI1roq"}],"Post":[{"title":"65536问题生成多dex处理","date":"2018-01-28T15:39:34.389Z","_content":"\n\n# 需求背景\n目前Android在处理65536的问题上提出了很多解决方案，google官方介绍的在Android studio上分dex开关控制是很多项目的首选，但这是基于源代码编译过程中去处理（或者说，在分完多dex后就是最终的apk包）。这里要说的一种业务场景，是提供一种方便接入第三方sdk平台的65536处理，区别于一次打包即可生成最终apk，这里是针对源apk（可以理解为通过开发工具打出的不接入任何三方sdk的可运行apk）通过选择不同接入第三方sdk二次编译打包而生成最终的apk场景。<!-- more -->具体来说，就是通过对源apk的反编译生成的smali文件，和通过约定规范接口接入的第三方sdk反编译smali文件结合，再通过对smali文件回编生成一个最终apk的过程。当然了，中间涉及包括资源和AndroidManifest等一些处理，这里不展开细说，因为65536问题主要是代码层面的处理。\n\n# 处理方案\n\n上述场景就不像Android studio提供的开关这么好处理了，因为即使上传的源apk方法数不超过65535，在合并第三方sdk的smali后难免会超过这个阈值，像接入单一个360这种sdk就已经有4w+的方法，这样回编肯定是不成功，这种场景下目前是没有很好的解决方案。业务初期提供了动态加载方案，即把接入多出的第三方sdk（像这里的360sdk）抽出dex动态加载，其他资源等处理不作改变，这样确实可以保证运行成功，而且启动速度也不会造成明显的影响。本以为这种方案可以后续推广，在接入360后提审返回结果竟然是不通过，原因在于360会检查我们的接入包是含有其代码文件，这就蛋疼了，因为我们把他们的代码都用作动态加载，反编译的包肯定是没有他们的代码文件。没想到还会有这种情况，这就让我们重新审视思考，能不能在现有的合并smali接入过程中做到像Android studio一样分dex？答案当然是可以。\n\n\n# 道路是曲折的\n\n## 思考\n\n既然要在不影响整个接入打包流程做出改变，就必须思考几个问题：\n\n1. 用什么方法去判断分出主从dex？\n2. 方法数怎么计算？\n\n\t事实上，上面两个问题都是依托当前的打包流程。因为中间涉及反编译的工具区分，业务初期采用的是apktool1.5.3，后面发现1.5.3版本不能适配Android后续推出的api版本。所以目前后台打包主要是使用apktool1.5.3、2.0.1和2.0.3三种打包空间，业务根据不同需要上传不同空间的源apk接入。这里面就有一个问题，经测试发现，不同apktool版本的处理是不一样的。具体来说，我们希望的是在后台合并完smali后分主从dex文件夹（smali和smali2），然后直接回编，这样最终的apk应该是有class.dex和classes2.dex。事与愿违，在1.5.3版本下回编是不会识别smali2这个文件夹的，就是说，最终回编的apk仅有classes.dex。这样就没辙了，既然用到人家的工具，就必须遵循他的一切规则和bug。不过在这个问题上还是很快地找到处理方法，就是根据打包版本区分处理，在1.5.3版本下另外对smali2文件生成classes2.dex。然后在最终回编的apk直接打入classes2.dex。\n\n## 第一点\n\n关于第一个问题，我们参考了[dex分包变形记](https://segmentfault.com/a/1190000004053072)，Android SDK 从 build tools 21 开始提供了 mainDexClasses 脚本来生成主 dex 的文件列表。这样就简单了，直接使用该jar包即可。命令示例如下：\n\t\n\tmainDexClasses.bat --output d:\\dex.log **\\5.7release_20160923_2_dex2jar.jar --disable-annotation-resolution-workaround\n\n关键在于第二点，事实上我们在研发过程中也是在处理第二个问题上花费了不少时间，包括找到处理方案和考虑折衷的阈值。在这里先说明一点，在这个打包流程当中我们使用的是python语言。\n\n## 第二点\n\n首先，计算方法数不单单是“怎么算”，还要考虑“什么时候算”。我们知道，Android studio在2.2版本引入了分析apk的功能，可以看到apk的方法数\n\n![](http://i.imgur.com/CeIPfJJ.png)\n\n这里注意的是，计算出来的有两个方法数，分别是6048和references的8235。\n\n我们可以用dex-method-counts.jar来计算上述jar包的方法数，得出的结果是8235。\n\n![](http://i.imgur.com/whvQIJx.png)\n\nAndroid studio统计出来的两个数值有什么区别呢？通俗点来说，每个类里面的方法不单单只有自己类所定义的方法，还有引用了其他包或者是系统定义类的方法，而references统计出来的就是包含这些引用方法的数目。经测试发现，用apktool回编出现65536问题提示的统计方法数正式这个references所代表的数值。这样一看，貌似接下来就很明朗了，直接用现成的dex-method-counts.jar就可以在移动smali文件过程中计算究竟移动后的方法数。\n\n但是，这里面就涉及另外一个问题，我们知道，dex-method-counts.jar统计的是dex文件，而我们的文件单位是smali，难道每移动一次就要用smlia工具生成dex再计算？这样所耗费的时间可想而知，因为我们并不能控制移动的次数。这样就迫使我们要考虑是继续查找其他计算方法还是在现有的基础上选择合适的计算时机。\n\n### 计算.method方法数\n\n参考 [U8SDK——支持自动拆分成多个dex文件(MultiDex支持)](http://blog.csdn.net/chenjie19891104/article/details/51258183)一文，发现了另外一种计算思路，即 直接计算smali文件的以.method开头的数目来计算当前smali文件的方法数。通过测试，该方法只是计算当前smali的直接方法数（即该samli定义的方法数，不包含引用数），我们从Android studio的计算方式知道，这样计算出来的方法数并不符合我们预期，因为肯定会比回编的smali工具计算得少（因为统计的是references方法数）。但是这里有一个思路，既然用这种方法统计出来的方法数是比正常统计的少，那么在移动smali计算过程中移动后所剩下smali的方法数肯定是比阈值要低。简单的计算公式：\n\n\tremainMethod = totalMethod - moveMethod\n\n这里具体解释一下操作。首先，我们在合并完smali文件后利用smali工具把合并后的smali文件生成dex，然后直接用dex-method-counts.jar计算该dex的方法数，这个数就是totalMethod，是准确的。然后开始移动smali，每操作一个smali文件之前，先用计算.method数的方法来粗略计算该smali的方法数，这个数就是moveMethod，在移动到smali2文件夹后，再判断remainMethod是否大于阈值（这里可以直接设置65536），如果是大于，继续做移动操作，否则停止移动。由于remainMethod比准确的剩余方法数要少，所以这个方法数即使是有误差但也是安全低于设置的阈值。\n\n## 修改smali源码\n\n一切障碍放佛都已经扫清，可以直接编写代码测试。没想到在合并完smali文件生成dex过程中就抛出方法数超过65536的错误。真是百密一疏，忽略了apktool其实也是依赖smali.jar来计算方法数啊，这岂不是一个endless loop？且慢，考虑到我们这一步只是用来计算方法数，生成的dex对于我们而言是没有作用的，换句话说，我们直接把判断抛错的地方注释掉不就行了？感谢smali开放了源码，注意的是，由于smali我们是用apktool反编译的apk，所以要和我们的apktool版本所用的smali.jar版本一致，这个可以查看apktool的jar得知：\n\n![](http://i.imgur.com/b1Adfdy.png)\n\n![](http://i.imgur.com/XacVseY.png)\n\n截图分别对应的是1.5.3和2.0.1的信息。进入[smali](https://github.com/JesusFreke/smali)的托管代码下载对应的源码，我们选用的是1.4.2和2.1.3版本。根据抛出的错误信息找到对应要注释的位置（下面面的源码修改只截图2.1.3版本，注意1.4.2修改的位置类不一样，请自行查找）：\n\n![](http://i.imgur.com/FFynHi2.png)\n\n细心点的读者可能会有个想法，既然超过65536会抛出具体的方法数错误，smali内部是有计算method的一套方法，直接在生成dex过程中读出不就好了？对的，既然我们拿到了源码，完全是可以利用其计算出来的数，免去dex-method-counts.jar计算方法数这一步，上面也说到了，这一步生成的dex只是用作计算，那是否生成dex就没有关系了，把smali内部计算的方法数保存到一个文件读取即可，不用等dex生成，也节省了时间。\n\n![](http://i.imgur.com/wr9Ii0c.png)\n\n截图中的opcodes.logFile是我们增加了命令行一个输入可选参数，用作保存记录方法数的文件路径。特别强调的是，smali的2.1.3和1.4.2版本差别较大，请注意修改。\n\n## filed的65536问题\n\n按照上述的步骤去打包测试，是可以正常生成可运行的apk，打开apk也可以发现有classes2.dex。但是在大量的测试过程中发现，有部分打包过程中出现filed的65536问题，这是比价少见的。查看源码，filed的确也会去做65536检验，当然还有type和string等，为了避免这种情况，我们在判断方法数阈值添加一个“与”判断，即同时判断filed是否也小于阈值，而对应的移动smali也同步计算filed的值，原理和method是一样的。注意的是，totalFiled需要和totalMethod一样，修改源码在生成dex过程中保存在读取的文件中。\n\n## 修改mainDexClasses.rules\n\n由于是用google官方推荐的classesN.dex方案，在5.0以下的系统必须添加依赖的jar包，即android-support-multidex.jar。由于加载classesN.dex的逻辑是android-support-multidex的代码里面，即必须保证该jar的类必须在主列表清单。测试发现，mainDexClasses生成的主列表清单并没有记录MultiDexExtractor和ZipUtil这两个类，所以需要我们手动添加过滤这两个类，具体修改在mainDexClasses.rules：\n\n![](http://i.imgur.com/roV1hbC.png)\n\n当然，你也可以在移动smali添加过滤以android.support.multidex开头的类不作移动。\n\n# Todo\n\n在本文介绍的处理方法关键是如何判断停止移动smali，上述的方法虽然可以保证主dex不会超过65536方法数，但是造成的误差有可能会给加载其他dex带来加载时间过长的不好体验，由于smali是在生成dex过程中读出的方法数，后续细读其源码能把主dex的方法数控制得更准确。","source":"_posts/65536问题生成多dex处理.md","raw":"title: 65536问题生成多dex处理\ndate: 2016/10/30 17：10\n\ncategories:\n- Android\ntags:\n- Android，多dex，65536\n---\n\n\n# 需求背景\n目前Android在处理65536的问题上提出了很多解决方案，google官方介绍的在Android studio上分dex开关控制是很多项目的首选，但这是基于源代码编译过程中去处理（或者说，在分完多dex后就是最终的apk包）。这里要说的一种业务场景，是提供一种方便接入第三方sdk平台的65536处理，区别于一次打包即可生成最终apk，这里是针对源apk（可以理解为通过开发工具打出的不接入任何三方sdk的可运行apk）通过选择不同接入第三方sdk二次编译打包而生成最终的apk场景。<!-- more -->具体来说，就是通过对源apk的反编译生成的smali文件，和通过约定规范接口接入的第三方sdk反编译smali文件结合，再通过对smali文件回编生成一个最终apk的过程。当然了，中间涉及包括资源和AndroidManifest等一些处理，这里不展开细说，因为65536问题主要是代码层面的处理。\n\n# 处理方案\n\n上述场景就不像Android studio提供的开关这么好处理了，因为即使上传的源apk方法数不超过65535，在合并第三方sdk的smali后难免会超过这个阈值，像接入单一个360这种sdk就已经有4w+的方法，这样回编肯定是不成功，这种场景下目前是没有很好的解决方案。业务初期提供了动态加载方案，即把接入多出的第三方sdk（像这里的360sdk）抽出dex动态加载，其他资源等处理不作改变，这样确实可以保证运行成功，而且启动速度也不会造成明显的影响。本以为这种方案可以后续推广，在接入360后提审返回结果竟然是不通过，原因在于360会检查我们的接入包是含有其代码文件，这就蛋疼了，因为我们把他们的代码都用作动态加载，反编译的包肯定是没有他们的代码文件。没想到还会有这种情况，这就让我们重新审视思考，能不能在现有的合并smali接入过程中做到像Android studio一样分dex？答案当然是可以。\n\n\n# 道路是曲折的\n\n## 思考\n\n既然要在不影响整个接入打包流程做出改变，就必须思考几个问题：\n\n1. 用什么方法去判断分出主从dex？\n2. 方法数怎么计算？\n\n\t事实上，上面两个问题都是依托当前的打包流程。因为中间涉及反编译的工具区分，业务初期采用的是apktool1.5.3，后面发现1.5.3版本不能适配Android后续推出的api版本。所以目前后台打包主要是使用apktool1.5.3、2.0.1和2.0.3三种打包空间，业务根据不同需要上传不同空间的源apk接入。这里面就有一个问题，经测试发现，不同apktool版本的处理是不一样的。具体来说，我们希望的是在后台合并完smali后分主从dex文件夹（smali和smali2），然后直接回编，这样最终的apk应该是有class.dex和classes2.dex。事与愿违，在1.5.3版本下回编是不会识别smali2这个文件夹的，就是说，最终回编的apk仅有classes.dex。这样就没辙了，既然用到人家的工具，就必须遵循他的一切规则和bug。不过在这个问题上还是很快地找到处理方法，就是根据打包版本区分处理，在1.5.3版本下另外对smali2文件生成classes2.dex。然后在最终回编的apk直接打入classes2.dex。\n\n## 第一点\n\n关于第一个问题，我们参考了[dex分包变形记](https://segmentfault.com/a/1190000004053072)，Android SDK 从 build tools 21 开始提供了 mainDexClasses 脚本来生成主 dex 的文件列表。这样就简单了，直接使用该jar包即可。命令示例如下：\n\t\n\tmainDexClasses.bat --output d:\\dex.log **\\5.7release_20160923_2_dex2jar.jar --disable-annotation-resolution-workaround\n\n关键在于第二点，事实上我们在研发过程中也是在处理第二个问题上花费了不少时间，包括找到处理方案和考虑折衷的阈值。在这里先说明一点，在这个打包流程当中我们使用的是python语言。\n\n## 第二点\n\n首先，计算方法数不单单是“怎么算”，还要考虑“什么时候算”。我们知道，Android studio在2.2版本引入了分析apk的功能，可以看到apk的方法数\n\n![](http://i.imgur.com/CeIPfJJ.png)\n\n这里注意的是，计算出来的有两个方法数，分别是6048和references的8235。\n\n我们可以用dex-method-counts.jar来计算上述jar包的方法数，得出的结果是8235。\n\n![](http://i.imgur.com/whvQIJx.png)\n\nAndroid studio统计出来的两个数值有什么区别呢？通俗点来说，每个类里面的方法不单单只有自己类所定义的方法，还有引用了其他包或者是系统定义类的方法，而references统计出来的就是包含这些引用方法的数目。经测试发现，用apktool回编出现65536问题提示的统计方法数正式这个references所代表的数值。这样一看，貌似接下来就很明朗了，直接用现成的dex-method-counts.jar就可以在移动smali文件过程中计算究竟移动后的方法数。\n\n但是，这里面就涉及另外一个问题，我们知道，dex-method-counts.jar统计的是dex文件，而我们的文件单位是smali，难道每移动一次就要用smlia工具生成dex再计算？这样所耗费的时间可想而知，因为我们并不能控制移动的次数。这样就迫使我们要考虑是继续查找其他计算方法还是在现有的基础上选择合适的计算时机。\n\n### 计算.method方法数\n\n参考 [U8SDK——支持自动拆分成多个dex文件(MultiDex支持)](http://blog.csdn.net/chenjie19891104/article/details/51258183)一文，发现了另外一种计算思路，即 直接计算smali文件的以.method开头的数目来计算当前smali文件的方法数。通过测试，该方法只是计算当前smali的直接方法数（即该samli定义的方法数，不包含引用数），我们从Android studio的计算方式知道，这样计算出来的方法数并不符合我们预期，因为肯定会比回编的smali工具计算得少（因为统计的是references方法数）。但是这里有一个思路，既然用这种方法统计出来的方法数是比正常统计的少，那么在移动smali计算过程中移动后所剩下smali的方法数肯定是比阈值要低。简单的计算公式：\n\n\tremainMethod = totalMethod - moveMethod\n\n这里具体解释一下操作。首先，我们在合并完smali文件后利用smali工具把合并后的smali文件生成dex，然后直接用dex-method-counts.jar计算该dex的方法数，这个数就是totalMethod，是准确的。然后开始移动smali，每操作一个smali文件之前，先用计算.method数的方法来粗略计算该smali的方法数，这个数就是moveMethod，在移动到smali2文件夹后，再判断remainMethod是否大于阈值（这里可以直接设置65536），如果是大于，继续做移动操作，否则停止移动。由于remainMethod比准确的剩余方法数要少，所以这个方法数即使是有误差但也是安全低于设置的阈值。\n\n## 修改smali源码\n\n一切障碍放佛都已经扫清，可以直接编写代码测试。没想到在合并完smali文件生成dex过程中就抛出方法数超过65536的错误。真是百密一疏，忽略了apktool其实也是依赖smali.jar来计算方法数啊，这岂不是一个endless loop？且慢，考虑到我们这一步只是用来计算方法数，生成的dex对于我们而言是没有作用的，换句话说，我们直接把判断抛错的地方注释掉不就行了？感谢smali开放了源码，注意的是，由于smali我们是用apktool反编译的apk，所以要和我们的apktool版本所用的smali.jar版本一致，这个可以查看apktool的jar得知：\n\n![](http://i.imgur.com/b1Adfdy.png)\n\n![](http://i.imgur.com/XacVseY.png)\n\n截图分别对应的是1.5.3和2.0.1的信息。进入[smali](https://github.com/JesusFreke/smali)的托管代码下载对应的源码，我们选用的是1.4.2和2.1.3版本。根据抛出的错误信息找到对应要注释的位置（下面面的源码修改只截图2.1.3版本，注意1.4.2修改的位置类不一样，请自行查找）：\n\n![](http://i.imgur.com/FFynHi2.png)\n\n细心点的读者可能会有个想法，既然超过65536会抛出具体的方法数错误，smali内部是有计算method的一套方法，直接在生成dex过程中读出不就好了？对的，既然我们拿到了源码，完全是可以利用其计算出来的数，免去dex-method-counts.jar计算方法数这一步，上面也说到了，这一步生成的dex只是用作计算，那是否生成dex就没有关系了，把smali内部计算的方法数保存到一个文件读取即可，不用等dex生成，也节省了时间。\n\n![](http://i.imgur.com/wr9Ii0c.png)\n\n截图中的opcodes.logFile是我们增加了命令行一个输入可选参数，用作保存记录方法数的文件路径。特别强调的是，smali的2.1.3和1.4.2版本差别较大，请注意修改。\n\n## filed的65536问题\n\n按照上述的步骤去打包测试，是可以正常生成可运行的apk，打开apk也可以发现有classes2.dex。但是在大量的测试过程中发现，有部分打包过程中出现filed的65536问题，这是比价少见的。查看源码，filed的确也会去做65536检验，当然还有type和string等，为了避免这种情况，我们在判断方法数阈值添加一个“与”判断，即同时判断filed是否也小于阈值，而对应的移动smali也同步计算filed的值，原理和method是一样的。注意的是，totalFiled需要和totalMethod一样，修改源码在生成dex过程中保存在读取的文件中。\n\n## 修改mainDexClasses.rules\n\n由于是用google官方推荐的classesN.dex方案，在5.0以下的系统必须添加依赖的jar包，即android-support-multidex.jar。由于加载classesN.dex的逻辑是android-support-multidex的代码里面，即必须保证该jar的类必须在主列表清单。测试发现，mainDexClasses生成的主列表清单并没有记录MultiDexExtractor和ZipUtil这两个类，所以需要我们手动添加过滤这两个类，具体修改在mainDexClasses.rules：\n\n![](http://i.imgur.com/roV1hbC.png)\n\n当然，你也可以在移动smali添加过滤以android.support.multidex开头的类不作移动。\n\n# Todo\n\n在本文介绍的处理方法关键是如何判断停止移动smali，上述的方法虽然可以保证主dex不会超过65536方法数，但是造成的误差有可能会给加载其他dex带来加载时间过长的不好体验，由于smali是在生成dex过程中读出的方法数，后续细读其源码能把主dex的方法数控制得更准确。","slug":"65536问题生成多dex处理","published":1,"updated":"2018-01-28T15:39:34.389Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjcyyg7j90002niuso4ugd0k7","content":"<h1 id=\"需求背景\"><a href=\"#需求背景\" class=\"headerlink\" title=\"需求背景\"></a>需求背景</h1><p>目前Android在处理65536的问题上提出了很多解决方案，google官方介绍的在Android studio上分dex开关控制是很多项目的首选，但这是基于源代码编译过程中去处理（或者说，在分完多dex后就是最终的apk包）。这里要说的一种业务场景，是提供一种方便接入第三方sdk平台的65536处理，区别于一次打包即可生成最终apk，这里是针对源apk（可以理解为通过开发工具打出的不接入任何三方sdk的可运行apk）通过选择不同接入第三方sdk二次编译打包而生成最终的apk场景。<a id=\"more\"></a>具体来说，就是通过对源apk的反编译生成的smali文件，和通过约定规范接口接入的第三方sdk反编译smali文件结合，再通过对smali文件回编生成一个最终apk的过程。当然了，中间涉及包括资源和AndroidManifest等一些处理，这里不展开细说，因为65536问题主要是代码层面的处理。</p>\n<h1 id=\"处理方案\"><a href=\"#处理方案\" class=\"headerlink\" title=\"处理方案\"></a>处理方案</h1><p>上述场景就不像Android studio提供的开关这么好处理了，因为即使上传的源apk方法数不超过65535，在合并第三方sdk的smali后难免会超过这个阈值，像接入单一个360这种sdk就已经有4w+的方法，这样回编肯定是不成功，这种场景下目前是没有很好的解决方案。业务初期提供了动态加载方案，即把接入多出的第三方sdk（像这里的360sdk）抽出dex动态加载，其他资源等处理不作改变，这样确实可以保证运行成功，而且启动速度也不会造成明显的影响。本以为这种方案可以后续推广，在接入360后提审返回结果竟然是不通过，原因在于360会检查我们的接入包是含有其代码文件，这就蛋疼了，因为我们把他们的代码都用作动态加载，反编译的包肯定是没有他们的代码文件。没想到还会有这种情况，这就让我们重新审视思考，能不能在现有的合并smali接入过程中做到像Android studio一样分dex？答案当然是可以。</p>\n<h1 id=\"道路是曲折的\"><a href=\"#道路是曲折的\" class=\"headerlink\" title=\"道路是曲折的\"></a>道路是曲折的</h1><h2 id=\"思考\"><a href=\"#思考\" class=\"headerlink\" title=\"思考\"></a>思考</h2><p>既然要在不影响整个接入打包流程做出改变，就必须思考几个问题：</p>\n<ol>\n<li>用什么方法去判断分出主从dex？</li>\n<li><p>方法数怎么计算？</p>\n<p> 事实上，上面两个问题都是依托当前的打包流程。因为中间涉及反编译的工具区分，业务初期采用的是apktool1.5.3，后面发现1.5.3版本不能适配Android后续推出的api版本。所以目前后台打包主要是使用apktool1.5.3、2.0.1和2.0.3三种打包空间，业务根据不同需要上传不同空间的源apk接入。这里面就有一个问题，经测试发现，不同apktool版本的处理是不一样的。具体来说，我们希望的是在后台合并完smali后分主从dex文件夹（smali和smali2），然后直接回编，这样最终的apk应该是有class.dex和classes2.dex。事与愿违，在1.5.3版本下回编是不会识别smali2这个文件夹的，就是说，最终回编的apk仅有classes.dex。这样就没辙了，既然用到人家的工具，就必须遵循他的一切规则和bug。不过在这个问题上还是很快地找到处理方法，就是根据打包版本区分处理，在1.5.3版本下另外对smali2文件生成classes2.dex。然后在最终回编的apk直接打入classes2.dex。</p>\n</li>\n</ol>\n<h2 id=\"第一点\"><a href=\"#第一点\" class=\"headerlink\" title=\"第一点\"></a>第一点</h2><p>关于第一个问题，我们参考了<a href=\"https://segmentfault.com/a/1190000004053072\" target=\"_blank\" rel=\"noopener\">dex分包变形记</a>，Android SDK 从 build tools 21 开始提供了 mainDexClasses 脚本来生成主 dex 的文件列表。这样就简单了，直接使用该jar包即可。命令示例如下：</p>\n<pre><code>mainDexClasses.bat --output d:\\dex.log **\\5.7release_20160923_2_dex2jar.jar --disable-annotation-resolution-workaround\n</code></pre><p>关键在于第二点，事实上我们在研发过程中也是在处理第二个问题上花费了不少时间，包括找到处理方案和考虑折衷的阈值。在这里先说明一点，在这个打包流程当中我们使用的是python语言。</p>\n<h2 id=\"第二点\"><a href=\"#第二点\" class=\"headerlink\" title=\"第二点\"></a>第二点</h2><p>首先，计算方法数不单单是“怎么算”，还要考虑“什么时候算”。我们知道，Android studio在2.2版本引入了分析apk的功能，可以看到apk的方法数</p>\n<p><img src=\"http://i.imgur.com/CeIPfJJ.png\" alt=\"\"></p>\n<p>这里注意的是，计算出来的有两个方法数，分别是6048和references的8235。</p>\n<p>我们可以用dex-method-counts.jar来计算上述jar包的方法数，得出的结果是8235。</p>\n<p><img src=\"http://i.imgur.com/whvQIJx.png\" alt=\"\"></p>\n<p>Android studio统计出来的两个数值有什么区别呢？通俗点来说，每个类里面的方法不单单只有自己类所定义的方法，还有引用了其他包或者是系统定义类的方法，而references统计出来的就是包含这些引用方法的数目。经测试发现，用apktool回编出现65536问题提示的统计方法数正式这个references所代表的数值。这样一看，貌似接下来就很明朗了，直接用现成的dex-method-counts.jar就可以在移动smali文件过程中计算究竟移动后的方法数。</p>\n<p>但是，这里面就涉及另外一个问题，我们知道，dex-method-counts.jar统计的是dex文件，而我们的文件单位是smali，难道每移动一次就要用smlia工具生成dex再计算？这样所耗费的时间可想而知，因为我们并不能控制移动的次数。这样就迫使我们要考虑是继续查找其他计算方法还是在现有的基础上选择合适的计算时机。</p>\n<h3 id=\"计算-method方法数\"><a href=\"#计算-method方法数\" class=\"headerlink\" title=\"计算.method方法数\"></a>计算.method方法数</h3><p>参考 <a href=\"http://blog.csdn.net/chenjie19891104/article/details/51258183\" target=\"_blank\" rel=\"noopener\">U8SDK——支持自动拆分成多个dex文件(MultiDex支持)</a>一文，发现了另外一种计算思路，即 直接计算smali文件的以.method开头的数目来计算当前smali文件的方法数。通过测试，该方法只是计算当前smali的直接方法数（即该samli定义的方法数，不包含引用数），我们从Android studio的计算方式知道，这样计算出来的方法数并不符合我们预期，因为肯定会比回编的smali工具计算得少（因为统计的是references方法数）。但是这里有一个思路，既然用这种方法统计出来的方法数是比正常统计的少，那么在移动smali计算过程中移动后所剩下smali的方法数肯定是比阈值要低。简单的计算公式：</p>\n<pre><code>remainMethod = totalMethod - moveMethod\n</code></pre><p>这里具体解释一下操作。首先，我们在合并完smali文件后利用smali工具把合并后的smali文件生成dex，然后直接用dex-method-counts.jar计算该dex的方法数，这个数就是totalMethod，是准确的。然后开始移动smali，每操作一个smali文件之前，先用计算.method数的方法来粗略计算该smali的方法数，这个数就是moveMethod，在移动到smali2文件夹后，再判断remainMethod是否大于阈值（这里可以直接设置65536），如果是大于，继续做移动操作，否则停止移动。由于remainMethod比准确的剩余方法数要少，所以这个方法数即使是有误差但也是安全低于设置的阈值。</p>\n<h2 id=\"修改smali源码\"><a href=\"#修改smali源码\" class=\"headerlink\" title=\"修改smali源码\"></a>修改smali源码</h2><p>一切障碍放佛都已经扫清，可以直接编写代码测试。没想到在合并完smali文件生成dex过程中就抛出方法数超过65536的错误。真是百密一疏，忽略了apktool其实也是依赖smali.jar来计算方法数啊，这岂不是一个endless loop？且慢，考虑到我们这一步只是用来计算方法数，生成的dex对于我们而言是没有作用的，换句话说，我们直接把判断抛错的地方注释掉不就行了？感谢smali开放了源码，注意的是，由于smali我们是用apktool反编译的apk，所以要和我们的apktool版本所用的smali.jar版本一致，这个可以查看apktool的jar得知：</p>\n<p><img src=\"http://i.imgur.com/b1Adfdy.png\" alt=\"\"></p>\n<p><img src=\"http://i.imgur.com/XacVseY.png\" alt=\"\"></p>\n<p>截图分别对应的是1.5.3和2.0.1的信息。进入<a href=\"https://github.com/JesusFreke/smali\" target=\"_blank\" rel=\"noopener\">smali</a>的托管代码下载对应的源码，我们选用的是1.4.2和2.1.3版本。根据抛出的错误信息找到对应要注释的位置（下面面的源码修改只截图2.1.3版本，注意1.4.2修改的位置类不一样，请自行查找）：</p>\n<p><img src=\"http://i.imgur.com/FFynHi2.png\" alt=\"\"></p>\n<p>细心点的读者可能会有个想法，既然超过65536会抛出具体的方法数错误，smali内部是有计算method的一套方法，直接在生成dex过程中读出不就好了？对的，既然我们拿到了源码，完全是可以利用其计算出来的数，免去dex-method-counts.jar计算方法数这一步，上面也说到了，这一步生成的dex只是用作计算，那是否生成dex就没有关系了，把smali内部计算的方法数保存到一个文件读取即可，不用等dex生成，也节省了时间。</p>\n<p><img src=\"http://i.imgur.com/wr9Ii0c.png\" alt=\"\"></p>\n<p>截图中的opcodes.logFile是我们增加了命令行一个输入可选参数，用作保存记录方法数的文件路径。特别强调的是，smali的2.1.3和1.4.2版本差别较大，请注意修改。</p>\n<h2 id=\"filed的65536问题\"><a href=\"#filed的65536问题\" class=\"headerlink\" title=\"filed的65536问题\"></a>filed的65536问题</h2><p>按照上述的步骤去打包测试，是可以正常生成可运行的apk，打开apk也可以发现有classes2.dex。但是在大量的测试过程中发现，有部分打包过程中出现filed的65536问题，这是比价少见的。查看源码，filed的确也会去做65536检验，当然还有type和string等，为了避免这种情况，我们在判断方法数阈值添加一个“与”判断，即同时判断filed是否也小于阈值，而对应的移动smali也同步计算filed的值，原理和method是一样的。注意的是，totalFiled需要和totalMethod一样，修改源码在生成dex过程中保存在读取的文件中。</p>\n<h2 id=\"修改mainDexClasses-rules\"><a href=\"#修改mainDexClasses-rules\" class=\"headerlink\" title=\"修改mainDexClasses.rules\"></a>修改mainDexClasses.rules</h2><p>由于是用google官方推荐的classesN.dex方案，在5.0以下的系统必须添加依赖的jar包，即android-support-multidex.jar。由于加载classesN.dex的逻辑是android-support-multidex的代码里面，即必须保证该jar的类必须在主列表清单。测试发现，mainDexClasses生成的主列表清单并没有记录MultiDexExtractor和ZipUtil这两个类，所以需要我们手动添加过滤这两个类，具体修改在mainDexClasses.rules：</p>\n<p><img src=\"http://i.imgur.com/roV1hbC.png\" alt=\"\"></p>\n<p>当然，你也可以在移动smali添加过滤以android.support.multidex开头的类不作移动。</p>\n<h1 id=\"Todo\"><a href=\"#Todo\" class=\"headerlink\" title=\"Todo\"></a>Todo</h1><p>在本文介绍的处理方法关键是如何判断停止移动smali，上述的方法虽然可以保证主dex不会超过65536方法数，但是造成的误差有可能会给加载其他dex带来加载时间过长的不好体验，由于smali是在生成dex过程中读出的方法数，后续细读其源码能把主dex的方法数控制得更准确。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"需求背景\"><a href=\"#需求背景\" class=\"headerlink\" title=\"需求背景\"></a>需求背景</h1><p>目前Android在处理65536的问题上提出了很多解决方案，google官方介绍的在Android studio上分dex开关控制是很多项目的首选，但这是基于源代码编译过程中去处理（或者说，在分完多dex后就是最终的apk包）。这里要说的一种业务场景，是提供一种方便接入第三方sdk平台的65536处理，区别于一次打包即可生成最终apk，这里是针对源apk（可以理解为通过开发工具打出的不接入任何三方sdk的可运行apk）通过选择不同接入第三方sdk二次编译打包而生成最终的apk场景。","more":"具体来说，就是通过对源apk的反编译生成的smali文件，和通过约定规范接口接入的第三方sdk反编译smali文件结合，再通过对smali文件回编生成一个最终apk的过程。当然了，中间涉及包括资源和AndroidManifest等一些处理，这里不展开细说，因为65536问题主要是代码层面的处理。</p>\n<h1 id=\"处理方案\"><a href=\"#处理方案\" class=\"headerlink\" title=\"处理方案\"></a>处理方案</h1><p>上述场景就不像Android studio提供的开关这么好处理了，因为即使上传的源apk方法数不超过65535，在合并第三方sdk的smali后难免会超过这个阈值，像接入单一个360这种sdk就已经有4w+的方法，这样回编肯定是不成功，这种场景下目前是没有很好的解决方案。业务初期提供了动态加载方案，即把接入多出的第三方sdk（像这里的360sdk）抽出dex动态加载，其他资源等处理不作改变，这样确实可以保证运行成功，而且启动速度也不会造成明显的影响。本以为这种方案可以后续推广，在接入360后提审返回结果竟然是不通过，原因在于360会检查我们的接入包是含有其代码文件，这就蛋疼了，因为我们把他们的代码都用作动态加载，反编译的包肯定是没有他们的代码文件。没想到还会有这种情况，这就让我们重新审视思考，能不能在现有的合并smali接入过程中做到像Android studio一样分dex？答案当然是可以。</p>\n<h1 id=\"道路是曲折的\"><a href=\"#道路是曲折的\" class=\"headerlink\" title=\"道路是曲折的\"></a>道路是曲折的</h1><h2 id=\"思考\"><a href=\"#思考\" class=\"headerlink\" title=\"思考\"></a>思考</h2><p>既然要在不影响整个接入打包流程做出改变，就必须思考几个问题：</p>\n<ol>\n<li>用什么方法去判断分出主从dex？</li>\n<li><p>方法数怎么计算？</p>\n<p> 事实上，上面两个问题都是依托当前的打包流程。因为中间涉及反编译的工具区分，业务初期采用的是apktool1.5.3，后面发现1.5.3版本不能适配Android后续推出的api版本。所以目前后台打包主要是使用apktool1.5.3、2.0.1和2.0.3三种打包空间，业务根据不同需要上传不同空间的源apk接入。这里面就有一个问题，经测试发现，不同apktool版本的处理是不一样的。具体来说，我们希望的是在后台合并完smali后分主从dex文件夹（smali和smali2），然后直接回编，这样最终的apk应该是有class.dex和classes2.dex。事与愿违，在1.5.3版本下回编是不会识别smali2这个文件夹的，就是说，最终回编的apk仅有classes.dex。这样就没辙了，既然用到人家的工具，就必须遵循他的一切规则和bug。不过在这个问题上还是很快地找到处理方法，就是根据打包版本区分处理，在1.5.3版本下另外对smali2文件生成classes2.dex。然后在最终回编的apk直接打入classes2.dex。</p>\n</li>\n</ol>\n<h2 id=\"第一点\"><a href=\"#第一点\" class=\"headerlink\" title=\"第一点\"></a>第一点</h2><p>关于第一个问题，我们参考了<a href=\"https://segmentfault.com/a/1190000004053072\" target=\"_blank\" rel=\"noopener\">dex分包变形记</a>，Android SDK 从 build tools 21 开始提供了 mainDexClasses 脚本来生成主 dex 的文件列表。这样就简单了，直接使用该jar包即可。命令示例如下：</p>\n<pre><code>mainDexClasses.bat --output d:\\dex.log **\\5.7release_20160923_2_dex2jar.jar --disable-annotation-resolution-workaround\n</code></pre><p>关键在于第二点，事实上我们在研发过程中也是在处理第二个问题上花费了不少时间，包括找到处理方案和考虑折衷的阈值。在这里先说明一点，在这个打包流程当中我们使用的是python语言。</p>\n<h2 id=\"第二点\"><a href=\"#第二点\" class=\"headerlink\" title=\"第二点\"></a>第二点</h2><p>首先，计算方法数不单单是“怎么算”，还要考虑“什么时候算”。我们知道，Android studio在2.2版本引入了分析apk的功能，可以看到apk的方法数</p>\n<p><img src=\"http://i.imgur.com/CeIPfJJ.png\" alt=\"\"></p>\n<p>这里注意的是，计算出来的有两个方法数，分别是6048和references的8235。</p>\n<p>我们可以用dex-method-counts.jar来计算上述jar包的方法数，得出的结果是8235。</p>\n<p><img src=\"http://i.imgur.com/whvQIJx.png\" alt=\"\"></p>\n<p>Android studio统计出来的两个数值有什么区别呢？通俗点来说，每个类里面的方法不单单只有自己类所定义的方法，还有引用了其他包或者是系统定义类的方法，而references统计出来的就是包含这些引用方法的数目。经测试发现，用apktool回编出现65536问题提示的统计方法数正式这个references所代表的数值。这样一看，貌似接下来就很明朗了，直接用现成的dex-method-counts.jar就可以在移动smali文件过程中计算究竟移动后的方法数。</p>\n<p>但是，这里面就涉及另外一个问题，我们知道，dex-method-counts.jar统计的是dex文件，而我们的文件单位是smali，难道每移动一次就要用smlia工具生成dex再计算？这样所耗费的时间可想而知，因为我们并不能控制移动的次数。这样就迫使我们要考虑是继续查找其他计算方法还是在现有的基础上选择合适的计算时机。</p>\n<h3 id=\"计算-method方法数\"><a href=\"#计算-method方法数\" class=\"headerlink\" title=\"计算.method方法数\"></a>计算.method方法数</h3><p>参考 <a href=\"http://blog.csdn.net/chenjie19891104/article/details/51258183\" target=\"_blank\" rel=\"noopener\">U8SDK——支持自动拆分成多个dex文件(MultiDex支持)</a>一文，发现了另外一种计算思路，即 直接计算smali文件的以.method开头的数目来计算当前smali文件的方法数。通过测试，该方法只是计算当前smali的直接方法数（即该samli定义的方法数，不包含引用数），我们从Android studio的计算方式知道，这样计算出来的方法数并不符合我们预期，因为肯定会比回编的smali工具计算得少（因为统计的是references方法数）。但是这里有一个思路，既然用这种方法统计出来的方法数是比正常统计的少，那么在移动smali计算过程中移动后所剩下smali的方法数肯定是比阈值要低。简单的计算公式：</p>\n<pre><code>remainMethod = totalMethod - moveMethod\n</code></pre><p>这里具体解释一下操作。首先，我们在合并完smali文件后利用smali工具把合并后的smali文件生成dex，然后直接用dex-method-counts.jar计算该dex的方法数，这个数就是totalMethod，是准确的。然后开始移动smali，每操作一个smali文件之前，先用计算.method数的方法来粗略计算该smali的方法数，这个数就是moveMethod，在移动到smali2文件夹后，再判断remainMethod是否大于阈值（这里可以直接设置65536），如果是大于，继续做移动操作，否则停止移动。由于remainMethod比准确的剩余方法数要少，所以这个方法数即使是有误差但也是安全低于设置的阈值。</p>\n<h2 id=\"修改smali源码\"><a href=\"#修改smali源码\" class=\"headerlink\" title=\"修改smali源码\"></a>修改smali源码</h2><p>一切障碍放佛都已经扫清，可以直接编写代码测试。没想到在合并完smali文件生成dex过程中就抛出方法数超过65536的错误。真是百密一疏，忽略了apktool其实也是依赖smali.jar来计算方法数啊，这岂不是一个endless loop？且慢，考虑到我们这一步只是用来计算方法数，生成的dex对于我们而言是没有作用的，换句话说，我们直接把判断抛错的地方注释掉不就行了？感谢smali开放了源码，注意的是，由于smali我们是用apktool反编译的apk，所以要和我们的apktool版本所用的smali.jar版本一致，这个可以查看apktool的jar得知：</p>\n<p><img src=\"http://i.imgur.com/b1Adfdy.png\" alt=\"\"></p>\n<p><img src=\"http://i.imgur.com/XacVseY.png\" alt=\"\"></p>\n<p>截图分别对应的是1.5.3和2.0.1的信息。进入<a href=\"https://github.com/JesusFreke/smali\" target=\"_blank\" rel=\"noopener\">smali</a>的托管代码下载对应的源码，我们选用的是1.4.2和2.1.3版本。根据抛出的错误信息找到对应要注释的位置（下面面的源码修改只截图2.1.3版本，注意1.4.2修改的位置类不一样，请自行查找）：</p>\n<p><img src=\"http://i.imgur.com/FFynHi2.png\" alt=\"\"></p>\n<p>细心点的读者可能会有个想法，既然超过65536会抛出具体的方法数错误，smali内部是有计算method的一套方法，直接在生成dex过程中读出不就好了？对的，既然我们拿到了源码，完全是可以利用其计算出来的数，免去dex-method-counts.jar计算方法数这一步，上面也说到了，这一步生成的dex只是用作计算，那是否生成dex就没有关系了，把smali内部计算的方法数保存到一个文件读取即可，不用等dex生成，也节省了时间。</p>\n<p><img src=\"http://i.imgur.com/wr9Ii0c.png\" alt=\"\"></p>\n<p>截图中的opcodes.logFile是我们增加了命令行一个输入可选参数，用作保存记录方法数的文件路径。特别强调的是，smali的2.1.3和1.4.2版本差别较大，请注意修改。</p>\n<h2 id=\"filed的65536问题\"><a href=\"#filed的65536问题\" class=\"headerlink\" title=\"filed的65536问题\"></a>filed的65536问题</h2><p>按照上述的步骤去打包测试，是可以正常生成可运行的apk，打开apk也可以发现有classes2.dex。但是在大量的测试过程中发现，有部分打包过程中出现filed的65536问题，这是比价少见的。查看源码，filed的确也会去做65536检验，当然还有type和string等，为了避免这种情况，我们在判断方法数阈值添加一个“与”判断，即同时判断filed是否也小于阈值，而对应的移动smali也同步计算filed的值，原理和method是一样的。注意的是，totalFiled需要和totalMethod一样，修改源码在生成dex过程中保存在读取的文件中。</p>\n<h2 id=\"修改mainDexClasses-rules\"><a href=\"#修改mainDexClasses-rules\" class=\"headerlink\" title=\"修改mainDexClasses.rules\"></a>修改mainDexClasses.rules</h2><p>由于是用google官方推荐的classesN.dex方案，在5.0以下的系统必须添加依赖的jar包，即android-support-multidex.jar。由于加载classesN.dex的逻辑是android-support-multidex的代码里面，即必须保证该jar的类必须在主列表清单。测试发现，mainDexClasses生成的主列表清单并没有记录MultiDexExtractor和ZipUtil这两个类，所以需要我们手动添加过滤这两个类，具体修改在mainDexClasses.rules：</p>\n<p><img src=\"http://i.imgur.com/roV1hbC.png\" alt=\"\"></p>\n<p>当然，你也可以在移动smali添加过滤以android.support.multidex开头的类不作移动。</p>\n<h1 id=\"Todo\"><a href=\"#Todo\" class=\"headerlink\" title=\"Todo\"></a>Todo</h1><p>在本文介绍的处理方法关键是如何判断停止移动smali，上述的方法虽然可以保证主dex不会超过65536方法数，但是造成的误差有可能会给加载其他dex带来加载时间过长的不好体验，由于smali是在生成dex过程中读出的方法数，后续细读其源码能把主dex的方法数控制得更准确。</p>"},{"title":"Android冗余or重复资源处理","date":"2018-01-28T15:39:34.389Z","_content":"\n\n# 前言\n\n项目组在优化apk包体大小时，有一项是删除项目中冗余or重复资源，这对于自家app资源文件处理是很简单的，只要找到对应的资源文件删除即可。但是在删除过程中，发现有一些资源文件并不是很好的处理：\n\n- 集成第三方sdk的资源文件\n- 不同module的冗余资源\n- google 提供的v4包等也扫出冗余资源\n\n针对上面几个场景扫出的资源，在编译前处理就显得无能为力。google提供的shrinkResources可以去除无用资源，但反编译发现，shrinkResources扫描出来的无用资源并没有删除，只是变成空文件（.xml）或变成67字节文件（.png）。有没有办法在生成apk后进行处理？笔者参考 [AndResGuard](https://github.com/shwenzhang/AndResGuard) 实现方式，在AndResGuard基础上实现了只输入apk即可真正删除冗余or无用资源。\n\n# 思路\n\n这里分别就冗余和无用资源的删除做下简要实现流程：\n\n- ***冗余资源***\n\n1. 扫描apk（zip格式）各文件的CRC\n2. 筛选CRC相同对应的文件路径，即这些文件都是相同的，只需要保留扫描出来的第一个文件路径\n3. 重新生成resource.arsc，修改StringBlock，具体即把重复的资源路径全部替换成扫描出来第一份文件的路径\n4. 之后的几个chunk原原本本copy一次，重写整份resource.arsc的size\n5. 删除重复资源\n\n- ***无用资源***\n\n1. AS gradle设置 shrinkResources true***（必须）***\n2. 扫描apk（zip格式）各文件的CRC\n3. shrinkResources 扫描出来的无用代码文件，都会替换成预定义资源，其CRC定义是：\n\n![](https://github.com/hellokugo/markdownPic/blob/master/dupilcate.png)\n\n4.删除上述三种CRC文件\n\n## 核心代码\n\nTalk is cheap，show me the code. 说明一点，笔者是在AndResGuard基础上开发，一是没必要重复造轮子，二是resource.arsc字节码文件处理要特别小心，特别是修改StringBlock要注意四个字节对齐问题，AndResGuard本身是支持这一点，所以就站在巨人肩膀上开发。\n\n\n获取CRC：\n\n\tUtils.java\n\tmethod:getZipCrc(add)\n\t\n\tpublic static Map<String, String> getZipCrc(String apkPath) {\n        Map<Long, String> resMap = new HashMap<>();\n        Map<String, String> duplicateMap = new HashMap<>();\n        try {\n            ZipFile zipFile = new ZipFile(apkPath);\n            Enumeration e = zipFile.entries();\n\n            while (e.hasMoreElements()) {\n                ZipEntry entry = (ZipEntry) e.nextElement();\n                String entryName = entry.getName();\n                long crc = entry.getCrc();\n                if (entryName.startsWith(\"res/\")) {\n                    //record useless files\n                    if (\"2293408688\".equals(Long.toString(crc)) ||\n                        \"289995143\".equals(Long.toString(crc)) ||\n                        \"3622196803\".equals(Long.toString(crc))) {\n                        duplicateMap.put(entryName, \"\");\n                        continue;\n                    }\n                    //record duplicate files\n                    if (resMap.containsKey(crc)) {\n                        duplicateMap.put(entryName, resMap.get(crc));\n                    } else {\n                        resMap.put(crc, entryName);\n                    }\n                }\n            }\n            zipFile.close();\n            return duplicateMap;\n\n        } catch (IOException ioe) {\n            System.out.printf(\"Error opening zip file\" + ioe);\n            return null;\n        }\n    }\n    \n修改StringBlock：\n\n\tStringBlock.java\n\tmethod:writeTableNameStringBlock\n\t\n\tfor (i = 0; i < stringCount; i++) {\n            stringOffsets[i] = offset;\n            String originStr = getString(i);\n            //如果没有duplicatedFile,直接拷贝\n            if (duplicatedFile == null || !duplicatedFile.containsKey(originStr)) {\n                //需要区分是否是最后一项\n                int copyLen = (i == (stringCount - 1)) ? (block.m_strings.length - block.m_stringOffsets[i]) : (block.m_stringOffsets[i + 1] - block.m_stringOffsets[i]);\n                System.arraycopy(block.m_strings, block.m_stringOffsets[i], strings, offset, copyLen);\n                offset += copyLen;\n                totalSize += copyLen;\n            } else {\n                String name = duplicatedFile.get(originStr);\n                //是无用资源，无需修改StringBlock\n                if(\"\".equals(name)) {\n                    continue;\n                }\n                if (block.m_isUTF8) {\n                    strings[offset++] = (byte) name.length();\n                    strings[offset++] = (byte) name.length();\n                    ......\n                    \n删除冗余or无用资源：\n\n\tResourceApkBuilder.java\n\tmethod:generalUnsignApk\n\t\n        for (File f : unzipFiles) {\n            String name = f.getName();\n            if (name.equals(\"resources.arsc\")) {\n                continue;\n            } else if (name.equals(\"res\")) {\n                //删除重复文件\n                if (duplicateMap != null && duplicateMap.size() > 0) {\n                    for (String duplicatePath : duplicateMap.keySet()) {               \n                        File duplicateFile = new File(tempOutDir, duplicatePath);          \n                        if (duplicateFile.exists()) {\n                            duplicateFile.delete();          \n                        }\n                    }\n                }\n                continue;\n            } else if (name.equals(config.mMetaName)) {\n                addNonSignatureFiles(collectFiles, f);\n                continue;\n            }\n            collectFiles.add(f);\n        }\n\n# 最后\n\n目前该jar应用在项目jenkins持续集成中，无需手动扫描并删除资源，而且解决之前因各种原因无法在编译前删除对应资源的问题。不过目前该jar仍需完善，像无用资源并没有在resource.arsc删除对应的item，没处理在打包过后插进META-INF的无用文件等等，这个可以根据项目的实际需要再做完善。","source":"_posts/Android冗余or重复资源处理.md","raw":"title: Android冗余or重复资源处理\ndate: 2018/1/28 12：25\n\ncategories:\n- Android\ntags:\n- Android，AndResguard\n---\n\n\n# 前言\n\n项目组在优化apk包体大小时，有一项是删除项目中冗余or重复资源，这对于自家app资源文件处理是很简单的，只要找到对应的资源文件删除即可。但是在删除过程中，发现有一些资源文件并不是很好的处理：\n\n- 集成第三方sdk的资源文件\n- 不同module的冗余资源\n- google 提供的v4包等也扫出冗余资源\n\n针对上面几个场景扫出的资源，在编译前处理就显得无能为力。google提供的shrinkResources可以去除无用资源，但反编译发现，shrinkResources扫描出来的无用资源并没有删除，只是变成空文件（.xml）或变成67字节文件（.png）。有没有办法在生成apk后进行处理？笔者参考 [AndResGuard](https://github.com/shwenzhang/AndResGuard) 实现方式，在AndResGuard基础上实现了只输入apk即可真正删除冗余or无用资源。\n\n# 思路\n\n这里分别就冗余和无用资源的删除做下简要实现流程：\n\n- ***冗余资源***\n\n1. 扫描apk（zip格式）各文件的CRC\n2. 筛选CRC相同对应的文件路径，即这些文件都是相同的，只需要保留扫描出来的第一个文件路径\n3. 重新生成resource.arsc，修改StringBlock，具体即把重复的资源路径全部替换成扫描出来第一份文件的路径\n4. 之后的几个chunk原原本本copy一次，重写整份resource.arsc的size\n5. 删除重复资源\n\n- ***无用资源***\n\n1. AS gradle设置 shrinkResources true***（必须）***\n2. 扫描apk（zip格式）各文件的CRC\n3. shrinkResources 扫描出来的无用代码文件，都会替换成预定义资源，其CRC定义是：\n\n![](https://github.com/hellokugo/markdownPic/blob/master/dupilcate.png)\n\n4.删除上述三种CRC文件\n\n## 核心代码\n\nTalk is cheap，show me the code. 说明一点，笔者是在AndResGuard基础上开发，一是没必要重复造轮子，二是resource.arsc字节码文件处理要特别小心，特别是修改StringBlock要注意四个字节对齐问题，AndResGuard本身是支持这一点，所以就站在巨人肩膀上开发。\n\n\n获取CRC：\n\n\tUtils.java\n\tmethod:getZipCrc(add)\n\t\n\tpublic static Map<String, String> getZipCrc(String apkPath) {\n        Map<Long, String> resMap = new HashMap<>();\n        Map<String, String> duplicateMap = new HashMap<>();\n        try {\n            ZipFile zipFile = new ZipFile(apkPath);\n            Enumeration e = zipFile.entries();\n\n            while (e.hasMoreElements()) {\n                ZipEntry entry = (ZipEntry) e.nextElement();\n                String entryName = entry.getName();\n                long crc = entry.getCrc();\n                if (entryName.startsWith(\"res/\")) {\n                    //record useless files\n                    if (\"2293408688\".equals(Long.toString(crc)) ||\n                        \"289995143\".equals(Long.toString(crc)) ||\n                        \"3622196803\".equals(Long.toString(crc))) {\n                        duplicateMap.put(entryName, \"\");\n                        continue;\n                    }\n                    //record duplicate files\n                    if (resMap.containsKey(crc)) {\n                        duplicateMap.put(entryName, resMap.get(crc));\n                    } else {\n                        resMap.put(crc, entryName);\n                    }\n                }\n            }\n            zipFile.close();\n            return duplicateMap;\n\n        } catch (IOException ioe) {\n            System.out.printf(\"Error opening zip file\" + ioe);\n            return null;\n        }\n    }\n    \n修改StringBlock：\n\n\tStringBlock.java\n\tmethod:writeTableNameStringBlock\n\t\n\tfor (i = 0; i < stringCount; i++) {\n            stringOffsets[i] = offset;\n            String originStr = getString(i);\n            //如果没有duplicatedFile,直接拷贝\n            if (duplicatedFile == null || !duplicatedFile.containsKey(originStr)) {\n                //需要区分是否是最后一项\n                int copyLen = (i == (stringCount - 1)) ? (block.m_strings.length - block.m_stringOffsets[i]) : (block.m_stringOffsets[i + 1] - block.m_stringOffsets[i]);\n                System.arraycopy(block.m_strings, block.m_stringOffsets[i], strings, offset, copyLen);\n                offset += copyLen;\n                totalSize += copyLen;\n            } else {\n                String name = duplicatedFile.get(originStr);\n                //是无用资源，无需修改StringBlock\n                if(\"\".equals(name)) {\n                    continue;\n                }\n                if (block.m_isUTF8) {\n                    strings[offset++] = (byte) name.length();\n                    strings[offset++] = (byte) name.length();\n                    ......\n                    \n删除冗余or无用资源：\n\n\tResourceApkBuilder.java\n\tmethod:generalUnsignApk\n\t\n        for (File f : unzipFiles) {\n            String name = f.getName();\n            if (name.equals(\"resources.arsc\")) {\n                continue;\n            } else if (name.equals(\"res\")) {\n                //删除重复文件\n                if (duplicateMap != null && duplicateMap.size() > 0) {\n                    for (String duplicatePath : duplicateMap.keySet()) {               \n                        File duplicateFile = new File(tempOutDir, duplicatePath);          \n                        if (duplicateFile.exists()) {\n                            duplicateFile.delete();          \n                        }\n                    }\n                }\n                continue;\n            } else if (name.equals(config.mMetaName)) {\n                addNonSignatureFiles(collectFiles, f);\n                continue;\n            }\n            collectFiles.add(f);\n        }\n\n# 最后\n\n目前该jar应用在项目jenkins持续集成中，无需手动扫描并删除资源，而且解决之前因各种原因无法在编译前删除对应资源的问题。不过目前该jar仍需完善，像无用资源并没有在resource.arsc删除对应的item，没处理在打包过后插进META-INF的无用文件等等，这个可以根据项目的实际需要再做完善。","slug":"Android冗余or重复资源处理","published":1,"updated":"2018-01-28T15:39:34.389Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjcyyg7jg0003niusfyp73gk3","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>项目组在优化apk包体大小时，有一项是删除项目中冗余or重复资源，这对于自家app资源文件处理是很简单的，只要找到对应的资源文件删除即可。但是在删除过程中，发现有一些资源文件并不是很好的处理：</p>\n<ul>\n<li>集成第三方sdk的资源文件</li>\n<li>不同module的冗余资源</li>\n<li>google 提供的v4包等也扫出冗余资源</li>\n</ul>\n<p>针对上面几个场景扫出的资源，在编译前处理就显得无能为力。google提供的shrinkResources可以去除无用资源，但反编译发现，shrinkResources扫描出来的无用资源并没有删除，只是变成空文件（.xml）或变成67字节文件（.png）。有没有办法在生成apk后进行处理？笔者参考 <a href=\"https://github.com/shwenzhang/AndResGuard\" target=\"_blank\" rel=\"noopener\">AndResGuard</a> 实现方式，在AndResGuard基础上实现了只输入apk即可真正删除冗余or无用资源。</p>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>这里分别就冗余和无用资源的删除做下简要实现流程：</p>\n<ul>\n<li><strong><em>冗余资源</em></strong></li>\n</ul>\n<ol>\n<li>扫描apk（zip格式）各文件的CRC</li>\n<li>筛选CRC相同对应的文件路径，即这些文件都是相同的，只需要保留扫描出来的第一个文件路径</li>\n<li>重新生成resource.arsc，修改StringBlock，具体即把重复的资源路径全部替换成扫描出来第一份文件的路径</li>\n<li>之后的几个chunk原原本本copy一次，重写整份resource.arsc的size</li>\n<li>删除重复资源</li>\n</ol>\n<ul>\n<li><strong><em>无用资源</em></strong></li>\n</ul>\n<ol>\n<li>AS gradle设置 shrinkResources true<strong><em>（必须）</em></strong></li>\n<li>扫描apk（zip格式）各文件的CRC</li>\n<li>shrinkResources 扫描出来的无用代码文件，都会替换成预定义资源，其CRC定义是：</li>\n</ol>\n<p><img src=\"https://github.com/hellokugo/markdownPic/blob/master/dupilcate.png\" alt=\"\"></p>\n<p>4.删除上述三种CRC文件</p>\n<h2 id=\"核心代码\"><a href=\"#核心代码\" class=\"headerlink\" title=\"核心代码\"></a>核心代码</h2><p>Talk is cheap，show me the code. 说明一点，笔者是在AndResGuard基础上开发，一是没必要重复造轮子，二是resource.arsc字节码文件处理要特别小心，特别是修改StringBlock要注意四个字节对齐问题，AndResGuard本身是支持这一点，所以就站在巨人肩膀上开发。</p>\n<p>获取CRC：</p>\n<pre><code>Utils.java\nmethod:getZipCrc(add)\n\npublic static Map&lt;String, String&gt; getZipCrc(String apkPath) {\n    Map&lt;Long, String&gt; resMap = new HashMap&lt;&gt;();\n    Map&lt;String, String&gt; duplicateMap = new HashMap&lt;&gt;();\n    try {\n        ZipFile zipFile = new ZipFile(apkPath);\n        Enumeration e = zipFile.entries();\n\n        while (e.hasMoreElements()) {\n            ZipEntry entry = (ZipEntry) e.nextElement();\n            String entryName = entry.getName();\n            long crc = entry.getCrc();\n            if (entryName.startsWith(&quot;res/&quot;)) {\n                //record useless files\n                if (&quot;2293408688&quot;.equals(Long.toString(crc)) ||\n                    &quot;289995143&quot;.equals(Long.toString(crc)) ||\n                    &quot;3622196803&quot;.equals(Long.toString(crc))) {\n                    duplicateMap.put(entryName, &quot;&quot;);\n                    continue;\n                }\n                //record duplicate files\n                if (resMap.containsKey(crc)) {\n                    duplicateMap.put(entryName, resMap.get(crc));\n                } else {\n                    resMap.put(crc, entryName);\n                }\n            }\n        }\n        zipFile.close();\n        return duplicateMap;\n\n    } catch (IOException ioe) {\n        System.out.printf(&quot;Error opening zip file&quot; + ioe);\n        return null;\n    }\n}\n</code></pre><p>修改StringBlock：</p>\n<pre><code>StringBlock.java\nmethod:writeTableNameStringBlock\n\nfor (i = 0; i &lt; stringCount; i++) {\n        stringOffsets[i] = offset;\n        String originStr = getString(i);\n        //如果没有duplicatedFile,直接拷贝\n        if (duplicatedFile == null || !duplicatedFile.containsKey(originStr)) {\n            //需要区分是否是最后一项\n            int copyLen = (i == (stringCount - 1)) ? (block.m_strings.length - block.m_stringOffsets[i]) : (block.m_stringOffsets[i + 1] - block.m_stringOffsets[i]);\n            System.arraycopy(block.m_strings, block.m_stringOffsets[i], strings, offset, copyLen);\n            offset += copyLen;\n            totalSize += copyLen;\n        } else {\n            String name = duplicatedFile.get(originStr);\n            //是无用资源，无需修改StringBlock\n            if(&quot;&quot;.equals(name)) {\n                continue;\n            }\n            if (block.m_isUTF8) {\n                strings[offset++] = (byte) name.length();\n                strings[offset++] = (byte) name.length();\n                ......\n</code></pre><p>删除冗余or无用资源：</p>\n<pre><code>ResourceApkBuilder.java\nmethod:generalUnsignApk\n\n    for (File f : unzipFiles) {\n        String name = f.getName();\n        if (name.equals(&quot;resources.arsc&quot;)) {\n            continue;\n        } else if (name.equals(&quot;res&quot;)) {\n            //删除重复文件\n            if (duplicateMap != null &amp;&amp; duplicateMap.size() &gt; 0) {\n                for (String duplicatePath : duplicateMap.keySet()) {               \n                    File duplicateFile = new File(tempOutDir, duplicatePath);          \n                    if (duplicateFile.exists()) {\n                        duplicateFile.delete();          \n                    }\n                }\n            }\n            continue;\n        } else if (name.equals(config.mMetaName)) {\n            addNonSignatureFiles(collectFiles, f);\n            continue;\n        }\n        collectFiles.add(f);\n    }\n</code></pre><h1 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h1><p>目前该jar应用在项目jenkins持续集成中，无需手动扫描并删除资源，而且解决之前因各种原因无法在编译前删除对应资源的问题。不过目前该jar仍需完善，像无用资源并没有在resource.arsc删除对应的item，没处理在打包过后插进META-INF的无用文件等等，这个可以根据项目的实际需要再做完善。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>项目组在优化apk包体大小时，有一项是删除项目中冗余or重复资源，这对于自家app资源文件处理是很简单的，只要找到对应的资源文件删除即可。但是在删除过程中，发现有一些资源文件并不是很好的处理：</p>\n<ul>\n<li>集成第三方sdk的资源文件</li>\n<li>不同module的冗余资源</li>\n<li>google 提供的v4包等也扫出冗余资源</li>\n</ul>\n<p>针对上面几个场景扫出的资源，在编译前处理就显得无能为力。google提供的shrinkResources可以去除无用资源，但反编译发现，shrinkResources扫描出来的无用资源并没有删除，只是变成空文件（.xml）或变成67字节文件（.png）。有没有办法在生成apk后进行处理？笔者参考 <a href=\"https://github.com/shwenzhang/AndResGuard\" target=\"_blank\" rel=\"noopener\">AndResGuard</a> 实现方式，在AndResGuard基础上实现了只输入apk即可真正删除冗余or无用资源。</p>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>这里分别就冗余和无用资源的删除做下简要实现流程：</p>\n<ul>\n<li><strong><em>冗余资源</em></strong></li>\n</ul>\n<ol>\n<li>扫描apk（zip格式）各文件的CRC</li>\n<li>筛选CRC相同对应的文件路径，即这些文件都是相同的，只需要保留扫描出来的第一个文件路径</li>\n<li>重新生成resource.arsc，修改StringBlock，具体即把重复的资源路径全部替换成扫描出来第一份文件的路径</li>\n<li>之后的几个chunk原原本本copy一次，重写整份resource.arsc的size</li>\n<li>删除重复资源</li>\n</ol>\n<ul>\n<li><strong><em>无用资源</em></strong></li>\n</ul>\n<ol>\n<li>AS gradle设置 shrinkResources true<strong><em>（必须）</em></strong></li>\n<li>扫描apk（zip格式）各文件的CRC</li>\n<li>shrinkResources 扫描出来的无用代码文件，都会替换成预定义资源，其CRC定义是：</li>\n</ol>\n<p><img src=\"https://github.com/hellokugo/markdownPic/blob/master/dupilcate.png\" alt=\"\"></p>\n<p>4.删除上述三种CRC文件</p>\n<h2 id=\"核心代码\"><a href=\"#核心代码\" class=\"headerlink\" title=\"核心代码\"></a>核心代码</h2><p>Talk is cheap，show me the code. 说明一点，笔者是在AndResGuard基础上开发，一是没必要重复造轮子，二是resource.arsc字节码文件处理要特别小心，特别是修改StringBlock要注意四个字节对齐问题，AndResGuard本身是支持这一点，所以就站在巨人肩膀上开发。</p>\n<p>获取CRC：</p>\n<pre><code>Utils.java\nmethod:getZipCrc(add)\n\npublic static Map&lt;String, String&gt; getZipCrc(String apkPath) {\n    Map&lt;Long, String&gt; resMap = new HashMap&lt;&gt;();\n    Map&lt;String, String&gt; duplicateMap = new HashMap&lt;&gt;();\n    try {\n        ZipFile zipFile = new ZipFile(apkPath);\n        Enumeration e = zipFile.entries();\n\n        while (e.hasMoreElements()) {\n            ZipEntry entry = (ZipEntry) e.nextElement();\n            String entryName = entry.getName();\n            long crc = entry.getCrc();\n            if (entryName.startsWith(&quot;res/&quot;)) {\n                //record useless files\n                if (&quot;2293408688&quot;.equals(Long.toString(crc)) ||\n                    &quot;289995143&quot;.equals(Long.toString(crc)) ||\n                    &quot;3622196803&quot;.equals(Long.toString(crc))) {\n                    duplicateMap.put(entryName, &quot;&quot;);\n                    continue;\n                }\n                //record duplicate files\n                if (resMap.containsKey(crc)) {\n                    duplicateMap.put(entryName, resMap.get(crc));\n                } else {\n                    resMap.put(crc, entryName);\n                }\n            }\n        }\n        zipFile.close();\n        return duplicateMap;\n\n    } catch (IOException ioe) {\n        System.out.printf(&quot;Error opening zip file&quot; + ioe);\n        return null;\n    }\n}\n</code></pre><p>修改StringBlock：</p>\n<pre><code>StringBlock.java\nmethod:writeTableNameStringBlock\n\nfor (i = 0; i &lt; stringCount; i++) {\n        stringOffsets[i] = offset;\n        String originStr = getString(i);\n        //如果没有duplicatedFile,直接拷贝\n        if (duplicatedFile == null || !duplicatedFile.containsKey(originStr)) {\n            //需要区分是否是最后一项\n            int copyLen = (i == (stringCount - 1)) ? (block.m_strings.length - block.m_stringOffsets[i]) : (block.m_stringOffsets[i + 1] - block.m_stringOffsets[i]);\n            System.arraycopy(block.m_strings, block.m_stringOffsets[i], strings, offset, copyLen);\n            offset += copyLen;\n            totalSize += copyLen;\n        } else {\n            String name = duplicatedFile.get(originStr);\n            //是无用资源，无需修改StringBlock\n            if(&quot;&quot;.equals(name)) {\n                continue;\n            }\n            if (block.m_isUTF8) {\n                strings[offset++] = (byte) name.length();\n                strings[offset++] = (byte) name.length();\n                ......\n</code></pre><p>删除冗余or无用资源：</p>\n<pre><code>ResourceApkBuilder.java\nmethod:generalUnsignApk\n\n    for (File f : unzipFiles) {\n        String name = f.getName();\n        if (name.equals(&quot;resources.arsc&quot;)) {\n            continue;\n        } else if (name.equals(&quot;res&quot;)) {\n            //删除重复文件\n            if (duplicateMap != null &amp;&amp; duplicateMap.size() &gt; 0) {\n                for (String duplicatePath : duplicateMap.keySet()) {               \n                    File duplicateFile = new File(tempOutDir, duplicatePath);          \n                    if (duplicateFile.exists()) {\n                        duplicateFile.delete();          \n                    }\n                }\n            }\n            continue;\n        } else if (name.equals(config.mMetaName)) {\n            addNonSignatureFiles(collectFiles, f);\n            continue;\n        }\n        collectFiles.add(f);\n    }\n</code></pre><h1 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h1><p>目前该jar应用在项目jenkins持续集成中，无需手动扫描并删除资源，而且解决之前因各种原因无法在编译前删除对应资源的问题。不过目前该jar仍需完善，像无用资源并没有在resource.arsc删除对应的item，没处理在打包过后插进META-INF的无用文件等等，这个可以根据项目的实际需要再做完善。</p>\n"},{"title":"Android多渠道包处理","date":"2018-01-28T15:39:34.390Z","_content":"\n# 使用说明\n众所周知，Android会在不同的应用市场或者渠道去发布自己的产品，然后根据不同渠道的反馈去做相应产品的后续版本。目前用得比较多的是像集成友盟在AndroidManifest的meta-data加入渠道信息然后在代码读取，我们前期业务的做法是打包过程中在assets目录下加入标识文件记录渠道信息，由于这样的做法是在apk签名前插入，换言之每处理一个渠道就要做一次签名打包的操作，如果处理多个渠道消耗的时间就需要非常长，这样的大前提下就要思考是否有更好的打渠道方式。<!-- more -->\n\n# 处理方案\n\n我们知道，apk其实就是一个zip格式的文件。在 [zip格式介绍](https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT)中我们发现，zip留给我们一个可扩展的comment字段，这个字段的添加修改并不会影响签名后的apk包。换言之，以往我们在打多渠道的时候是每打一个渠道就要签名一个apk，现在用这种方式可以是实现签名一个apk来打多个渠道包，而且这些apk包并不影响原本的签名，这样所消耗的时间肯定会大大减少。后续发现github上有人提供这个打包方式，大概的思路和[packer-ng-plugin](https://github.com/mcxiaoke/packer-ng-plugin) 是一致的，区别在于考虑到业务打渠道的时机基本是在第三方提审过后签名apk才打入，这时候尽可能让打渠道的工作交由相应的运营，所以做出一个可操作简单友好的“傻瓜式”GUI，方便任何人都可以参与这项工作。\n\n# 思路\n\n这里要说明下，打渠道是用python语言，并且通过编写pyqt来实现界面化；读取渠道信息是在java语言层面，具体是直接读zip的字节码来获取。还有一点是，测试过程中发现通过zip comment打渠道方式在有的时候没有通过对apk重签名（apk重新签名会把这个字段抹去）也会出现读取不到渠道信息的情况，这样为了尽可能避免这种情况出现，我们参考了 [美团Android自动化之旅—生成渠道包](http://tech.meituan.com/mt-apk-packaging.html)，在签名后的apk插入空的META-INF/channel_file.txt做了规避处理，防止zip被破坏了导致渠道信息丢失而读取不到的问题。当然了，美团这种处理方案在apk重签名后也是会导致渠道信息丢失的问题。\n\n# 实现\n\n## 最终界面\n\n![](http://i.imgur.com/CI6KNco.png)\n\n![](http://i.imgur.com/wyepQoT.png)\n\n整体而言，操作的界面还是比较简单的，主要是两个tab：第一个是查看渠道信息，这里面首先读取comment字段，没有渠道信息则读取META-INF目录下的标识渠道的空文件，如果也没有则友好提示；第二个是打渠道的tab，可以看到有一个Extra可选填入操作，这个字段是供业务扩展字段，可以为空，实现的规则也是comment和空文件标识同时写入，当然，channel是可填入多个渠道标识实现打包。\n\n## 写入渠道信息\n\n安装pyqt和使用这里就不做介绍了，主要是说说实现的核心代码：\n\n \twith zipfile.ZipFile(tempApk,'a',zipfile.ZIP_DEFLATED) as myzip:\n            log_utils.getLogger().debug('do insert empty_channel_file.....')\n            # 遍历META-INF目录下文件，如果本来就存有渠道空文件，返回提示不能生成渠道包\n            fileList = myzip.namelist()\n            for f in fileList:\n                if f.startswith('META-INF/channelId'):\n                    log_utils.getLogger().info('channel file has exists: ' + f)\n                    return ('Failed ! channel file has exists: ' + f)\n            # 添加以渠道id命令的空文件到META-INF/文件下\n            channel_file = \"META-INF/channelId_{channel}\".format(channel=symbol)\n            if not os.path.exists(\"empty_file.txt\"):\n                log_utils.getLogger().debug('empty_file.txt is not exists..')\n                return ('Failed ! empty_file.txt is not exists..')\n            myzip.write(\"empty_file.txt\", channel_file)\n\n            log_utils.getLogger().debug('do change EOCD comment.....')\n            myzip.comment = str(commentDict).encode('utf-8') # 修改comment字段\n            myzip.close()\n            targetName = os.path.join(out_dir,originName.split(\".\")[0] + '(' + symbol + ').apk')\n            shutil.move(tempApk,targetName)\n\n代码应该比较清晰，首先在apk的META-INF目录下添加空的渠道标识文件，然后再添加comment字段。\n\n## 查看渠道信息\n\n    with zipfile.ZipFile(signedApk,'r',zipfile.ZIP_DEFLATED) as myzip:\n        tag = 'comment'\n        info = str(myzip.comment,encoding = \"utf-8\")\n        if not info: # 不存在comment字段，读meta-inf文件下空渠道信息\n            fileList = myzip.namelist()\n            for f in fileList:\n                if f.startswith('META-INF/channelId'):\n                    info = f.split('_',1)[1]\n                    tag = 'empty_file'\n\n        return info,tag\n\n上述代码实现是先读取comment，没有则读取空文件标识，返回不同结果。\n\n\n## java读取渠道信息\n\n上述GUI是本地可供快速查询和打渠道的工具，在我们的业务代码里肯定也需要读取具体的渠道信息用于上报，上述思路中也说了，我们是直接读取zip的字节码来获取comment信息的，核心代码参考：\n\n\tprivate static void readComment(File file) {\n\t\tRandomAccessFile zipFile = null;\n\t\ttry {\n\t\t\tzipFile = new RandomAccessFile(file, \"r\");\n\n\t\t\tlong fileSize = zipFile.length();\n\t\t\t/* find the magic number in a reverse manner */\n\t\t\tfor (long i = 1; fileSize - i >= 0; ++i) {\n\t\t\t\tzipFile.seek(fileSize - i);\n\t\t\t\tbyte b = zipFile.readByte();\n\t\t\t\tif (b == 0x06) {\n\t\t\t\t\tzipFile.seek(fileSize - i - 3);\n\t\t\t\t\t/* check for magic \"0x06054b50\" in little endian */\n\t\t\t\t\tbyte[] key = new byte[4];\n\t\t\t\t\tzipFile.readFully(key);\n\t\t\t\t\tif (key[0] != 0x50 || key[1] != 0x4b || key[2] != 0x05) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t/* get the file comment size */\n\t\t\t\t\tbyte[] tmp = new byte[18];\n\t\t\t\t\tzipFile.readFully(tmp);\n\t\t\t\t\tint commentSize = (tmp[16] & 0xff)\n\t\t\t\t\t\t\t| ((tmp[17] & 0xff) << 8);\n\t\t\t\t\tSystem.out.println(\"\" + commentSize);\n\t\t\t\t\tif (commentSize > 0) {\n\t\t\t\t\t\tbyte[] comment = new byte[commentSize];\n\t\t\t\t\t\tzipFile.readFully(comment);\n\t\t\t\t\t\tString commentStr = new String(comment, \"UTF-8\");\n\t\t\t\t\t\tJSONObject json = new JSONObject(commentStr);\n\t\t\t\t\t\tSYMBOL = json.getString(\"channelId\");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}catch(IOException e){//读写EOCD出错，默认设置没有EOCD字段\n\t\t\te.printStackTrace();\n\t\t\t//这里应该加入读取META-INF下空文件渠道标识的逻辑\n\t\t\tif（读取到空文件标识）{\n\t\t\t\tSYMBOL = \"空文件标识\"\n\t\t\t}else{\n\t\t\t\tSYMBOL = \"\";\n\t\t\t}\n\t\t}catch (JSONException e) {//有EOCD字段，但是没有channelId\n\t\t\te.printStackTrace();\n\t\t\tSYMBOL = \"\";\n\t\t}  finally {\n\t\t\tif (zipFile != null) {\n\t\t\t\ttry {\n\t\t\t\t\tzipFile.close();\n\t\t\t\t} catch (IOException ex) {\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n注意，这里在没有读到EOCD（即zip的comment字段）时，应该是会读取META-INF目录下时候存在空的标识渠道文件，这里没有做演示，读者可以自行补充。\n\n[github上的源码和本地工具](https://github.com/hellokugo/packageMultiChannel)\n\n","source":"_posts/Android多渠道包处理.md","raw":"title: Android多渠道包处理\ndate: 2016/11/6 2：21\n\ncategories:\n- Android\ntags:\n- Android，，多渠道，pyqt\n---\n\n# 使用说明\n众所周知，Android会在不同的应用市场或者渠道去发布自己的产品，然后根据不同渠道的反馈去做相应产品的后续版本。目前用得比较多的是像集成友盟在AndroidManifest的meta-data加入渠道信息然后在代码读取，我们前期业务的做法是打包过程中在assets目录下加入标识文件记录渠道信息，由于这样的做法是在apk签名前插入，换言之每处理一个渠道就要做一次签名打包的操作，如果处理多个渠道消耗的时间就需要非常长，这样的大前提下就要思考是否有更好的打渠道方式。<!-- more -->\n\n# 处理方案\n\n我们知道，apk其实就是一个zip格式的文件。在 [zip格式介绍](https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT)中我们发现，zip留给我们一个可扩展的comment字段，这个字段的添加修改并不会影响签名后的apk包。换言之，以往我们在打多渠道的时候是每打一个渠道就要签名一个apk，现在用这种方式可以是实现签名一个apk来打多个渠道包，而且这些apk包并不影响原本的签名，这样所消耗的时间肯定会大大减少。后续发现github上有人提供这个打包方式，大概的思路和[packer-ng-plugin](https://github.com/mcxiaoke/packer-ng-plugin) 是一致的，区别在于考虑到业务打渠道的时机基本是在第三方提审过后签名apk才打入，这时候尽可能让打渠道的工作交由相应的运营，所以做出一个可操作简单友好的“傻瓜式”GUI，方便任何人都可以参与这项工作。\n\n# 思路\n\n这里要说明下，打渠道是用python语言，并且通过编写pyqt来实现界面化；读取渠道信息是在java语言层面，具体是直接读zip的字节码来获取。还有一点是，测试过程中发现通过zip comment打渠道方式在有的时候没有通过对apk重签名（apk重新签名会把这个字段抹去）也会出现读取不到渠道信息的情况，这样为了尽可能避免这种情况出现，我们参考了 [美团Android自动化之旅—生成渠道包](http://tech.meituan.com/mt-apk-packaging.html)，在签名后的apk插入空的META-INF/channel_file.txt做了规避处理，防止zip被破坏了导致渠道信息丢失而读取不到的问题。当然了，美团这种处理方案在apk重签名后也是会导致渠道信息丢失的问题。\n\n# 实现\n\n## 最终界面\n\n![](http://i.imgur.com/CI6KNco.png)\n\n![](http://i.imgur.com/wyepQoT.png)\n\n整体而言，操作的界面还是比较简单的，主要是两个tab：第一个是查看渠道信息，这里面首先读取comment字段，没有渠道信息则读取META-INF目录下的标识渠道的空文件，如果也没有则友好提示；第二个是打渠道的tab，可以看到有一个Extra可选填入操作，这个字段是供业务扩展字段，可以为空，实现的规则也是comment和空文件标识同时写入，当然，channel是可填入多个渠道标识实现打包。\n\n## 写入渠道信息\n\n安装pyqt和使用这里就不做介绍了，主要是说说实现的核心代码：\n\n \twith zipfile.ZipFile(tempApk,'a',zipfile.ZIP_DEFLATED) as myzip:\n            log_utils.getLogger().debug('do insert empty_channel_file.....')\n            # 遍历META-INF目录下文件，如果本来就存有渠道空文件，返回提示不能生成渠道包\n            fileList = myzip.namelist()\n            for f in fileList:\n                if f.startswith('META-INF/channelId'):\n                    log_utils.getLogger().info('channel file has exists: ' + f)\n                    return ('Failed ! channel file has exists: ' + f)\n            # 添加以渠道id命令的空文件到META-INF/文件下\n            channel_file = \"META-INF/channelId_{channel}\".format(channel=symbol)\n            if not os.path.exists(\"empty_file.txt\"):\n                log_utils.getLogger().debug('empty_file.txt is not exists..')\n                return ('Failed ! empty_file.txt is not exists..')\n            myzip.write(\"empty_file.txt\", channel_file)\n\n            log_utils.getLogger().debug('do change EOCD comment.....')\n            myzip.comment = str(commentDict).encode('utf-8') # 修改comment字段\n            myzip.close()\n            targetName = os.path.join(out_dir,originName.split(\".\")[0] + '(' + symbol + ').apk')\n            shutil.move(tempApk,targetName)\n\n代码应该比较清晰，首先在apk的META-INF目录下添加空的渠道标识文件，然后再添加comment字段。\n\n## 查看渠道信息\n\n    with zipfile.ZipFile(signedApk,'r',zipfile.ZIP_DEFLATED) as myzip:\n        tag = 'comment'\n        info = str(myzip.comment,encoding = \"utf-8\")\n        if not info: # 不存在comment字段，读meta-inf文件下空渠道信息\n            fileList = myzip.namelist()\n            for f in fileList:\n                if f.startswith('META-INF/channelId'):\n                    info = f.split('_',1)[1]\n                    tag = 'empty_file'\n\n        return info,tag\n\n上述代码实现是先读取comment，没有则读取空文件标识，返回不同结果。\n\n\n## java读取渠道信息\n\n上述GUI是本地可供快速查询和打渠道的工具，在我们的业务代码里肯定也需要读取具体的渠道信息用于上报，上述思路中也说了，我们是直接读取zip的字节码来获取comment信息的，核心代码参考：\n\n\tprivate static void readComment(File file) {\n\t\tRandomAccessFile zipFile = null;\n\t\ttry {\n\t\t\tzipFile = new RandomAccessFile(file, \"r\");\n\n\t\t\tlong fileSize = zipFile.length();\n\t\t\t/* find the magic number in a reverse manner */\n\t\t\tfor (long i = 1; fileSize - i >= 0; ++i) {\n\t\t\t\tzipFile.seek(fileSize - i);\n\t\t\t\tbyte b = zipFile.readByte();\n\t\t\t\tif (b == 0x06) {\n\t\t\t\t\tzipFile.seek(fileSize - i - 3);\n\t\t\t\t\t/* check for magic \"0x06054b50\" in little endian */\n\t\t\t\t\tbyte[] key = new byte[4];\n\t\t\t\t\tzipFile.readFully(key);\n\t\t\t\t\tif (key[0] != 0x50 || key[1] != 0x4b || key[2] != 0x05) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t/* get the file comment size */\n\t\t\t\t\tbyte[] tmp = new byte[18];\n\t\t\t\t\tzipFile.readFully(tmp);\n\t\t\t\t\tint commentSize = (tmp[16] & 0xff)\n\t\t\t\t\t\t\t| ((tmp[17] & 0xff) << 8);\n\t\t\t\t\tSystem.out.println(\"\" + commentSize);\n\t\t\t\t\tif (commentSize > 0) {\n\t\t\t\t\t\tbyte[] comment = new byte[commentSize];\n\t\t\t\t\t\tzipFile.readFully(comment);\n\t\t\t\t\t\tString commentStr = new String(comment, \"UTF-8\");\n\t\t\t\t\t\tJSONObject json = new JSONObject(commentStr);\n\t\t\t\t\t\tSYMBOL = json.getString(\"channelId\");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}catch(IOException e){//读写EOCD出错，默认设置没有EOCD字段\n\t\t\te.printStackTrace();\n\t\t\t//这里应该加入读取META-INF下空文件渠道标识的逻辑\n\t\t\tif（读取到空文件标识）{\n\t\t\t\tSYMBOL = \"空文件标识\"\n\t\t\t}else{\n\t\t\t\tSYMBOL = \"\";\n\t\t\t}\n\t\t}catch (JSONException e) {//有EOCD字段，但是没有channelId\n\t\t\te.printStackTrace();\n\t\t\tSYMBOL = \"\";\n\t\t}  finally {\n\t\t\tif (zipFile != null) {\n\t\t\t\ttry {\n\t\t\t\t\tzipFile.close();\n\t\t\t\t} catch (IOException ex) {\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n注意，这里在没有读到EOCD（即zip的comment字段）时，应该是会读取META-INF目录下时候存在空的标识渠道文件，这里没有做演示，读者可以自行补充。\n\n[github上的源码和本地工具](https://github.com/hellokugo/packageMultiChannel)\n\n","slug":"Android多渠道包处理","published":1,"updated":"2018-01-28T15:39:34.390Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjcyyg7jp0006niusrm77mq0h","content":"<h1 id=\"使用说明\"><a href=\"#使用说明\" class=\"headerlink\" title=\"使用说明\"></a>使用说明</h1><p>众所周知，Android会在不同的应用市场或者渠道去发布自己的产品，然后根据不同渠道的反馈去做相应产品的后续版本。目前用得比较多的是像集成友盟在AndroidManifest的meta-data加入渠道信息然后在代码读取，我们前期业务的做法是打包过程中在assets目录下加入标识文件记录渠道信息，由于这样的做法是在apk签名前插入，换言之每处理一个渠道就要做一次签名打包的操作，如果处理多个渠道消耗的时间就需要非常长，这样的大前提下就要思考是否有更好的打渠道方式。<a id=\"more\"></a></p>\n<h1 id=\"处理方案\"><a href=\"#处理方案\" class=\"headerlink\" title=\"处理方案\"></a>处理方案</h1><p>我们知道，apk其实就是一个zip格式的文件。在 <a href=\"https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT\" target=\"_blank\" rel=\"noopener\">zip格式介绍</a>中我们发现，zip留给我们一个可扩展的comment字段，这个字段的添加修改并不会影响签名后的apk包。换言之，以往我们在打多渠道的时候是每打一个渠道就要签名一个apk，现在用这种方式可以是实现签名一个apk来打多个渠道包，而且这些apk包并不影响原本的签名，这样所消耗的时间肯定会大大减少。后续发现github上有人提供这个打包方式，大概的思路和<a href=\"https://github.com/mcxiaoke/packer-ng-plugin\" target=\"_blank\" rel=\"noopener\">packer-ng-plugin</a> 是一致的，区别在于考虑到业务打渠道的时机基本是在第三方提审过后签名apk才打入，这时候尽可能让打渠道的工作交由相应的运营，所以做出一个可操作简单友好的“傻瓜式”GUI，方便任何人都可以参与这项工作。</p>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>这里要说明下，打渠道是用python语言，并且通过编写pyqt来实现界面化；读取渠道信息是在java语言层面，具体是直接读zip的字节码来获取。还有一点是，测试过程中发现通过zip comment打渠道方式在有的时候没有通过对apk重签名（apk重新签名会把这个字段抹去）也会出现读取不到渠道信息的情况，这样为了尽可能避免这种情况出现，我们参考了 <a href=\"http://tech.meituan.com/mt-apk-packaging.html\" target=\"_blank\" rel=\"noopener\">美团Android自动化之旅—生成渠道包</a>，在签名后的apk插入空的META-INF/channel_file.txt做了规避处理，防止zip被破坏了导致渠道信息丢失而读取不到的问题。当然了，美团这种处理方案在apk重签名后也是会导致渠道信息丢失的问题。</p>\n<h1 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h1><h2 id=\"最终界面\"><a href=\"#最终界面\" class=\"headerlink\" title=\"最终界面\"></a>最终界面</h2><p><img src=\"http://i.imgur.com/CI6KNco.png\" alt=\"\"></p>\n<p><img src=\"http://i.imgur.com/wyepQoT.png\" alt=\"\"></p>\n<p>整体而言，操作的界面还是比较简单的，主要是两个tab：第一个是查看渠道信息，这里面首先读取comment字段，没有渠道信息则读取META-INF目录下的标识渠道的空文件，如果也没有则友好提示；第二个是打渠道的tab，可以看到有一个Extra可选填入操作，这个字段是供业务扩展字段，可以为空，实现的规则也是comment和空文件标识同时写入，当然，channel是可填入多个渠道标识实现打包。</p>\n<h2 id=\"写入渠道信息\"><a href=\"#写入渠道信息\" class=\"headerlink\" title=\"写入渠道信息\"></a>写入渠道信息</h2><p>安装pyqt和使用这里就不做介绍了，主要是说说实现的核心代码：</p>\n<pre><code>with zipfile.ZipFile(tempApk,&apos;a&apos;,zipfile.ZIP_DEFLATED) as myzip:\n       log_utils.getLogger().debug(&apos;do insert empty_channel_file.....&apos;)\n       # 遍历META-INF目录下文件，如果本来就存有渠道空文件，返回提示不能生成渠道包\n       fileList = myzip.namelist()\n       for f in fileList:\n           if f.startswith(&apos;META-INF/channelId&apos;):\n               log_utils.getLogger().info(&apos;channel file has exists: &apos; + f)\n               return (&apos;Failed ! channel file has exists: &apos; + f)\n       # 添加以渠道id命令的空文件到META-INF/文件下\n       channel_file = &quot;META-INF/channelId_{channel}&quot;.format(channel=symbol)\n       if not os.path.exists(&quot;empty_file.txt&quot;):\n           log_utils.getLogger().debug(&apos;empty_file.txt is not exists..&apos;)\n           return (&apos;Failed ! empty_file.txt is not exists..&apos;)\n       myzip.write(&quot;empty_file.txt&quot;, channel_file)\n\n       log_utils.getLogger().debug(&apos;do change EOCD comment.....&apos;)\n       myzip.comment = str(commentDict).encode(&apos;utf-8&apos;) # 修改comment字段\n       myzip.close()\n       targetName = os.path.join(out_dir,originName.split(&quot;.&quot;)[0] + &apos;(&apos; + symbol + &apos;).apk&apos;)\n       shutil.move(tempApk,targetName)\n</code></pre><p>代码应该比较清晰，首先在apk的META-INF目录下添加空的渠道标识文件，然后再添加comment字段。</p>\n<h2 id=\"查看渠道信息\"><a href=\"#查看渠道信息\" class=\"headerlink\" title=\"查看渠道信息\"></a>查看渠道信息</h2><pre><code>with zipfile.ZipFile(signedApk,&apos;r&apos;,zipfile.ZIP_DEFLATED) as myzip:\n    tag = &apos;comment&apos;\n    info = str(myzip.comment,encoding = &quot;utf-8&quot;)\n    if not info: # 不存在comment字段，读meta-inf文件下空渠道信息\n        fileList = myzip.namelist()\n        for f in fileList:\n            if f.startswith(&apos;META-INF/channelId&apos;):\n                info = f.split(&apos;_&apos;,1)[1]\n                tag = &apos;empty_file&apos;\n\n    return info,tag\n</code></pre><p>上述代码实现是先读取comment，没有则读取空文件标识，返回不同结果。</p>\n<h2 id=\"java读取渠道信息\"><a href=\"#java读取渠道信息\" class=\"headerlink\" title=\"java读取渠道信息\"></a>java读取渠道信息</h2><p>上述GUI是本地可供快速查询和打渠道的工具，在我们的业务代码里肯定也需要读取具体的渠道信息用于上报，上述思路中也说了，我们是直接读取zip的字节码来获取comment信息的，核心代码参考：</p>\n<pre><code>private static void readComment(File file) {\n    RandomAccessFile zipFile = null;\n    try {\n        zipFile = new RandomAccessFile(file, &quot;r&quot;);\n\n        long fileSize = zipFile.length();\n        /* find the magic number in a reverse manner */\n        for (long i = 1; fileSize - i &gt;= 0; ++i) {\n            zipFile.seek(fileSize - i);\n            byte b = zipFile.readByte();\n            if (b == 0x06) {\n                zipFile.seek(fileSize - i - 3);\n                /* check for magic &quot;0x06054b50&quot; in little endian */\n                byte[] key = new byte[4];\n                zipFile.readFully(key);\n                if (key[0] != 0x50 || key[1] != 0x4b || key[2] != 0x05) {\n                    continue;\n                }\n                /* get the file comment size */\n                byte[] tmp = new byte[18];\n                zipFile.readFully(tmp);\n                int commentSize = (tmp[16] &amp; 0xff)\n                        | ((tmp[17] &amp; 0xff) &lt;&lt; 8);\n                System.out.println(&quot;&quot; + commentSize);\n                if (commentSize &gt; 0) {\n                    byte[] comment = new byte[commentSize];\n                    zipFile.readFully(comment);\n                    String commentStr = new String(comment, &quot;UTF-8&quot;);\n                    JSONObject json = new JSONObject(commentStr);\n                    SYMBOL = json.getString(&quot;channelId&quot;);\n                }\n                break;\n            }\n        }\n    }catch(IOException e){//读写EOCD出错，默认设置没有EOCD字段\n        e.printStackTrace();\n        //这里应该加入读取META-INF下空文件渠道标识的逻辑\n        if（读取到空文件标识）{\n            SYMBOL = &quot;空文件标识&quot;\n        }else{\n            SYMBOL = &quot;&quot;;\n        }\n    }catch (JSONException e) {//有EOCD字段，但是没有channelId\n        e.printStackTrace();\n        SYMBOL = &quot;&quot;;\n    }  finally {\n        if (zipFile != null) {\n            try {\n                zipFile.close();\n            } catch (IOException ex) {\n            }\n        }\n    }\n}\n</code></pre><p>注意，这里在没有读到EOCD（即zip的comment字段）时，应该是会读取META-INF目录下时候存在空的标识渠道文件，这里没有做演示，读者可以自行补充。</p>\n<p><a href=\"https://github.com/hellokugo/packageMultiChannel\" target=\"_blank\" rel=\"noopener\">github上的源码和本地工具</a></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"使用说明\"><a href=\"#使用说明\" class=\"headerlink\" title=\"使用说明\"></a>使用说明</h1><p>众所周知，Android会在不同的应用市场或者渠道去发布自己的产品，然后根据不同渠道的反馈去做相应产品的后续版本。目前用得比较多的是像集成友盟在AndroidManifest的meta-data加入渠道信息然后在代码读取，我们前期业务的做法是打包过程中在assets目录下加入标识文件记录渠道信息，由于这样的做法是在apk签名前插入，换言之每处理一个渠道就要做一次签名打包的操作，如果处理多个渠道消耗的时间就需要非常长，这样的大前提下就要思考是否有更好的打渠道方式。","more":"</p>\n<h1 id=\"处理方案\"><a href=\"#处理方案\" class=\"headerlink\" title=\"处理方案\"></a>处理方案</h1><p>我们知道，apk其实就是一个zip格式的文件。在 <a href=\"https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT\" target=\"_blank\" rel=\"noopener\">zip格式介绍</a>中我们发现，zip留给我们一个可扩展的comment字段，这个字段的添加修改并不会影响签名后的apk包。换言之，以往我们在打多渠道的时候是每打一个渠道就要签名一个apk，现在用这种方式可以是实现签名一个apk来打多个渠道包，而且这些apk包并不影响原本的签名，这样所消耗的时间肯定会大大减少。后续发现github上有人提供这个打包方式，大概的思路和<a href=\"https://github.com/mcxiaoke/packer-ng-plugin\" target=\"_blank\" rel=\"noopener\">packer-ng-plugin</a> 是一致的，区别在于考虑到业务打渠道的时机基本是在第三方提审过后签名apk才打入，这时候尽可能让打渠道的工作交由相应的运营，所以做出一个可操作简单友好的“傻瓜式”GUI，方便任何人都可以参与这项工作。</p>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>这里要说明下，打渠道是用python语言，并且通过编写pyqt来实现界面化；读取渠道信息是在java语言层面，具体是直接读zip的字节码来获取。还有一点是，测试过程中发现通过zip comment打渠道方式在有的时候没有通过对apk重签名（apk重新签名会把这个字段抹去）也会出现读取不到渠道信息的情况，这样为了尽可能避免这种情况出现，我们参考了 <a href=\"http://tech.meituan.com/mt-apk-packaging.html\" target=\"_blank\" rel=\"noopener\">美团Android自动化之旅—生成渠道包</a>，在签名后的apk插入空的META-INF/channel_file.txt做了规避处理，防止zip被破坏了导致渠道信息丢失而读取不到的问题。当然了，美团这种处理方案在apk重签名后也是会导致渠道信息丢失的问题。</p>\n<h1 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h1><h2 id=\"最终界面\"><a href=\"#最终界面\" class=\"headerlink\" title=\"最终界面\"></a>最终界面</h2><p><img src=\"http://i.imgur.com/CI6KNco.png\" alt=\"\"></p>\n<p><img src=\"http://i.imgur.com/wyepQoT.png\" alt=\"\"></p>\n<p>整体而言，操作的界面还是比较简单的，主要是两个tab：第一个是查看渠道信息，这里面首先读取comment字段，没有渠道信息则读取META-INF目录下的标识渠道的空文件，如果也没有则友好提示；第二个是打渠道的tab，可以看到有一个Extra可选填入操作，这个字段是供业务扩展字段，可以为空，实现的规则也是comment和空文件标识同时写入，当然，channel是可填入多个渠道标识实现打包。</p>\n<h2 id=\"写入渠道信息\"><a href=\"#写入渠道信息\" class=\"headerlink\" title=\"写入渠道信息\"></a>写入渠道信息</h2><p>安装pyqt和使用这里就不做介绍了，主要是说说实现的核心代码：</p>\n<pre><code>with zipfile.ZipFile(tempApk,&apos;a&apos;,zipfile.ZIP_DEFLATED) as myzip:\n       log_utils.getLogger().debug(&apos;do insert empty_channel_file.....&apos;)\n       # 遍历META-INF目录下文件，如果本来就存有渠道空文件，返回提示不能生成渠道包\n       fileList = myzip.namelist()\n       for f in fileList:\n           if f.startswith(&apos;META-INF/channelId&apos;):\n               log_utils.getLogger().info(&apos;channel file has exists: &apos; + f)\n               return (&apos;Failed ! channel file has exists: &apos; + f)\n       # 添加以渠道id命令的空文件到META-INF/文件下\n       channel_file = &quot;META-INF/channelId_{channel}&quot;.format(channel=symbol)\n       if not os.path.exists(&quot;empty_file.txt&quot;):\n           log_utils.getLogger().debug(&apos;empty_file.txt is not exists..&apos;)\n           return (&apos;Failed ! empty_file.txt is not exists..&apos;)\n       myzip.write(&quot;empty_file.txt&quot;, channel_file)\n\n       log_utils.getLogger().debug(&apos;do change EOCD comment.....&apos;)\n       myzip.comment = str(commentDict).encode(&apos;utf-8&apos;) # 修改comment字段\n       myzip.close()\n       targetName = os.path.join(out_dir,originName.split(&quot;.&quot;)[0] + &apos;(&apos; + symbol + &apos;).apk&apos;)\n       shutil.move(tempApk,targetName)\n</code></pre><p>代码应该比较清晰，首先在apk的META-INF目录下添加空的渠道标识文件，然后再添加comment字段。</p>\n<h2 id=\"查看渠道信息\"><a href=\"#查看渠道信息\" class=\"headerlink\" title=\"查看渠道信息\"></a>查看渠道信息</h2><pre><code>with zipfile.ZipFile(signedApk,&apos;r&apos;,zipfile.ZIP_DEFLATED) as myzip:\n    tag = &apos;comment&apos;\n    info = str(myzip.comment,encoding = &quot;utf-8&quot;)\n    if not info: # 不存在comment字段，读meta-inf文件下空渠道信息\n        fileList = myzip.namelist()\n        for f in fileList:\n            if f.startswith(&apos;META-INF/channelId&apos;):\n                info = f.split(&apos;_&apos;,1)[1]\n                tag = &apos;empty_file&apos;\n\n    return info,tag\n</code></pre><p>上述代码实现是先读取comment，没有则读取空文件标识，返回不同结果。</p>\n<h2 id=\"java读取渠道信息\"><a href=\"#java读取渠道信息\" class=\"headerlink\" title=\"java读取渠道信息\"></a>java读取渠道信息</h2><p>上述GUI是本地可供快速查询和打渠道的工具，在我们的业务代码里肯定也需要读取具体的渠道信息用于上报，上述思路中也说了，我们是直接读取zip的字节码来获取comment信息的，核心代码参考：</p>\n<pre><code>private static void readComment(File file) {\n    RandomAccessFile zipFile = null;\n    try {\n        zipFile = new RandomAccessFile(file, &quot;r&quot;);\n\n        long fileSize = zipFile.length();\n        /* find the magic number in a reverse manner */\n        for (long i = 1; fileSize - i &gt;= 0; ++i) {\n            zipFile.seek(fileSize - i);\n            byte b = zipFile.readByte();\n            if (b == 0x06) {\n                zipFile.seek(fileSize - i - 3);\n                /* check for magic &quot;0x06054b50&quot; in little endian */\n                byte[] key = new byte[4];\n                zipFile.readFully(key);\n                if (key[0] != 0x50 || key[1] != 0x4b || key[2] != 0x05) {\n                    continue;\n                }\n                /* get the file comment size */\n                byte[] tmp = new byte[18];\n                zipFile.readFully(tmp);\n                int commentSize = (tmp[16] &amp; 0xff)\n                        | ((tmp[17] &amp; 0xff) &lt;&lt; 8);\n                System.out.println(&quot;&quot; + commentSize);\n                if (commentSize &gt; 0) {\n                    byte[] comment = new byte[commentSize];\n                    zipFile.readFully(comment);\n                    String commentStr = new String(comment, &quot;UTF-8&quot;);\n                    JSONObject json = new JSONObject(commentStr);\n                    SYMBOL = json.getString(&quot;channelId&quot;);\n                }\n                break;\n            }\n        }\n    }catch(IOException e){//读写EOCD出错，默认设置没有EOCD字段\n        e.printStackTrace();\n        //这里应该加入读取META-INF下空文件渠道标识的逻辑\n        if（读取到空文件标识）{\n            SYMBOL = &quot;空文件标识&quot;\n        }else{\n            SYMBOL = &quot;&quot;;\n        }\n    }catch (JSONException e) {//有EOCD字段，但是没有channelId\n        e.printStackTrace();\n        SYMBOL = &quot;&quot;;\n    }  finally {\n        if (zipFile != null) {\n            try {\n                zipFile.close();\n            } catch (IOException ex) {\n            }\n        }\n    }\n}\n</code></pre><p>注意，这里在没有读到EOCD（即zip的comment字段）时，应该是会读取META-INF目录下时候存在空的标识渠道文件，这里没有做演示，读者可以自行补充。</p>\n<p><a href=\"https://github.com/hellokugo/packageMultiChannel\" target=\"_blank\" rel=\"noopener\">github上的源码和本地工具</a></p>"},{"title":"MQTT源码解析之connect","date":"2018-01-28T15:39:34.390Z","_content":"\n# 说在前面\n\n前段时间项目组在搞 [IM](http://blog.csdn.net/DreamTww/article/details/4632174)，前期主要是对当前IM类似QQ、微信和环信等通信协议的采用分析，基本确定是在XMPP和MQTT二者选一。XMPP应用较为广泛稳定，但是如果应用在移动端实在是折腾不起，流量大，自然耗电量也会多。<!-- more -->相比之下，初衷使用在推送方面的MQTT协议简直是为移动端的痛点应运而生。 [参考](http://xiangwangfeng.com/2015/05/20/%E7%A7%BB%E5%8A%A8IM%E5%BC%80%E5%8F%91%E9%82%A3%E4%BA%9B%E4%BA%8B/)\n\n# 说些什么\n\n本文不是要详细展开对MQTT协议的解析，而是主要从github上的 [paho demo](https://github.com/sandro-k/org.eclipse.paho.android.service.sample) 来对MQTT内部实现connect进行流程的梳理，结合其 [官方文档](http://public.dhe.ibm.com/software/dw/webservices/ws-mqtt/mqtt-v3r1.html) 对协议格式的了解，相信读者能拨开云雾，了解其实现机制。另外，推荐下国人对MQTT理解写的 [系列文章](http://www.blogjava.net/yongboy/category/54835.html)。注意的是，要跑起demo需要搭建测试服务器作订阅发送，建议采用mosquitto作连接服务端供本地测试， [参考地址](https://code.google.com/archive/p/mosquitto-mqtt-client-android/)\n\n# Read Code\n\n## Prepare\n\n假如demo能成功在手机端跑起，并且开启mosquitto，开始介绍其connect流程，跟进代码到ClientConnections类中的connectAction方法：\n\n![](http://i.imgur.com/mXz6h2H.png)\n\n获取到新建连接的cid、uri和port信息，注意，这里是用本地的mosquitto作测试连接，所以uri通过ipconfig获取到的ip地址填入，port默认是1883（当然，你可以作修改），cid可以随意。\n\n其中还有其他一些参数（诸如ssl、qos和keepalive等）由于本篇主要介绍的是conncet所以不展开细说。ok，接着往下看：\n\n![](http://i.imgur.com/WzEHxZO.png)\n\n![](http://i.imgur.com/RJIgpES.png)\n\n这里要对回调进行区分，以上截图第一个回调MqttCallbackHandler主要是接收服务端push过来的信息回调；而下图的callback继承于ActionListener，顾名思义，是发起本次“动作”的回调结果，连接是一个动作，订阅是一个动作，客户端push信息也是一个动作，每次动作的发起都会注册回调返回结果。区分好上述两个回调后，开始走进connect操作的核心。\n\n## MqttService\n\nconnect前还需要做一个操作，就是区分每一次连接，这里是用MqttTokenAndroid来保存当前连接的callback。我们知道，连接过程的时间并不是我们所能控制的，所以这里开启了一个service来进行后面的操作。这里需要说明一点的是，在startService后进入到MqttService的onStartCommand方法中，注册了一个广播：\n\n![](http://i.imgur.com/WlIsDzx.png)\n\n该广播主要是检测手机网络的变化而进行重连或断开连接的提示操作。ok，在开启startService和bindService后注册了另外一个广播：\n\n![](http://i.imgur.com/NNDEpwq.png)\n\n这个广播至关重要，因为它是接收服务端信息的桥梁，action是MqttServiceConstants.CALLBACK_TO_ACTIVITY，在后面会用到。\n\n## connect\n\n连接service成功后回调至onServiceConnected中做doConnect()方法，跟进代码，有这样一句：\n\n![](http://i.imgur.com/IKUDaul.png)\n\n这里巧妙地用一个以递增num作key、token作value的map来保存映射每次的连接操作。之后做mqttService.connect()。\n\n跟到MqttConnection的connect方法，设置一个回调的bundle，action指定为CONNECT_ACTION，并把传进来的token带上，这里多设置了一层代理的IMqttActionListener，把上述设置的bundle带上。然后就new出一个MqttAsyncClient，并绑定上述设置的IMqttActionListener作为回调，然后再做connect()。\n\n## tcp / ssl\n\n跟进MqttAsyncClient类中的connect()方法，在进行一系列的当前连接状态判断之后，有以下一句代码：\n\n![](http://i.imgur.com/OXZzldo.png)\n\n这里面是干嘛的呢？跟进去看下：\n\n![](http://i.imgur.com/03bxLCO.png)\n\n原来是设置不同连接的端口和uri地址，这里是根据connect前是否设置ssl安全访问模式去设定的，默认ssl为false，即tcp连接。\n\n## connect protocol infomation\n\n跟到这里，发现复杂的代码总是设置各种代码和多层回调，给人雾里看花的感觉，也许这就是设计模式的魅力。别急，接着往下看，跟到ClientComms类的connect()方法。看到这里：\n\n![](http://i.imgur.com/b4rdqKi.png)\n\n在MqttConnect的构造方法中第一句代码是 \n\n\tsuper(MqttWireMessage.MESSAGE_TYPE_CONNECT);\n终于看到设置connect协议的地方了，为什么这么说？了解mqtt头部信息的读者应该对以下的图并不陌生：\n\n![](http://i.imgur.com/ynGryag.png)\n\n要想进一步了解connect协议字段，可以参考文章开篇推荐的国人总结的系列文章中有提及到。 [送上链接](http://www.blogjava.net/yongboy/archive/2014/02/09/409630.html)\n\n## connect Thread\n\n看到设置connect协议了，应该离真正连接的代码不远了。继续往下看：\n\n![](http://i.imgur.com/3cevn7V.png)\n\n咦，这里开了一个线程，干嘛的呢？看下ConnectBG的run()方法：\n\n![](http://i.imgur.com/ucJCDSt.png)\n\n接下来，打算分三部分来介绍。\n\n### socket \n\nNetworkModule是一个接口，真正实现的是在上述tcp/ssl介绍部分的TCPNetworkModule/LocalNetworkModule。这里以TCPNetworkModule为例，上代码：\n\n![](http://i.imgur.com/ujIbCD6.png)\n\n哎呀，原来是用到socket连接，这下终于看到真面目了。这一步是打开了socket。\n\n### run Threads\n\n网络连接了，必然是开始数据的发送和接收处理。果不其然，接下来看到的是三个线程，分别是CommsReceiver、CommsSender和CommsCallback。\n下面直接看下这三个线程的run方法：\n\n***CommsReceiver***：\n\n![](http://i.imgur.com/lb0DTw3.png)\n\n该线程用 in.available() > 0 处理接收消息，如果没有接收到消息则一直处于阻塞状态；\n\n***CommsSender***：\n\n![](http://i.imgur.com/bG7FV1c.png)\n\n通过clientState.get()获取到发送消息，点进去get()方法看下：\n\n![](http://i.imgur.com/nc5mpmS.png)\n\n这里定义pendingMessages和pendingFlows两个容器来处理不同的发送消息类型，并释放queueLock锁，queueLock.wait()一直阻塞等待被唤起。\n\n***CommsCallback***：\n\n![](http://i.imgur.com/Agf4Pis.png)\n\n和CommsSender类似，通过释放workAvailable锁，workAvailable.wait()一直阻塞等待被唤起。\n\n### send connect request\n\n看到上面介绍的三个线程均是阻塞状，接下来肯定是需要唤醒某个线程做发送操作了。跟进internalSend()方法：\n\n![](http://i.imgur.com/UbJIeJv.png)\n\n看到这一步验证了我们的猜想，被唤起的是CommsSender这个线程：\n\n![](http://i.imgur.com/CzzhoTL.png)\n\n最终通过out.write()和out.flush()把connect消息发送出去。\n\n## receive connectAck\n\n把coneect消息发送出去只是成功一半，接收到服务端的connectAck才算是connect成功。So，服务端发送过来的消息在哪里接收呢？CommsReceiver在获取到消息则不在阻塞，第一步先解析获取到数据类型：\n\n![](http://i.imgur.com/rEuV1ov.png)\n\n如果阅读过推荐的解析MQTT协议文章的读者在这里应该理解不难，跟进createWireMessage()方法，由于收到的是connectAck，所以会走到这里：\n\n![](http://i.imgur.com/TVppG3e.png)\n\n建立并返回的是一个MqttAck对象。继续返回到CommsReceiver：\n\n![](http://i.imgur.com/FQSP8Nf.png)\n\n跟进clientState.notifyReceivedAck((MqttAck)message)，走到这里：\n\n![](http://i.imgur.com/iEmslY9.png)\n\n获取rc状态码，等于0则会成功，这里面connected()方法是一个关键，主要是做心跳连接，这个后面再细讲；跟进notifyResult() 方法：\n\n![](http://i.imgur.com/pbVUvhD.png)\n\n![](http://i.imgur.com/58Q2QiK.png)\n\n哎呀，跟到最后，原来是为了唤醒CommsCallback这个线程。Then，跟到CommsCallback：\n\n![](http://i.imgur.com/irBkubN.png)\n\n接着跟进去handleActionComplete()方法：\n\n![](http://i.imgur.com/BfpZpiu.png)\n\n![](http://i.imgur.com/5gCV2MN.png)\n\n至此，线程已经走完，剩下的就是之前设置下来的回调通知。这个相信读者可以自行往下阅读。\n\n# 说到最后\n\n整个connect流程走下来还是很清晰可见的，后续会继续分析心跳ping、订阅和publish等流程，其实过程都是大同小异，都是基于以上三个线程去进行。所以，熟悉connect流程对之后的分析帮助很大。","source":"_posts/MQTT源码解析之connect.md","raw":"title: MQTT源码解析之connect\ndate: 2016/12/20 20：40\n\ncategories:\n- Android\ntags:\n- Android，MQTT\n---\n\n# 说在前面\n\n前段时间项目组在搞 [IM](http://blog.csdn.net/DreamTww/article/details/4632174)，前期主要是对当前IM类似QQ、微信和环信等通信协议的采用分析，基本确定是在XMPP和MQTT二者选一。XMPP应用较为广泛稳定，但是如果应用在移动端实在是折腾不起，流量大，自然耗电量也会多。<!-- more -->相比之下，初衷使用在推送方面的MQTT协议简直是为移动端的痛点应运而生。 [参考](http://xiangwangfeng.com/2015/05/20/%E7%A7%BB%E5%8A%A8IM%E5%BC%80%E5%8F%91%E9%82%A3%E4%BA%9B%E4%BA%8B/)\n\n# 说些什么\n\n本文不是要详细展开对MQTT协议的解析，而是主要从github上的 [paho demo](https://github.com/sandro-k/org.eclipse.paho.android.service.sample) 来对MQTT内部实现connect进行流程的梳理，结合其 [官方文档](http://public.dhe.ibm.com/software/dw/webservices/ws-mqtt/mqtt-v3r1.html) 对协议格式的了解，相信读者能拨开云雾，了解其实现机制。另外，推荐下国人对MQTT理解写的 [系列文章](http://www.blogjava.net/yongboy/category/54835.html)。注意的是，要跑起demo需要搭建测试服务器作订阅发送，建议采用mosquitto作连接服务端供本地测试， [参考地址](https://code.google.com/archive/p/mosquitto-mqtt-client-android/)\n\n# Read Code\n\n## Prepare\n\n假如demo能成功在手机端跑起，并且开启mosquitto，开始介绍其connect流程，跟进代码到ClientConnections类中的connectAction方法：\n\n![](http://i.imgur.com/mXz6h2H.png)\n\n获取到新建连接的cid、uri和port信息，注意，这里是用本地的mosquitto作测试连接，所以uri通过ipconfig获取到的ip地址填入，port默认是1883（当然，你可以作修改），cid可以随意。\n\n其中还有其他一些参数（诸如ssl、qos和keepalive等）由于本篇主要介绍的是conncet所以不展开细说。ok，接着往下看：\n\n![](http://i.imgur.com/WzEHxZO.png)\n\n![](http://i.imgur.com/RJIgpES.png)\n\n这里要对回调进行区分，以上截图第一个回调MqttCallbackHandler主要是接收服务端push过来的信息回调；而下图的callback继承于ActionListener，顾名思义，是发起本次“动作”的回调结果，连接是一个动作，订阅是一个动作，客户端push信息也是一个动作，每次动作的发起都会注册回调返回结果。区分好上述两个回调后，开始走进connect操作的核心。\n\n## MqttService\n\nconnect前还需要做一个操作，就是区分每一次连接，这里是用MqttTokenAndroid来保存当前连接的callback。我们知道，连接过程的时间并不是我们所能控制的，所以这里开启了一个service来进行后面的操作。这里需要说明一点的是，在startService后进入到MqttService的onStartCommand方法中，注册了一个广播：\n\n![](http://i.imgur.com/WlIsDzx.png)\n\n该广播主要是检测手机网络的变化而进行重连或断开连接的提示操作。ok，在开启startService和bindService后注册了另外一个广播：\n\n![](http://i.imgur.com/NNDEpwq.png)\n\n这个广播至关重要，因为它是接收服务端信息的桥梁，action是MqttServiceConstants.CALLBACK_TO_ACTIVITY，在后面会用到。\n\n## connect\n\n连接service成功后回调至onServiceConnected中做doConnect()方法，跟进代码，有这样一句：\n\n![](http://i.imgur.com/IKUDaul.png)\n\n这里巧妙地用一个以递增num作key、token作value的map来保存映射每次的连接操作。之后做mqttService.connect()。\n\n跟到MqttConnection的connect方法，设置一个回调的bundle，action指定为CONNECT_ACTION，并把传进来的token带上，这里多设置了一层代理的IMqttActionListener，把上述设置的bundle带上。然后就new出一个MqttAsyncClient，并绑定上述设置的IMqttActionListener作为回调，然后再做connect()。\n\n## tcp / ssl\n\n跟进MqttAsyncClient类中的connect()方法，在进行一系列的当前连接状态判断之后，有以下一句代码：\n\n![](http://i.imgur.com/OXZzldo.png)\n\n这里面是干嘛的呢？跟进去看下：\n\n![](http://i.imgur.com/03bxLCO.png)\n\n原来是设置不同连接的端口和uri地址，这里是根据connect前是否设置ssl安全访问模式去设定的，默认ssl为false，即tcp连接。\n\n## connect protocol infomation\n\n跟到这里，发现复杂的代码总是设置各种代码和多层回调，给人雾里看花的感觉，也许这就是设计模式的魅力。别急，接着往下看，跟到ClientComms类的connect()方法。看到这里：\n\n![](http://i.imgur.com/b4rdqKi.png)\n\n在MqttConnect的构造方法中第一句代码是 \n\n\tsuper(MqttWireMessage.MESSAGE_TYPE_CONNECT);\n终于看到设置connect协议的地方了，为什么这么说？了解mqtt头部信息的读者应该对以下的图并不陌生：\n\n![](http://i.imgur.com/ynGryag.png)\n\n要想进一步了解connect协议字段，可以参考文章开篇推荐的国人总结的系列文章中有提及到。 [送上链接](http://www.blogjava.net/yongboy/archive/2014/02/09/409630.html)\n\n## connect Thread\n\n看到设置connect协议了，应该离真正连接的代码不远了。继续往下看：\n\n![](http://i.imgur.com/3cevn7V.png)\n\n咦，这里开了一个线程，干嘛的呢？看下ConnectBG的run()方法：\n\n![](http://i.imgur.com/ucJCDSt.png)\n\n接下来，打算分三部分来介绍。\n\n### socket \n\nNetworkModule是一个接口，真正实现的是在上述tcp/ssl介绍部分的TCPNetworkModule/LocalNetworkModule。这里以TCPNetworkModule为例，上代码：\n\n![](http://i.imgur.com/ujIbCD6.png)\n\n哎呀，原来是用到socket连接，这下终于看到真面目了。这一步是打开了socket。\n\n### run Threads\n\n网络连接了，必然是开始数据的发送和接收处理。果不其然，接下来看到的是三个线程，分别是CommsReceiver、CommsSender和CommsCallback。\n下面直接看下这三个线程的run方法：\n\n***CommsReceiver***：\n\n![](http://i.imgur.com/lb0DTw3.png)\n\n该线程用 in.available() > 0 处理接收消息，如果没有接收到消息则一直处于阻塞状态；\n\n***CommsSender***：\n\n![](http://i.imgur.com/bG7FV1c.png)\n\n通过clientState.get()获取到发送消息，点进去get()方法看下：\n\n![](http://i.imgur.com/nc5mpmS.png)\n\n这里定义pendingMessages和pendingFlows两个容器来处理不同的发送消息类型，并释放queueLock锁，queueLock.wait()一直阻塞等待被唤起。\n\n***CommsCallback***：\n\n![](http://i.imgur.com/Agf4Pis.png)\n\n和CommsSender类似，通过释放workAvailable锁，workAvailable.wait()一直阻塞等待被唤起。\n\n### send connect request\n\n看到上面介绍的三个线程均是阻塞状，接下来肯定是需要唤醒某个线程做发送操作了。跟进internalSend()方法：\n\n![](http://i.imgur.com/UbJIeJv.png)\n\n看到这一步验证了我们的猜想，被唤起的是CommsSender这个线程：\n\n![](http://i.imgur.com/CzzhoTL.png)\n\n最终通过out.write()和out.flush()把connect消息发送出去。\n\n## receive connectAck\n\n把coneect消息发送出去只是成功一半，接收到服务端的connectAck才算是connect成功。So，服务端发送过来的消息在哪里接收呢？CommsReceiver在获取到消息则不在阻塞，第一步先解析获取到数据类型：\n\n![](http://i.imgur.com/rEuV1ov.png)\n\n如果阅读过推荐的解析MQTT协议文章的读者在这里应该理解不难，跟进createWireMessage()方法，由于收到的是connectAck，所以会走到这里：\n\n![](http://i.imgur.com/TVppG3e.png)\n\n建立并返回的是一个MqttAck对象。继续返回到CommsReceiver：\n\n![](http://i.imgur.com/FQSP8Nf.png)\n\n跟进clientState.notifyReceivedAck((MqttAck)message)，走到这里：\n\n![](http://i.imgur.com/iEmslY9.png)\n\n获取rc状态码，等于0则会成功，这里面connected()方法是一个关键，主要是做心跳连接，这个后面再细讲；跟进notifyResult() 方法：\n\n![](http://i.imgur.com/pbVUvhD.png)\n\n![](http://i.imgur.com/58Q2QiK.png)\n\n哎呀，跟到最后，原来是为了唤醒CommsCallback这个线程。Then，跟到CommsCallback：\n\n![](http://i.imgur.com/irBkubN.png)\n\n接着跟进去handleActionComplete()方法：\n\n![](http://i.imgur.com/BfpZpiu.png)\n\n![](http://i.imgur.com/5gCV2MN.png)\n\n至此，线程已经走完，剩下的就是之前设置下来的回调通知。这个相信读者可以自行往下阅读。\n\n# 说到最后\n\n整个connect流程走下来还是很清晰可见的，后续会继续分析心跳ping、订阅和publish等流程，其实过程都是大同小异，都是基于以上三个线程去进行。所以，熟悉connect流程对之后的分析帮助很大。","slug":"MQTT源码解析之connect","published":1,"updated":"2018-01-28T15:39:34.390Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjcyyg7jr0007nius4i5tj02w","content":"<h1 id=\"说在前面\"><a href=\"#说在前面\" class=\"headerlink\" title=\"说在前面\"></a>说在前面</h1><p>前段时间项目组在搞 <a href=\"http://blog.csdn.net/DreamTww/article/details/4632174\" target=\"_blank\" rel=\"noopener\">IM</a>，前期主要是对当前IM类似QQ、微信和环信等通信协议的采用分析，基本确定是在XMPP和MQTT二者选一。XMPP应用较为广泛稳定，但是如果应用在移动端实在是折腾不起，流量大，自然耗电量也会多。<a id=\"more\"></a>相比之下，初衷使用在推送方面的MQTT协议简直是为移动端的痛点应运而生。 <a href=\"http://xiangwangfeng.com/2015/05/20/%E7%A7%BB%E5%8A%A8IM%E5%BC%80%E5%8F%91%E9%82%A3%E4%BA%9B%E4%BA%8B/\" target=\"_blank\" rel=\"noopener\">参考</a></p>\n<h1 id=\"说些什么\"><a href=\"#说些什么\" class=\"headerlink\" title=\"说些什么\"></a>说些什么</h1><p>本文不是要详细展开对MQTT协议的解析，而是主要从github上的 <a href=\"https://github.com/sandro-k/org.eclipse.paho.android.service.sample\" target=\"_blank\" rel=\"noopener\">paho demo</a> 来对MQTT内部实现connect进行流程的梳理，结合其 <a href=\"http://public.dhe.ibm.com/software/dw/webservices/ws-mqtt/mqtt-v3r1.html\" target=\"_blank\" rel=\"noopener\">官方文档</a> 对协议格式的了解，相信读者能拨开云雾，了解其实现机制。另外，推荐下国人对MQTT理解写的 <a href=\"http://www.blogjava.net/yongboy/category/54835.html\" target=\"_blank\" rel=\"noopener\">系列文章</a>。注意的是，要跑起demo需要搭建测试服务器作订阅发送，建议采用mosquitto作连接服务端供本地测试， <a href=\"https://code.google.com/archive/p/mosquitto-mqtt-client-android/\" target=\"_blank\" rel=\"noopener\">参考地址</a></p>\n<h1 id=\"Read-Code\"><a href=\"#Read-Code\" class=\"headerlink\" title=\"Read Code\"></a>Read Code</h1><h2 id=\"Prepare\"><a href=\"#Prepare\" class=\"headerlink\" title=\"Prepare\"></a>Prepare</h2><p>假如demo能成功在手机端跑起，并且开启mosquitto，开始介绍其connect流程，跟进代码到ClientConnections类中的connectAction方法：</p>\n<p><img src=\"http://i.imgur.com/mXz6h2H.png\" alt=\"\"></p>\n<p>获取到新建连接的cid、uri和port信息，注意，这里是用本地的mosquitto作测试连接，所以uri通过ipconfig获取到的ip地址填入，port默认是1883（当然，你可以作修改），cid可以随意。</p>\n<p>其中还有其他一些参数（诸如ssl、qos和keepalive等）由于本篇主要介绍的是conncet所以不展开细说。ok，接着往下看：</p>\n<p><img src=\"http://i.imgur.com/WzEHxZO.png\" alt=\"\"></p>\n<p><img src=\"http://i.imgur.com/RJIgpES.png\" alt=\"\"></p>\n<p>这里要对回调进行区分，以上截图第一个回调MqttCallbackHandler主要是接收服务端push过来的信息回调；而下图的callback继承于ActionListener，顾名思义，是发起本次“动作”的回调结果，连接是一个动作，订阅是一个动作，客户端push信息也是一个动作，每次动作的发起都会注册回调返回结果。区分好上述两个回调后，开始走进connect操作的核心。</p>\n<h2 id=\"MqttService\"><a href=\"#MqttService\" class=\"headerlink\" title=\"MqttService\"></a>MqttService</h2><p>connect前还需要做一个操作，就是区分每一次连接，这里是用MqttTokenAndroid来保存当前连接的callback。我们知道，连接过程的时间并不是我们所能控制的，所以这里开启了一个service来进行后面的操作。这里需要说明一点的是，在startService后进入到MqttService的onStartCommand方法中，注册了一个广播：</p>\n<p><img src=\"http://i.imgur.com/WlIsDzx.png\" alt=\"\"></p>\n<p>该广播主要是检测手机网络的变化而进行重连或断开连接的提示操作。ok，在开启startService和bindService后注册了另外一个广播：</p>\n<p><img src=\"http://i.imgur.com/NNDEpwq.png\" alt=\"\"></p>\n<p>这个广播至关重要，因为它是接收服务端信息的桥梁，action是MqttServiceConstants.CALLBACK_TO_ACTIVITY，在后面会用到。</p>\n<h2 id=\"connect\"><a href=\"#connect\" class=\"headerlink\" title=\"connect\"></a>connect</h2><p>连接service成功后回调至onServiceConnected中做doConnect()方法，跟进代码，有这样一句：</p>\n<p><img src=\"http://i.imgur.com/IKUDaul.png\" alt=\"\"></p>\n<p>这里巧妙地用一个以递增num作key、token作value的map来保存映射每次的连接操作。之后做mqttService.connect()。</p>\n<p>跟到MqttConnection的connect方法，设置一个回调的bundle，action指定为CONNECT_ACTION，并把传进来的token带上，这里多设置了一层代理的IMqttActionListener，把上述设置的bundle带上。然后就new出一个MqttAsyncClient，并绑定上述设置的IMqttActionListener作为回调，然后再做connect()。</p>\n<h2 id=\"tcp-ssl\"><a href=\"#tcp-ssl\" class=\"headerlink\" title=\"tcp / ssl\"></a>tcp / ssl</h2><p>跟进MqttAsyncClient类中的connect()方法，在进行一系列的当前连接状态判断之后，有以下一句代码：</p>\n<p><img src=\"http://i.imgur.com/OXZzldo.png\" alt=\"\"></p>\n<p>这里面是干嘛的呢？跟进去看下：</p>\n<p><img src=\"http://i.imgur.com/03bxLCO.png\" alt=\"\"></p>\n<p>原来是设置不同连接的端口和uri地址，这里是根据connect前是否设置ssl安全访问模式去设定的，默认ssl为false，即tcp连接。</p>\n<h2 id=\"connect-protocol-infomation\"><a href=\"#connect-protocol-infomation\" class=\"headerlink\" title=\"connect protocol infomation\"></a>connect protocol infomation</h2><p>跟到这里，发现复杂的代码总是设置各种代码和多层回调，给人雾里看花的感觉，也许这就是设计模式的魅力。别急，接着往下看，跟到ClientComms类的connect()方法。看到这里：</p>\n<p><img src=\"http://i.imgur.com/b4rdqKi.png\" alt=\"\"></p>\n<p>在MqttConnect的构造方法中第一句代码是 </p>\n<pre><code>super(MqttWireMessage.MESSAGE_TYPE_CONNECT);\n</code></pre><p>终于看到设置connect协议的地方了，为什么这么说？了解mqtt头部信息的读者应该对以下的图并不陌生：</p>\n<p><img src=\"http://i.imgur.com/ynGryag.png\" alt=\"\"></p>\n<p>要想进一步了解connect协议字段，可以参考文章开篇推荐的国人总结的系列文章中有提及到。 <a href=\"http://www.blogjava.net/yongboy/archive/2014/02/09/409630.html\" target=\"_blank\" rel=\"noopener\">送上链接</a></p>\n<h2 id=\"connect-Thread\"><a href=\"#connect-Thread\" class=\"headerlink\" title=\"connect Thread\"></a>connect Thread</h2><p>看到设置connect协议了，应该离真正连接的代码不远了。继续往下看：</p>\n<p><img src=\"http://i.imgur.com/3cevn7V.png\" alt=\"\"></p>\n<p>咦，这里开了一个线程，干嘛的呢？看下ConnectBG的run()方法：</p>\n<p><img src=\"http://i.imgur.com/ucJCDSt.png\" alt=\"\"></p>\n<p>接下来，打算分三部分来介绍。</p>\n<h3 id=\"socket\"><a href=\"#socket\" class=\"headerlink\" title=\"socket\"></a>socket</h3><p>NetworkModule是一个接口，真正实现的是在上述tcp/ssl介绍部分的TCPNetworkModule/LocalNetworkModule。这里以TCPNetworkModule为例，上代码：</p>\n<p><img src=\"http://i.imgur.com/ujIbCD6.png\" alt=\"\"></p>\n<p>哎呀，原来是用到socket连接，这下终于看到真面目了。这一步是打开了socket。</p>\n<h3 id=\"run-Threads\"><a href=\"#run-Threads\" class=\"headerlink\" title=\"run Threads\"></a>run Threads</h3><p>网络连接了，必然是开始数据的发送和接收处理。果不其然，接下来看到的是三个线程，分别是CommsReceiver、CommsSender和CommsCallback。<br>下面直接看下这三个线程的run方法：</p>\n<p><strong><em>CommsReceiver</em></strong>：</p>\n<p><img src=\"http://i.imgur.com/lb0DTw3.png\" alt=\"\"></p>\n<p>该线程用 in.available() &gt; 0 处理接收消息，如果没有接收到消息则一直处于阻塞状态；</p>\n<p><strong><em>CommsSender</em></strong>：</p>\n<p><img src=\"http://i.imgur.com/bG7FV1c.png\" alt=\"\"></p>\n<p>通过clientState.get()获取到发送消息，点进去get()方法看下：</p>\n<p><img src=\"http://i.imgur.com/nc5mpmS.png\" alt=\"\"></p>\n<p>这里定义pendingMessages和pendingFlows两个容器来处理不同的发送消息类型，并释放queueLock锁，queueLock.wait()一直阻塞等待被唤起。</p>\n<p><strong><em>CommsCallback</em></strong>：</p>\n<p><img src=\"http://i.imgur.com/Agf4Pis.png\" alt=\"\"></p>\n<p>和CommsSender类似，通过释放workAvailable锁，workAvailable.wait()一直阻塞等待被唤起。</p>\n<h3 id=\"send-connect-request\"><a href=\"#send-connect-request\" class=\"headerlink\" title=\"send connect request\"></a>send connect request</h3><p>看到上面介绍的三个线程均是阻塞状，接下来肯定是需要唤醒某个线程做发送操作了。跟进internalSend()方法：</p>\n<p><img src=\"http://i.imgur.com/UbJIeJv.png\" alt=\"\"></p>\n<p>看到这一步验证了我们的猜想，被唤起的是CommsSender这个线程：</p>\n<p><img src=\"http://i.imgur.com/CzzhoTL.png\" alt=\"\"></p>\n<p>最终通过out.write()和out.flush()把connect消息发送出去。</p>\n<h2 id=\"receive-connectAck\"><a href=\"#receive-connectAck\" class=\"headerlink\" title=\"receive connectAck\"></a>receive connectAck</h2><p>把coneect消息发送出去只是成功一半，接收到服务端的connectAck才算是connect成功。So，服务端发送过来的消息在哪里接收呢？CommsReceiver在获取到消息则不在阻塞，第一步先解析获取到数据类型：</p>\n<p><img src=\"http://i.imgur.com/rEuV1ov.png\" alt=\"\"></p>\n<p>如果阅读过推荐的解析MQTT协议文章的读者在这里应该理解不难，跟进createWireMessage()方法，由于收到的是connectAck，所以会走到这里：</p>\n<p><img src=\"http://i.imgur.com/TVppG3e.png\" alt=\"\"></p>\n<p>建立并返回的是一个MqttAck对象。继续返回到CommsReceiver：</p>\n<p><img src=\"http://i.imgur.com/FQSP8Nf.png\" alt=\"\"></p>\n<p>跟进clientState.notifyReceivedAck((MqttAck)message)，走到这里：</p>\n<p><img src=\"http://i.imgur.com/iEmslY9.png\" alt=\"\"></p>\n<p>获取rc状态码，等于0则会成功，这里面connected()方法是一个关键，主要是做心跳连接，这个后面再细讲；跟进notifyResult() 方法：</p>\n<p><img src=\"http://i.imgur.com/pbVUvhD.png\" alt=\"\"></p>\n<p><img src=\"http://i.imgur.com/58Q2QiK.png\" alt=\"\"></p>\n<p>哎呀，跟到最后，原来是为了唤醒CommsCallback这个线程。Then，跟到CommsCallback：</p>\n<p><img src=\"http://i.imgur.com/irBkubN.png\" alt=\"\"></p>\n<p>接着跟进去handleActionComplete()方法：</p>\n<p><img src=\"http://i.imgur.com/BfpZpiu.png\" alt=\"\"></p>\n<p><img src=\"http://i.imgur.com/5gCV2MN.png\" alt=\"\"></p>\n<p>至此，线程已经走完，剩下的就是之前设置下来的回调通知。这个相信读者可以自行往下阅读。</p>\n<h1 id=\"说到最后\"><a href=\"#说到最后\" class=\"headerlink\" title=\"说到最后\"></a>说到最后</h1><p>整个connect流程走下来还是很清晰可见的，后续会继续分析心跳ping、订阅和publish等流程，其实过程都是大同小异，都是基于以上三个线程去进行。所以，熟悉connect流程对之后的分析帮助很大。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"说在前面\"><a href=\"#说在前面\" class=\"headerlink\" title=\"说在前面\"></a>说在前面</h1><p>前段时间项目组在搞 <a href=\"http://blog.csdn.net/DreamTww/article/details/4632174\" target=\"_blank\" rel=\"noopener\">IM</a>，前期主要是对当前IM类似QQ、微信和环信等通信协议的采用分析，基本确定是在XMPP和MQTT二者选一。XMPP应用较为广泛稳定，但是如果应用在移动端实在是折腾不起，流量大，自然耗电量也会多。","more":"相比之下，初衷使用在推送方面的MQTT协议简直是为移动端的痛点应运而生。 <a href=\"http://xiangwangfeng.com/2015/05/20/%E7%A7%BB%E5%8A%A8IM%E5%BC%80%E5%8F%91%E9%82%A3%E4%BA%9B%E4%BA%8B/\" target=\"_blank\" rel=\"noopener\">参考</a></p>\n<h1 id=\"说些什么\"><a href=\"#说些什么\" class=\"headerlink\" title=\"说些什么\"></a>说些什么</h1><p>本文不是要详细展开对MQTT协议的解析，而是主要从github上的 <a href=\"https://github.com/sandro-k/org.eclipse.paho.android.service.sample\" target=\"_blank\" rel=\"noopener\">paho demo</a> 来对MQTT内部实现connect进行流程的梳理，结合其 <a href=\"http://public.dhe.ibm.com/software/dw/webservices/ws-mqtt/mqtt-v3r1.html\" target=\"_blank\" rel=\"noopener\">官方文档</a> 对协议格式的了解，相信读者能拨开云雾，了解其实现机制。另外，推荐下国人对MQTT理解写的 <a href=\"http://www.blogjava.net/yongboy/category/54835.html\" target=\"_blank\" rel=\"noopener\">系列文章</a>。注意的是，要跑起demo需要搭建测试服务器作订阅发送，建议采用mosquitto作连接服务端供本地测试， <a href=\"https://code.google.com/archive/p/mosquitto-mqtt-client-android/\" target=\"_blank\" rel=\"noopener\">参考地址</a></p>\n<h1 id=\"Read-Code\"><a href=\"#Read-Code\" class=\"headerlink\" title=\"Read Code\"></a>Read Code</h1><h2 id=\"Prepare\"><a href=\"#Prepare\" class=\"headerlink\" title=\"Prepare\"></a>Prepare</h2><p>假如demo能成功在手机端跑起，并且开启mosquitto，开始介绍其connect流程，跟进代码到ClientConnections类中的connectAction方法：</p>\n<p><img src=\"http://i.imgur.com/mXz6h2H.png\" alt=\"\"></p>\n<p>获取到新建连接的cid、uri和port信息，注意，这里是用本地的mosquitto作测试连接，所以uri通过ipconfig获取到的ip地址填入，port默认是1883（当然，你可以作修改），cid可以随意。</p>\n<p>其中还有其他一些参数（诸如ssl、qos和keepalive等）由于本篇主要介绍的是conncet所以不展开细说。ok，接着往下看：</p>\n<p><img src=\"http://i.imgur.com/WzEHxZO.png\" alt=\"\"></p>\n<p><img src=\"http://i.imgur.com/RJIgpES.png\" alt=\"\"></p>\n<p>这里要对回调进行区分，以上截图第一个回调MqttCallbackHandler主要是接收服务端push过来的信息回调；而下图的callback继承于ActionListener，顾名思义，是发起本次“动作”的回调结果，连接是一个动作，订阅是一个动作，客户端push信息也是一个动作，每次动作的发起都会注册回调返回结果。区分好上述两个回调后，开始走进connect操作的核心。</p>\n<h2 id=\"MqttService\"><a href=\"#MqttService\" class=\"headerlink\" title=\"MqttService\"></a>MqttService</h2><p>connect前还需要做一个操作，就是区分每一次连接，这里是用MqttTokenAndroid来保存当前连接的callback。我们知道，连接过程的时间并不是我们所能控制的，所以这里开启了一个service来进行后面的操作。这里需要说明一点的是，在startService后进入到MqttService的onStartCommand方法中，注册了一个广播：</p>\n<p><img src=\"http://i.imgur.com/WlIsDzx.png\" alt=\"\"></p>\n<p>该广播主要是检测手机网络的变化而进行重连或断开连接的提示操作。ok，在开启startService和bindService后注册了另外一个广播：</p>\n<p><img src=\"http://i.imgur.com/NNDEpwq.png\" alt=\"\"></p>\n<p>这个广播至关重要，因为它是接收服务端信息的桥梁，action是MqttServiceConstants.CALLBACK_TO_ACTIVITY，在后面会用到。</p>\n<h2 id=\"connect\"><a href=\"#connect\" class=\"headerlink\" title=\"connect\"></a>connect</h2><p>连接service成功后回调至onServiceConnected中做doConnect()方法，跟进代码，有这样一句：</p>\n<p><img src=\"http://i.imgur.com/IKUDaul.png\" alt=\"\"></p>\n<p>这里巧妙地用一个以递增num作key、token作value的map来保存映射每次的连接操作。之后做mqttService.connect()。</p>\n<p>跟到MqttConnection的connect方法，设置一个回调的bundle，action指定为CONNECT_ACTION，并把传进来的token带上，这里多设置了一层代理的IMqttActionListener，把上述设置的bundle带上。然后就new出一个MqttAsyncClient，并绑定上述设置的IMqttActionListener作为回调，然后再做connect()。</p>\n<h2 id=\"tcp-ssl\"><a href=\"#tcp-ssl\" class=\"headerlink\" title=\"tcp / ssl\"></a>tcp / ssl</h2><p>跟进MqttAsyncClient类中的connect()方法，在进行一系列的当前连接状态判断之后，有以下一句代码：</p>\n<p><img src=\"http://i.imgur.com/OXZzldo.png\" alt=\"\"></p>\n<p>这里面是干嘛的呢？跟进去看下：</p>\n<p><img src=\"http://i.imgur.com/03bxLCO.png\" alt=\"\"></p>\n<p>原来是设置不同连接的端口和uri地址，这里是根据connect前是否设置ssl安全访问模式去设定的，默认ssl为false，即tcp连接。</p>\n<h2 id=\"connect-protocol-infomation\"><a href=\"#connect-protocol-infomation\" class=\"headerlink\" title=\"connect protocol infomation\"></a>connect protocol infomation</h2><p>跟到这里，发现复杂的代码总是设置各种代码和多层回调，给人雾里看花的感觉，也许这就是设计模式的魅力。别急，接着往下看，跟到ClientComms类的connect()方法。看到这里：</p>\n<p><img src=\"http://i.imgur.com/b4rdqKi.png\" alt=\"\"></p>\n<p>在MqttConnect的构造方法中第一句代码是 </p>\n<pre><code>super(MqttWireMessage.MESSAGE_TYPE_CONNECT);\n</code></pre><p>终于看到设置connect协议的地方了，为什么这么说？了解mqtt头部信息的读者应该对以下的图并不陌生：</p>\n<p><img src=\"http://i.imgur.com/ynGryag.png\" alt=\"\"></p>\n<p>要想进一步了解connect协议字段，可以参考文章开篇推荐的国人总结的系列文章中有提及到。 <a href=\"http://www.blogjava.net/yongboy/archive/2014/02/09/409630.html\" target=\"_blank\" rel=\"noopener\">送上链接</a></p>\n<h2 id=\"connect-Thread\"><a href=\"#connect-Thread\" class=\"headerlink\" title=\"connect Thread\"></a>connect Thread</h2><p>看到设置connect协议了，应该离真正连接的代码不远了。继续往下看：</p>\n<p><img src=\"http://i.imgur.com/3cevn7V.png\" alt=\"\"></p>\n<p>咦，这里开了一个线程，干嘛的呢？看下ConnectBG的run()方法：</p>\n<p><img src=\"http://i.imgur.com/ucJCDSt.png\" alt=\"\"></p>\n<p>接下来，打算分三部分来介绍。</p>\n<h3 id=\"socket\"><a href=\"#socket\" class=\"headerlink\" title=\"socket\"></a>socket</h3><p>NetworkModule是一个接口，真正实现的是在上述tcp/ssl介绍部分的TCPNetworkModule/LocalNetworkModule。这里以TCPNetworkModule为例，上代码：</p>\n<p><img src=\"http://i.imgur.com/ujIbCD6.png\" alt=\"\"></p>\n<p>哎呀，原来是用到socket连接，这下终于看到真面目了。这一步是打开了socket。</p>\n<h3 id=\"run-Threads\"><a href=\"#run-Threads\" class=\"headerlink\" title=\"run Threads\"></a>run Threads</h3><p>网络连接了，必然是开始数据的发送和接收处理。果不其然，接下来看到的是三个线程，分别是CommsReceiver、CommsSender和CommsCallback。<br>下面直接看下这三个线程的run方法：</p>\n<p><strong><em>CommsReceiver</em></strong>：</p>\n<p><img src=\"http://i.imgur.com/lb0DTw3.png\" alt=\"\"></p>\n<p>该线程用 in.available() &gt; 0 处理接收消息，如果没有接收到消息则一直处于阻塞状态；</p>\n<p><strong><em>CommsSender</em></strong>：</p>\n<p><img src=\"http://i.imgur.com/bG7FV1c.png\" alt=\"\"></p>\n<p>通过clientState.get()获取到发送消息，点进去get()方法看下：</p>\n<p><img src=\"http://i.imgur.com/nc5mpmS.png\" alt=\"\"></p>\n<p>这里定义pendingMessages和pendingFlows两个容器来处理不同的发送消息类型，并释放queueLock锁，queueLock.wait()一直阻塞等待被唤起。</p>\n<p><strong><em>CommsCallback</em></strong>：</p>\n<p><img src=\"http://i.imgur.com/Agf4Pis.png\" alt=\"\"></p>\n<p>和CommsSender类似，通过释放workAvailable锁，workAvailable.wait()一直阻塞等待被唤起。</p>\n<h3 id=\"send-connect-request\"><a href=\"#send-connect-request\" class=\"headerlink\" title=\"send connect request\"></a>send connect request</h3><p>看到上面介绍的三个线程均是阻塞状，接下来肯定是需要唤醒某个线程做发送操作了。跟进internalSend()方法：</p>\n<p><img src=\"http://i.imgur.com/UbJIeJv.png\" alt=\"\"></p>\n<p>看到这一步验证了我们的猜想，被唤起的是CommsSender这个线程：</p>\n<p><img src=\"http://i.imgur.com/CzzhoTL.png\" alt=\"\"></p>\n<p>最终通过out.write()和out.flush()把connect消息发送出去。</p>\n<h2 id=\"receive-connectAck\"><a href=\"#receive-connectAck\" class=\"headerlink\" title=\"receive connectAck\"></a>receive connectAck</h2><p>把coneect消息发送出去只是成功一半，接收到服务端的connectAck才算是connect成功。So，服务端发送过来的消息在哪里接收呢？CommsReceiver在获取到消息则不在阻塞，第一步先解析获取到数据类型：</p>\n<p><img src=\"http://i.imgur.com/rEuV1ov.png\" alt=\"\"></p>\n<p>如果阅读过推荐的解析MQTT协议文章的读者在这里应该理解不难，跟进createWireMessage()方法，由于收到的是connectAck，所以会走到这里：</p>\n<p><img src=\"http://i.imgur.com/TVppG3e.png\" alt=\"\"></p>\n<p>建立并返回的是一个MqttAck对象。继续返回到CommsReceiver：</p>\n<p><img src=\"http://i.imgur.com/FQSP8Nf.png\" alt=\"\"></p>\n<p>跟进clientState.notifyReceivedAck((MqttAck)message)，走到这里：</p>\n<p><img src=\"http://i.imgur.com/iEmslY9.png\" alt=\"\"></p>\n<p>获取rc状态码，等于0则会成功，这里面connected()方法是一个关键，主要是做心跳连接，这个后面再细讲；跟进notifyResult() 方法：</p>\n<p><img src=\"http://i.imgur.com/pbVUvhD.png\" alt=\"\"></p>\n<p><img src=\"http://i.imgur.com/58Q2QiK.png\" alt=\"\"></p>\n<p>哎呀，跟到最后，原来是为了唤醒CommsCallback这个线程。Then，跟到CommsCallback：</p>\n<p><img src=\"http://i.imgur.com/irBkubN.png\" alt=\"\"></p>\n<p>接着跟进去handleActionComplete()方法：</p>\n<p><img src=\"http://i.imgur.com/BfpZpiu.png\" alt=\"\"></p>\n<p><img src=\"http://i.imgur.com/5gCV2MN.png\" alt=\"\"></p>\n<p>至此，线程已经走完，剩下的就是之前设置下来的回调通知。这个相信读者可以自行往下阅读。</p>\n<h1 id=\"说到最后\"><a href=\"#说到最后\" class=\"headerlink\" title=\"说到最后\"></a>说到最后</h1><p>整个connect流程走下来还是很清晰可见的，后续会继续分析心跳ping、订阅和publish等流程，其实过程都是大同小异，都是基于以上三个线程去进行。所以，熟悉connect流程对之后的分析帮助很大。</p>"},{"title":"Hexo搭建优化部署","date":"2018-01-28T15:39:34.390Z","_content":"\n\n# 前言\n作为一名专业的技术码农，经验积累和技术分享是一项必不可少的软技能。俗话说，好记性不如烂笔头，在平时工作中遇到的各种奇葩问题和学习感悟用文档记录是个很好的习惯，同时也可以用做分享，让别人或者自己少走弯路。目前网上各种技术博客可谓百花齐放，诸如CSDN、51blog和不少公司定制的分享博客等，当然也有不少公司内部分享的.md记录文档。当然了，如果\n<!-- more -->你是一名“异类”的程序猿，不满足于现有的博客框架，不妨考虑下本文介绍的Github pages+Hexo+Nodejs搭建个人blog。\n\n# 概要说明\n\n网上对于这种博客的搭建应该是有相当多的介绍了，[简单的搭建](http://cstsinghua.github.io/2016/06/16/Github%20pages+Hexo+Nodejs%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BAblog/#建站\")或者换一个皮肤相信也难不到大家。但是大家在使用的过程中应该会发现，框架的搭建是依赖于当前的电脑，假如电脑要重装或者直接挂了要换一台新的，这样原本的记录岂不是全没了？我一直都相信，高手在人间，发现这个问题的早有人在，而解决的办法总比问题多，本文的介绍就是参考网上的配置做法做点补充：[参考文章](http://crazymilk.github.io/2015/12/28/GitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/#more)\n\n# 搭建流程\n\n参考上面提供文章链接中的第四点 **优化部署与管理**，笔者在配置过程出现了几个问题导致一直配置失败，在这里分享下希望有同样问题的读者可以参考，过程大同小异：\n\n1. 创建仓库，hellokugo.github.io.git；<br>\n2. 创建两个分支：master 与 hexo；<br>\n3. 设置hexo为默认分支（因为我们只需要手动管理这个分支上的Hexo网站文件）；<br>\n4. 使用git clone git@github.com:hellokugo/hellokugo.github.io.git拷贝仓库；<br>\n5. hellokugo.github.io文件夹下通过Git bash依次执行npm install hexo、hexo init、npm install 和 npm install hexo-deployer-git（此时当前分支应显示为hexo）;<br>\n\n\t**注意1：笔者在这里踩了坑，在执行hexo init的时候会把第二步clone下来的文件.git给删掉，导致在下面做代码提交步骤时一直报找不到.git文件错误，所以，在执行第五步或者执行hexo init前把.git文件放到上级目录（或者在执行完第五步再把.git文件放回来，这个没有做测试），这样就不会出现这样的错误了。这里可以用git branch来检查下当前分支会否为hexo**<br>\n\n6. 修改_config.yml中的deploy参数，分支应为master（可用git branch命令来检查）；\n7. 依次执行git add .、git commit -m “…”、git push origin hexo提交网站相关的文件；\n\n\t**注意2：这里最后一步git push origin hexo，对于还没习惯git工具的读者可能会直接按照这个命令输入，然后就抛出origin未定义的错误，这个如果有点git工具使用经验的读者来说，是应该在这命令前先定义origin，即git remote add origin git@github.com:hellokugo/hellokugo.github.io.git（这里是你的仓库github地址）**<br>\n\n8. 执行hexo generate -d生成网站并部署到GitHub上。\n\n\t**注意3：有些读者可能走到这一步时就抛出FATE Deploy failed: git，这个问题在于执行第五步的最后一句命令npm install hexo-deployer-git没有把相关文件记录下来导致出错，不过这可能不是每个人都会出现，如果出现了，再执行npm install hexo-deployer-git --save,，然后再部署即可。**<br>\n\n# 最后\n\n其实上述步骤完全可以写一个简单的python脚本实现（有需要可以提供一个参数输入，用于填写提交日志），这里就不累赘了。最后，感谢参考文章中笔者提供这种思路去巧妙解决电脑各种丢失数据而导致的问题，真心想说一句，站在巨人的肩上，技术路上不孤单。","source":"_posts/Hexo搭建优化部署.md","raw":"title: Hexo搭建优化部署\ndate: 2016/9/4 00：17\n\ncategories:\n- Others\ntags:\n- other\n---\n\n\n# 前言\n作为一名专业的技术码农，经验积累和技术分享是一项必不可少的软技能。俗话说，好记性不如烂笔头，在平时工作中遇到的各种奇葩问题和学习感悟用文档记录是个很好的习惯，同时也可以用做分享，让别人或者自己少走弯路。目前网上各种技术博客可谓百花齐放，诸如CSDN、51blog和不少公司定制的分享博客等，当然也有不少公司内部分享的.md记录文档。当然了，如果\n<!-- more -->你是一名“异类”的程序猿，不满足于现有的博客框架，不妨考虑下本文介绍的Github pages+Hexo+Nodejs搭建个人blog。\n\n# 概要说明\n\n网上对于这种博客的搭建应该是有相当多的介绍了，[简单的搭建](http://cstsinghua.github.io/2016/06/16/Github%20pages+Hexo+Nodejs%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BAblog/#建站\")或者换一个皮肤相信也难不到大家。但是大家在使用的过程中应该会发现，框架的搭建是依赖于当前的电脑，假如电脑要重装或者直接挂了要换一台新的，这样原本的记录岂不是全没了？我一直都相信，高手在人间，发现这个问题的早有人在，而解决的办法总比问题多，本文的介绍就是参考网上的配置做法做点补充：[参考文章](http://crazymilk.github.io/2015/12/28/GitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/#more)\n\n# 搭建流程\n\n参考上面提供文章链接中的第四点 **优化部署与管理**，笔者在配置过程出现了几个问题导致一直配置失败，在这里分享下希望有同样问题的读者可以参考，过程大同小异：\n\n1. 创建仓库，hellokugo.github.io.git；<br>\n2. 创建两个分支：master 与 hexo；<br>\n3. 设置hexo为默认分支（因为我们只需要手动管理这个分支上的Hexo网站文件）；<br>\n4. 使用git clone git@github.com:hellokugo/hellokugo.github.io.git拷贝仓库；<br>\n5. hellokugo.github.io文件夹下通过Git bash依次执行npm install hexo、hexo init、npm install 和 npm install hexo-deployer-git（此时当前分支应显示为hexo）;<br>\n\n\t**注意1：笔者在这里踩了坑，在执行hexo init的时候会把第二步clone下来的文件.git给删掉，导致在下面做代码提交步骤时一直报找不到.git文件错误，所以，在执行第五步或者执行hexo init前把.git文件放到上级目录（或者在执行完第五步再把.git文件放回来，这个没有做测试），这样就不会出现这样的错误了。这里可以用git branch来检查下当前分支会否为hexo**<br>\n\n6. 修改_config.yml中的deploy参数，分支应为master（可用git branch命令来检查）；\n7. 依次执行git add .、git commit -m “…”、git push origin hexo提交网站相关的文件；\n\n\t**注意2：这里最后一步git push origin hexo，对于还没习惯git工具的读者可能会直接按照这个命令输入，然后就抛出origin未定义的错误，这个如果有点git工具使用经验的读者来说，是应该在这命令前先定义origin，即git remote add origin git@github.com:hellokugo/hellokugo.github.io.git（这里是你的仓库github地址）**<br>\n\n8. 执行hexo generate -d生成网站并部署到GitHub上。\n\n\t**注意3：有些读者可能走到这一步时就抛出FATE Deploy failed: git，这个问题在于执行第五步的最后一句命令npm install hexo-deployer-git没有把相关文件记录下来导致出错，不过这可能不是每个人都会出现，如果出现了，再执行npm install hexo-deployer-git --save,，然后再部署即可。**<br>\n\n# 最后\n\n其实上述步骤完全可以写一个简单的python脚本实现（有需要可以提供一个参数输入，用于填写提交日志），这里就不累赘了。最后，感谢参考文章中笔者提供这种思路去巧妙解决电脑各种丢失数据而导致的问题，真心想说一句，站在巨人的肩上，技术路上不孤单。","slug":"Hexo搭建优化部署","published":1,"updated":"2018-01-28T15:39:34.390Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjcyyg7ju0008nius2i23pwfo","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>作为一名专业的技术码农，经验积累和技术分享是一项必不可少的软技能。俗话说，好记性不如烂笔头，在平时工作中遇到的各种奇葩问题和学习感悟用文档记录是个很好的习惯，同时也可以用做分享，让别人或者自己少走弯路。目前网上各种技术博客可谓百花齐放，诸如CSDN、51blog和不少公司定制的分享博客等，当然也有不少公司内部分享的.md记录文档。当然了，如果<br><a id=\"more\"></a>你是一名“异类”的程序猿，不满足于现有的博客框架，不妨考虑下本文介绍的Github pages+Hexo+Nodejs搭建个人blog。</p>\n<h1 id=\"概要说明\"><a href=\"#概要说明\" class=\"headerlink\" title=\"概要说明\"></a>概要说明</h1><p>网上对于这种博客的搭建应该是有相当多的介绍了，<a href=\"http://cstsinghua.github.io/2016/06/16/Github%20pages+Hexo+Nodejs%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BAblog/#建站&quot;\" target=\"_blank\" rel=\"noopener\">简单的搭建</a>或者换一个皮肤相信也难不到大家。但是大家在使用的过程中应该会发现，框架的搭建是依赖于当前的电脑，假如电脑要重装或者直接挂了要换一台新的，这样原本的记录岂不是全没了？我一直都相信，高手在人间，发现这个问题的早有人在，而解决的办法总比问题多，本文的介绍就是参考网上的配置做法做点补充：<a href=\"http://crazymilk.github.io/2015/12/28/GitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/#more\" target=\"_blank\" rel=\"noopener\">参考文章</a></p>\n<h1 id=\"搭建流程\"><a href=\"#搭建流程\" class=\"headerlink\" title=\"搭建流程\"></a>搭建流程</h1><p>参考上面提供文章链接中的第四点 <strong>优化部署与管理</strong>，笔者在配置过程出现了几个问题导致一直配置失败，在这里分享下希望有同样问题的读者可以参考，过程大同小异：</p>\n<ol>\n<li>创建仓库，hellokugo.github.io.git；<br></li>\n<li>创建两个分支：master 与 hexo；<br></li>\n<li>设置hexo为默认分支（因为我们只需要手动管理这个分支上的Hexo网站文件）；<br></li>\n<li>使用git clone git@github.com:hellokugo/hellokugo.github.io.git拷贝仓库；<br></li>\n<li><p>hellokugo.github.io文件夹下通过Git bash依次执行npm install hexo、hexo init、npm install 和 npm install hexo-deployer-git（此时当前分支应显示为hexo）;<br></p>\n<p> <strong>注意1：笔者在这里踩了坑，在执行hexo init的时候会把第二步clone下来的文件.git给删掉，导致在下面做代码提交步骤时一直报找不到.git文件错误，所以，在执行第五步或者执行hexo init前把.git文件放到上级目录（或者在执行完第五步再把.git文件放回来，这个没有做测试），这样就不会出现这样的错误了。这里可以用git branch来检查下当前分支会否为hexo</strong><br></p>\n</li>\n<li><p>修改_config.yml中的deploy参数，分支应为master（可用git branch命令来检查）；</p>\n</li>\n<li><p>依次执行git add .、git commit -m “…”、git push origin hexo提交网站相关的文件；</p>\n<p> <strong>注意2：这里最后一步git push origin hexo，对于还没习惯git工具的读者可能会直接按照这个命令输入，然后就抛出origin未定义的错误，这个如果有点git工具使用经验的读者来说，是应该在这命令前先定义origin，即git remote add origin git@github.com:hellokugo/hellokugo.github.io.git（这里是你的仓库github地址）</strong><br></p>\n</li>\n<li><p>执行hexo generate -d生成网站并部署到GitHub上。</p>\n<p> <strong>注意3：有些读者可能走到这一步时就抛出FATE Deploy failed: git，这个问题在于执行第五步的最后一句命令npm install hexo-deployer-git没有把相关文件记录下来导致出错，不过这可能不是每个人都会出现，如果出现了，再执行npm install hexo-deployer-git –save,，然后再部署即可。</strong><br></p>\n</li>\n</ol>\n<h1 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h1><p>其实上述步骤完全可以写一个简单的python脚本实现（有需要可以提供一个参数输入，用于填写提交日志），这里就不累赘了。最后，感谢参考文章中笔者提供这种思路去巧妙解决电脑各种丢失数据而导致的问题，真心想说一句，站在巨人的肩上，技术路上不孤单。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>作为一名专业的技术码农，经验积累和技术分享是一项必不可少的软技能。俗话说，好记性不如烂笔头，在平时工作中遇到的各种奇葩问题和学习感悟用文档记录是个很好的习惯，同时也可以用做分享，让别人或者自己少走弯路。目前网上各种技术博客可谓百花齐放，诸如CSDN、51blog和不少公司定制的分享博客等，当然也有不少公司内部分享的.md记录文档。当然了，如果<br>","more":"你是一名“异类”的程序猿，不满足于现有的博客框架，不妨考虑下本文介绍的Github pages+Hexo+Nodejs搭建个人blog。</p>\n<h1 id=\"概要说明\"><a href=\"#概要说明\" class=\"headerlink\" title=\"概要说明\"></a>概要说明</h1><p>网上对于这种博客的搭建应该是有相当多的介绍了，<a href=\"http://cstsinghua.github.io/2016/06/16/Github%20pages+Hexo+Nodejs%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BAblog/#建站&quot;\" target=\"_blank\" rel=\"noopener\">简单的搭建</a>或者换一个皮肤相信也难不到大家。但是大家在使用的过程中应该会发现，框架的搭建是依赖于当前的电脑，假如电脑要重装或者直接挂了要换一台新的，这样原本的记录岂不是全没了？我一直都相信，高手在人间，发现这个问题的早有人在，而解决的办法总比问题多，本文的介绍就是参考网上的配置做法做点补充：<a href=\"http://crazymilk.github.io/2015/12/28/GitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/#more\" target=\"_blank\" rel=\"noopener\">参考文章</a></p>\n<h1 id=\"搭建流程\"><a href=\"#搭建流程\" class=\"headerlink\" title=\"搭建流程\"></a>搭建流程</h1><p>参考上面提供文章链接中的第四点 <strong>优化部署与管理</strong>，笔者在配置过程出现了几个问题导致一直配置失败，在这里分享下希望有同样问题的读者可以参考，过程大同小异：</p>\n<ol>\n<li>创建仓库，hellokugo.github.io.git；<br></li>\n<li>创建两个分支：master 与 hexo；<br></li>\n<li>设置hexo为默认分支（因为我们只需要手动管理这个分支上的Hexo网站文件）；<br></li>\n<li>使用git clone git@github.com:hellokugo/hellokugo.github.io.git拷贝仓库；<br></li>\n<li><p>hellokugo.github.io文件夹下通过Git bash依次执行npm install hexo、hexo init、npm install 和 npm install hexo-deployer-git（此时当前分支应显示为hexo）;<br></p>\n<p> <strong>注意1：笔者在这里踩了坑，在执行hexo init的时候会把第二步clone下来的文件.git给删掉，导致在下面做代码提交步骤时一直报找不到.git文件错误，所以，在执行第五步或者执行hexo init前把.git文件放到上级目录（或者在执行完第五步再把.git文件放回来，这个没有做测试），这样就不会出现这样的错误了。这里可以用git branch来检查下当前分支会否为hexo</strong><br></p>\n</li>\n<li><p>修改_config.yml中的deploy参数，分支应为master（可用git branch命令来检查）；</p>\n</li>\n<li><p>依次执行git add .、git commit -m “…”、git push origin hexo提交网站相关的文件；</p>\n<p> <strong>注意2：这里最后一步git push origin hexo，对于还没习惯git工具的读者可能会直接按照这个命令输入，然后就抛出origin未定义的错误，这个如果有点git工具使用经验的读者来说，是应该在这命令前先定义origin，即git remote add origin git@github.com:hellokugo/hellokugo.github.io.git（这里是你的仓库github地址）</strong><br></p>\n</li>\n<li><p>执行hexo generate -d生成网站并部署到GitHub上。</p>\n<p> <strong>注意3：有些读者可能走到这一步时就抛出FATE Deploy failed: git，这个问题在于执行第五步的最后一句命令npm install hexo-deployer-git没有把相关文件记录下来导致出错，不过这可能不是每个人都会出现，如果出现了，再执行npm install hexo-deployer-git –save,，然后再部署即可。</strong><br></p>\n</li>\n</ol>\n<h1 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h1><p>其实上述步骤完全可以写一个简单的python脚本实现（有需要可以提供一个参数输入，用于填写提交日志），这里就不累赘了。最后，感谢参考文章中笔者提供这种思路去巧妙解决电脑各种丢失数据而导致的问题，真心想说一句，站在巨人的肩上，技术路上不孤单。</p>"},{"title":"MQTT源码解析之心跳ping","date":"2018-01-28T15:39:34.391Z","_content":"\n# 前言\n\n前面已经解析了MQTT的 [connect连接源码](https://hellokugo.github.io/2016/12/20/MQTT%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8Bconnect/) ，接下来介绍MQTT心跳实现机制。<!-- more -->\n\n# 实现原理\n\n我们知道，手机客户端对流量和电量的要求极为苛刻。如果要保持MQTT的长连接就无法避免上述两个条件的限制。网上有很多检测网络是否连接的方法，这里从MQTT源码出发，找到一些相关的资料：\n\n[android设备休眠](http://www.cnblogs.com/kobe8/p/3819305.html)\n\n[Android手机的休眠状态](http://blog.csdn.net/berber78/article/details/46696675)\n\n推荐这两篇文章，都是在阐述Android手机有AP和BP两个处理器。事实上，MQTT也是从这思路去考虑，提供两种方式去实现心跳ping，分别是TimerTask和AlarmManager，具体实现类看继承关系：\n\n![](http://i.imgur.com/RhuZtuK.png)\n\n深入查看MQTT的当前实现，是采用AlarmManager这种方法来实现心跳连接。这也是Android官方推荐的定时任务实现，有一篇文章做了这两种实现方式的相关测试 [Android定时任务详解](http://jellybins.github.io/2016/01/26/Android%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E8%AF%A6%E8%A7%A3/)。\n\n# ping消息格式\n\n因为ping消息是我们自定义用作判断连接的消息，所以这个消息尽可能避免给正常收发消息带来不必要的消耗，而mqtt对ping消息的格式设计是怎样的呢？我们可以看下MqttPingReq.java这个类：\n\n![](http://i.imgur.com/bCTNRAX.png)\n\n很简单，定义了MESSAGE_TYPE_PINGREQ的消息类型，同时注意到复写getVariableHeader方法返回一个0字节的数组，同时也没有复写父类的getPayload方法，这说明ping消息结构只是简单的包含头部信息，即只有两个字节，非常轻便。\n\n# flow the code\n\n## 定义AlarmManager\n\nok，我们开始看下具体实现代码。首先，我们上面说到，MQTT采用的是AlarmManager这种方式来实现ping，这个可以从MqttConnection类中connect方法中看到其初始化：\n\n![](http://i.imgur.com/GsbTAF0.png)\n\n那么，它究竟什么时候开始ping呢？正常的想，应该是connect成功之后就可以开始，那就是收到connectAck之后。在介绍connect时说过，接收服务端发送过来的代码实现在CommsReceiver类中的线程中，追踪下代码，果不其然，在收到connectAck后进行解析：\n\n![](http://i.imgur.com/2b2xsAU.png)\n\n这个connected()方法就是ping的逻辑。开始跟进去看看：\n\n![](http://i.imgur.com/SEJQQOs.png)\n\n这里的pingSender就是AlarmPingSender的实例，跟进AlarmPingSender的start方法：\n\n![](http://i.imgur.com/FFrpFgh.png)\n\n这里注册了一个alarmReceiver的广播，这个稍后解析；定义一个和alarmReceiver一样action的pendingIntent，在schedule方法中具体实现：\n\n![](http://i.imgur.com/RRs2GTP.png)\n\n逻辑比较简单，定义了AlarmManager，并且在delayInMilliseconds（当前时间 + delayInMilliseconds）后去发送广播到alarmReceiver。那么，这个delayInMilliseconds即comms.getKeepAlive()是怎么传入的呢？这个可以在连接前定义MqttConnectOptions时进行设置：\n\n![](http://i.imgur.com/Zl7j7R6.png)\n\n如果不设置，默认值是60s。\n\n## alarmReceiver\n\n上面介绍说了，AlarmManager会在delayTime后发送广播，alarmReceiver的具体实现是AlarmReceiver类的onReceive方法中：\n\n![](http://i.imgur.com/3Z772yr.png)\n\n这里面主要分三部分，第一部分是发送ping的关键代码逻辑，也包含判断当前网络是否ping失败和规划下次ping的时间；第二部分是获取PowerManager的wakelock（这个是针对ping返回callback处理的wakelock，尽管在设置alarmManager时已经有获取过wakelock），保持CPU运转；第三部分是在发送ping后等待收到服务端pingResponse释放wakelock以尽可能减少对手机电源的损耗。接下来介绍下第一部分。\n\n## ping\n\n![](http://i.imgur.com/t5a4GoO.png)\n\n这里首先判断上一次ping是否失败，包括手机客户端和服务端的异常，这里说明一下，pingOutstanding是每次发送ping都会加1，收到pingResponse就减1；lastInboundActivity是代表上一次收到服务端消息的时间，相反地lastOutboundActivity则是上一次发送消息的时间；设置delta是因为代码使用System.currentTimeMillis()获取当前时间会有误差，所以尽可能加减delta值减少误差。\n\n两种异常注释已经解释得很清楚了。第一种异常是客户端发送ping消息后，在距离上一次接受到服务端发送回来的消息时间大于keepAlive + delta 认为是服务端没有reply客户端的ping消息异常；第二种异常则是认为客户端发送的ping没有在两个keepAlive时间发出，此时抛出写ping异常。接下来是对当前时间判断是否需要发送ping或者动态规划下一次接收广播时间：\n\n![](http://i.imgur.com/Gi7djvl.png)\n\n首先判断此次keepAlive时间内客户端是否有发送或者接收信息，如果没有则发送ping消息，并把下次ping的时间设置成当初传入的keepAlive，这里的判断条件有两种情况，注释也说明得比较清晰；如果在此次keepAlive时间内客户端有收发信息（除ping消息外），则重新规划下次ping的时间，这里主要是以上一次客户端发送消息的时间为准，以设置全局的keepAlive和当前时间做一个差运算，time - lastOutboundActivity即离上一次客户端发送信息时间越长，则设置下次ping时间越短，这个也很好理解，如果当前客户端收发信息频繁，则没必要在短时间内自定义发送ping，此时应该认为断开连接的异常机会较小，应当减少自定义ping。这种动态规划ping时间很巧妙，尽可能保证可以检测出连接异常，同时也减少ping的频率和消耗。\n\n## 释放WakeLock\n\n在上述分析中，成功发送ping消息后，获取手机WakeLock并针对此次ping的返回释放WakeLock。过程和介绍connect流程基本一致，也是走CommsSender-->CommsReceiver-->CommsCallback这三个线程的run方法，具体的代码这里就不跟了。最终走到CommsCallback的handleActionComplete方法，执行fireActionEvent方法对ping保存的token进行回调。记住，无论成功与否，必须释放本次创建的WakeLock，避免不必要的消耗。\n\n至此，mqtt的ping流程已经介绍完毕。","source":"_posts/MQTT源码解析之心跳ping.md","raw":"title: MQTT源码解析之心跳ping\ndate: 2017/2/1 14：18\n\ncategories:\n- Android\ntags:\n- Android，MQTT，ping\n---\n\n# 前言\n\n前面已经解析了MQTT的 [connect连接源码](https://hellokugo.github.io/2016/12/20/MQTT%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8Bconnect/) ，接下来介绍MQTT心跳实现机制。<!-- more -->\n\n# 实现原理\n\n我们知道，手机客户端对流量和电量的要求极为苛刻。如果要保持MQTT的长连接就无法避免上述两个条件的限制。网上有很多检测网络是否连接的方法，这里从MQTT源码出发，找到一些相关的资料：\n\n[android设备休眠](http://www.cnblogs.com/kobe8/p/3819305.html)\n\n[Android手机的休眠状态](http://blog.csdn.net/berber78/article/details/46696675)\n\n推荐这两篇文章，都是在阐述Android手机有AP和BP两个处理器。事实上，MQTT也是从这思路去考虑，提供两种方式去实现心跳ping，分别是TimerTask和AlarmManager，具体实现类看继承关系：\n\n![](http://i.imgur.com/RhuZtuK.png)\n\n深入查看MQTT的当前实现，是采用AlarmManager这种方法来实现心跳连接。这也是Android官方推荐的定时任务实现，有一篇文章做了这两种实现方式的相关测试 [Android定时任务详解](http://jellybins.github.io/2016/01/26/Android%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E8%AF%A6%E8%A7%A3/)。\n\n# ping消息格式\n\n因为ping消息是我们自定义用作判断连接的消息，所以这个消息尽可能避免给正常收发消息带来不必要的消耗，而mqtt对ping消息的格式设计是怎样的呢？我们可以看下MqttPingReq.java这个类：\n\n![](http://i.imgur.com/bCTNRAX.png)\n\n很简单，定义了MESSAGE_TYPE_PINGREQ的消息类型，同时注意到复写getVariableHeader方法返回一个0字节的数组，同时也没有复写父类的getPayload方法，这说明ping消息结构只是简单的包含头部信息，即只有两个字节，非常轻便。\n\n# flow the code\n\n## 定义AlarmManager\n\nok，我们开始看下具体实现代码。首先，我们上面说到，MQTT采用的是AlarmManager这种方式来实现ping，这个可以从MqttConnection类中connect方法中看到其初始化：\n\n![](http://i.imgur.com/GsbTAF0.png)\n\n那么，它究竟什么时候开始ping呢？正常的想，应该是connect成功之后就可以开始，那就是收到connectAck之后。在介绍connect时说过，接收服务端发送过来的代码实现在CommsReceiver类中的线程中，追踪下代码，果不其然，在收到connectAck后进行解析：\n\n![](http://i.imgur.com/2b2xsAU.png)\n\n这个connected()方法就是ping的逻辑。开始跟进去看看：\n\n![](http://i.imgur.com/SEJQQOs.png)\n\n这里的pingSender就是AlarmPingSender的实例，跟进AlarmPingSender的start方法：\n\n![](http://i.imgur.com/FFrpFgh.png)\n\n这里注册了一个alarmReceiver的广播，这个稍后解析；定义一个和alarmReceiver一样action的pendingIntent，在schedule方法中具体实现：\n\n![](http://i.imgur.com/RRs2GTP.png)\n\n逻辑比较简单，定义了AlarmManager，并且在delayInMilliseconds（当前时间 + delayInMilliseconds）后去发送广播到alarmReceiver。那么，这个delayInMilliseconds即comms.getKeepAlive()是怎么传入的呢？这个可以在连接前定义MqttConnectOptions时进行设置：\n\n![](http://i.imgur.com/Zl7j7R6.png)\n\n如果不设置，默认值是60s。\n\n## alarmReceiver\n\n上面介绍说了，AlarmManager会在delayTime后发送广播，alarmReceiver的具体实现是AlarmReceiver类的onReceive方法中：\n\n![](http://i.imgur.com/3Z772yr.png)\n\n这里面主要分三部分，第一部分是发送ping的关键代码逻辑，也包含判断当前网络是否ping失败和规划下次ping的时间；第二部分是获取PowerManager的wakelock（这个是针对ping返回callback处理的wakelock，尽管在设置alarmManager时已经有获取过wakelock），保持CPU运转；第三部分是在发送ping后等待收到服务端pingResponse释放wakelock以尽可能减少对手机电源的损耗。接下来介绍下第一部分。\n\n## ping\n\n![](http://i.imgur.com/t5a4GoO.png)\n\n这里首先判断上一次ping是否失败，包括手机客户端和服务端的异常，这里说明一下，pingOutstanding是每次发送ping都会加1，收到pingResponse就减1；lastInboundActivity是代表上一次收到服务端消息的时间，相反地lastOutboundActivity则是上一次发送消息的时间；设置delta是因为代码使用System.currentTimeMillis()获取当前时间会有误差，所以尽可能加减delta值减少误差。\n\n两种异常注释已经解释得很清楚了。第一种异常是客户端发送ping消息后，在距离上一次接受到服务端发送回来的消息时间大于keepAlive + delta 认为是服务端没有reply客户端的ping消息异常；第二种异常则是认为客户端发送的ping没有在两个keepAlive时间发出，此时抛出写ping异常。接下来是对当前时间判断是否需要发送ping或者动态规划下一次接收广播时间：\n\n![](http://i.imgur.com/Gi7djvl.png)\n\n首先判断此次keepAlive时间内客户端是否有发送或者接收信息，如果没有则发送ping消息，并把下次ping的时间设置成当初传入的keepAlive，这里的判断条件有两种情况，注释也说明得比较清晰；如果在此次keepAlive时间内客户端有收发信息（除ping消息外），则重新规划下次ping的时间，这里主要是以上一次客户端发送消息的时间为准，以设置全局的keepAlive和当前时间做一个差运算，time - lastOutboundActivity即离上一次客户端发送信息时间越长，则设置下次ping时间越短，这个也很好理解，如果当前客户端收发信息频繁，则没必要在短时间内自定义发送ping，此时应该认为断开连接的异常机会较小，应当减少自定义ping。这种动态规划ping时间很巧妙，尽可能保证可以检测出连接异常，同时也减少ping的频率和消耗。\n\n## 释放WakeLock\n\n在上述分析中，成功发送ping消息后，获取手机WakeLock并针对此次ping的返回释放WakeLock。过程和介绍connect流程基本一致，也是走CommsSender-->CommsReceiver-->CommsCallback这三个线程的run方法，具体的代码这里就不跟了。最终走到CommsCallback的handleActionComplete方法，执行fireActionEvent方法对ping保存的token进行回调。记住，无论成功与否，必须释放本次创建的WakeLock，避免不必要的消耗。\n\n至此，mqtt的ping流程已经介绍完毕。","slug":"MQTT源码解析之心跳ping","published":1,"updated":"2018-01-28T15:39:34.391Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjcyyg7k1000cniushjqbq9w7","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>前面已经解析了MQTT的 <a href=\"https://hellokugo.github.io/2016/12/20/MQTT%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8Bconnect/\">connect连接源码</a> ，接下来介绍MQTT心跳实现机制。<a id=\"more\"></a></p>\n<h1 id=\"实现原理\"><a href=\"#实现原理\" class=\"headerlink\" title=\"实现原理\"></a>实现原理</h1><p>我们知道，手机客户端对流量和电量的要求极为苛刻。如果要保持MQTT的长连接就无法避免上述两个条件的限制。网上有很多检测网络是否连接的方法，这里从MQTT源码出发，找到一些相关的资料：</p>\n<p><a href=\"http://www.cnblogs.com/kobe8/p/3819305.html\" target=\"_blank\" rel=\"noopener\">android设备休眠</a></p>\n<p><a href=\"http://blog.csdn.net/berber78/article/details/46696675\" target=\"_blank\" rel=\"noopener\">Android手机的休眠状态</a></p>\n<p>推荐这两篇文章，都是在阐述Android手机有AP和BP两个处理器。事实上，MQTT也是从这思路去考虑，提供两种方式去实现心跳ping，分别是TimerTask和AlarmManager，具体实现类看继承关系：</p>\n<p><img src=\"http://i.imgur.com/RhuZtuK.png\" alt=\"\"></p>\n<p>深入查看MQTT的当前实现，是采用AlarmManager这种方法来实现心跳连接。这也是Android官方推荐的定时任务实现，有一篇文章做了这两种实现方式的相关测试 <a href=\"http://jellybins.github.io/2016/01/26/Android%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E8%AF%A6%E8%A7%A3/\" target=\"_blank\" rel=\"noopener\">Android定时任务详解</a>。</p>\n<h1 id=\"ping消息格式\"><a href=\"#ping消息格式\" class=\"headerlink\" title=\"ping消息格式\"></a>ping消息格式</h1><p>因为ping消息是我们自定义用作判断连接的消息，所以这个消息尽可能避免给正常收发消息带来不必要的消耗，而mqtt对ping消息的格式设计是怎样的呢？我们可以看下MqttPingReq.java这个类：</p>\n<p><img src=\"http://i.imgur.com/bCTNRAX.png\" alt=\"\"></p>\n<p>很简单，定义了MESSAGE_TYPE_PINGREQ的消息类型，同时注意到复写getVariableHeader方法返回一个0字节的数组，同时也没有复写父类的getPayload方法，这说明ping消息结构只是简单的包含头部信息，即只有两个字节，非常轻便。</p>\n<h1 id=\"flow-the-code\"><a href=\"#flow-the-code\" class=\"headerlink\" title=\"flow the code\"></a>flow the code</h1><h2 id=\"定义AlarmManager\"><a href=\"#定义AlarmManager\" class=\"headerlink\" title=\"定义AlarmManager\"></a>定义AlarmManager</h2><p>ok，我们开始看下具体实现代码。首先，我们上面说到，MQTT采用的是AlarmManager这种方式来实现ping，这个可以从MqttConnection类中connect方法中看到其初始化：</p>\n<p><img src=\"http://i.imgur.com/GsbTAF0.png\" alt=\"\"></p>\n<p>那么，它究竟什么时候开始ping呢？正常的想，应该是connect成功之后就可以开始，那就是收到connectAck之后。在介绍connect时说过，接收服务端发送过来的代码实现在CommsReceiver类中的线程中，追踪下代码，果不其然，在收到connectAck后进行解析：</p>\n<p><img src=\"http://i.imgur.com/2b2xsAU.png\" alt=\"\"></p>\n<p>这个connected()方法就是ping的逻辑。开始跟进去看看：</p>\n<p><img src=\"http://i.imgur.com/SEJQQOs.png\" alt=\"\"></p>\n<p>这里的pingSender就是AlarmPingSender的实例，跟进AlarmPingSender的start方法：</p>\n<p><img src=\"http://i.imgur.com/FFrpFgh.png\" alt=\"\"></p>\n<p>这里注册了一个alarmReceiver的广播，这个稍后解析；定义一个和alarmReceiver一样action的pendingIntent，在schedule方法中具体实现：</p>\n<p><img src=\"http://i.imgur.com/RRs2GTP.png\" alt=\"\"></p>\n<p>逻辑比较简单，定义了AlarmManager，并且在delayInMilliseconds（当前时间 + delayInMilliseconds）后去发送广播到alarmReceiver。那么，这个delayInMilliseconds即comms.getKeepAlive()是怎么传入的呢？这个可以在连接前定义MqttConnectOptions时进行设置：</p>\n<p><img src=\"http://i.imgur.com/Zl7j7R6.png\" alt=\"\"></p>\n<p>如果不设置，默认值是60s。</p>\n<h2 id=\"alarmReceiver\"><a href=\"#alarmReceiver\" class=\"headerlink\" title=\"alarmReceiver\"></a>alarmReceiver</h2><p>上面介绍说了，AlarmManager会在delayTime后发送广播，alarmReceiver的具体实现是AlarmReceiver类的onReceive方法中：</p>\n<p><img src=\"http://i.imgur.com/3Z772yr.png\" alt=\"\"></p>\n<p>这里面主要分三部分，第一部分是发送ping的关键代码逻辑，也包含判断当前网络是否ping失败和规划下次ping的时间；第二部分是获取PowerManager的wakelock（这个是针对ping返回callback处理的wakelock，尽管在设置alarmManager时已经有获取过wakelock），保持CPU运转；第三部分是在发送ping后等待收到服务端pingResponse释放wakelock以尽可能减少对手机电源的损耗。接下来介绍下第一部分。</p>\n<h2 id=\"ping\"><a href=\"#ping\" class=\"headerlink\" title=\"ping\"></a>ping</h2><p><img src=\"http://i.imgur.com/t5a4GoO.png\" alt=\"\"></p>\n<p>这里首先判断上一次ping是否失败，包括手机客户端和服务端的异常，这里说明一下，pingOutstanding是每次发送ping都会加1，收到pingResponse就减1；lastInboundActivity是代表上一次收到服务端消息的时间，相反地lastOutboundActivity则是上一次发送消息的时间；设置delta是因为代码使用System.currentTimeMillis()获取当前时间会有误差，所以尽可能加减delta值减少误差。</p>\n<p>两种异常注释已经解释得很清楚了。第一种异常是客户端发送ping消息后，在距离上一次接受到服务端发送回来的消息时间大于keepAlive + delta 认为是服务端没有reply客户端的ping消息异常；第二种异常则是认为客户端发送的ping没有在两个keepAlive时间发出，此时抛出写ping异常。接下来是对当前时间判断是否需要发送ping或者动态规划下一次接收广播时间：</p>\n<p><img src=\"http://i.imgur.com/Gi7djvl.png\" alt=\"\"></p>\n<p>首先判断此次keepAlive时间内客户端是否有发送或者接收信息，如果没有则发送ping消息，并把下次ping的时间设置成当初传入的keepAlive，这里的判断条件有两种情况，注释也说明得比较清晰；如果在此次keepAlive时间内客户端有收发信息（除ping消息外），则重新规划下次ping的时间，这里主要是以上一次客户端发送消息的时间为准，以设置全局的keepAlive和当前时间做一个差运算，time - lastOutboundActivity即离上一次客户端发送信息时间越长，则设置下次ping时间越短，这个也很好理解，如果当前客户端收发信息频繁，则没必要在短时间内自定义发送ping，此时应该认为断开连接的异常机会较小，应当减少自定义ping。这种动态规划ping时间很巧妙，尽可能保证可以检测出连接异常，同时也减少ping的频率和消耗。</p>\n<h2 id=\"释放WakeLock\"><a href=\"#释放WakeLock\" class=\"headerlink\" title=\"释放WakeLock\"></a>释放WakeLock</h2><p>在上述分析中，成功发送ping消息后，获取手机WakeLock并针对此次ping的返回释放WakeLock。过程和介绍connect流程基本一致，也是走CommsSender–&gt;CommsReceiver–&gt;CommsCallback这三个线程的run方法，具体的代码这里就不跟了。最终走到CommsCallback的handleActionComplete方法，执行fireActionEvent方法对ping保存的token进行回调。记住，无论成功与否，必须释放本次创建的WakeLock，避免不必要的消耗。</p>\n<p>至此，mqtt的ping流程已经介绍完毕。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>前面已经解析了MQTT的 <a href=\"https://hellokugo.github.io/2016/12/20/MQTT%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8Bconnect/\">connect连接源码</a> ，接下来介绍MQTT心跳实现机制。","more":"</p>\n<h1 id=\"实现原理\"><a href=\"#实现原理\" class=\"headerlink\" title=\"实现原理\"></a>实现原理</h1><p>我们知道，手机客户端对流量和电量的要求极为苛刻。如果要保持MQTT的长连接就无法避免上述两个条件的限制。网上有很多检测网络是否连接的方法，这里从MQTT源码出发，找到一些相关的资料：</p>\n<p><a href=\"http://www.cnblogs.com/kobe8/p/3819305.html\" target=\"_blank\" rel=\"noopener\">android设备休眠</a></p>\n<p><a href=\"http://blog.csdn.net/berber78/article/details/46696675\" target=\"_blank\" rel=\"noopener\">Android手机的休眠状态</a></p>\n<p>推荐这两篇文章，都是在阐述Android手机有AP和BP两个处理器。事实上，MQTT也是从这思路去考虑，提供两种方式去实现心跳ping，分别是TimerTask和AlarmManager，具体实现类看继承关系：</p>\n<p><img src=\"http://i.imgur.com/RhuZtuK.png\" alt=\"\"></p>\n<p>深入查看MQTT的当前实现，是采用AlarmManager这种方法来实现心跳连接。这也是Android官方推荐的定时任务实现，有一篇文章做了这两种实现方式的相关测试 <a href=\"http://jellybins.github.io/2016/01/26/Android%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E8%AF%A6%E8%A7%A3/\" target=\"_blank\" rel=\"noopener\">Android定时任务详解</a>。</p>\n<h1 id=\"ping消息格式\"><a href=\"#ping消息格式\" class=\"headerlink\" title=\"ping消息格式\"></a>ping消息格式</h1><p>因为ping消息是我们自定义用作判断连接的消息，所以这个消息尽可能避免给正常收发消息带来不必要的消耗，而mqtt对ping消息的格式设计是怎样的呢？我们可以看下MqttPingReq.java这个类：</p>\n<p><img src=\"http://i.imgur.com/bCTNRAX.png\" alt=\"\"></p>\n<p>很简单，定义了MESSAGE_TYPE_PINGREQ的消息类型，同时注意到复写getVariableHeader方法返回一个0字节的数组，同时也没有复写父类的getPayload方法，这说明ping消息结构只是简单的包含头部信息，即只有两个字节，非常轻便。</p>\n<h1 id=\"flow-the-code\"><a href=\"#flow-the-code\" class=\"headerlink\" title=\"flow the code\"></a>flow the code</h1><h2 id=\"定义AlarmManager\"><a href=\"#定义AlarmManager\" class=\"headerlink\" title=\"定义AlarmManager\"></a>定义AlarmManager</h2><p>ok，我们开始看下具体实现代码。首先，我们上面说到，MQTT采用的是AlarmManager这种方式来实现ping，这个可以从MqttConnection类中connect方法中看到其初始化：</p>\n<p><img src=\"http://i.imgur.com/GsbTAF0.png\" alt=\"\"></p>\n<p>那么，它究竟什么时候开始ping呢？正常的想，应该是connect成功之后就可以开始，那就是收到connectAck之后。在介绍connect时说过，接收服务端发送过来的代码实现在CommsReceiver类中的线程中，追踪下代码，果不其然，在收到connectAck后进行解析：</p>\n<p><img src=\"http://i.imgur.com/2b2xsAU.png\" alt=\"\"></p>\n<p>这个connected()方法就是ping的逻辑。开始跟进去看看：</p>\n<p><img src=\"http://i.imgur.com/SEJQQOs.png\" alt=\"\"></p>\n<p>这里的pingSender就是AlarmPingSender的实例，跟进AlarmPingSender的start方法：</p>\n<p><img src=\"http://i.imgur.com/FFrpFgh.png\" alt=\"\"></p>\n<p>这里注册了一个alarmReceiver的广播，这个稍后解析；定义一个和alarmReceiver一样action的pendingIntent，在schedule方法中具体实现：</p>\n<p><img src=\"http://i.imgur.com/RRs2GTP.png\" alt=\"\"></p>\n<p>逻辑比较简单，定义了AlarmManager，并且在delayInMilliseconds（当前时间 + delayInMilliseconds）后去发送广播到alarmReceiver。那么，这个delayInMilliseconds即comms.getKeepAlive()是怎么传入的呢？这个可以在连接前定义MqttConnectOptions时进行设置：</p>\n<p><img src=\"http://i.imgur.com/Zl7j7R6.png\" alt=\"\"></p>\n<p>如果不设置，默认值是60s。</p>\n<h2 id=\"alarmReceiver\"><a href=\"#alarmReceiver\" class=\"headerlink\" title=\"alarmReceiver\"></a>alarmReceiver</h2><p>上面介绍说了，AlarmManager会在delayTime后发送广播，alarmReceiver的具体实现是AlarmReceiver类的onReceive方法中：</p>\n<p><img src=\"http://i.imgur.com/3Z772yr.png\" alt=\"\"></p>\n<p>这里面主要分三部分，第一部分是发送ping的关键代码逻辑，也包含判断当前网络是否ping失败和规划下次ping的时间；第二部分是获取PowerManager的wakelock（这个是针对ping返回callback处理的wakelock，尽管在设置alarmManager时已经有获取过wakelock），保持CPU运转；第三部分是在发送ping后等待收到服务端pingResponse释放wakelock以尽可能减少对手机电源的损耗。接下来介绍下第一部分。</p>\n<h2 id=\"ping\"><a href=\"#ping\" class=\"headerlink\" title=\"ping\"></a>ping</h2><p><img src=\"http://i.imgur.com/t5a4GoO.png\" alt=\"\"></p>\n<p>这里首先判断上一次ping是否失败，包括手机客户端和服务端的异常，这里说明一下，pingOutstanding是每次发送ping都会加1，收到pingResponse就减1；lastInboundActivity是代表上一次收到服务端消息的时间，相反地lastOutboundActivity则是上一次发送消息的时间；设置delta是因为代码使用System.currentTimeMillis()获取当前时间会有误差，所以尽可能加减delta值减少误差。</p>\n<p>两种异常注释已经解释得很清楚了。第一种异常是客户端发送ping消息后，在距离上一次接受到服务端发送回来的消息时间大于keepAlive + delta 认为是服务端没有reply客户端的ping消息异常；第二种异常则是认为客户端发送的ping没有在两个keepAlive时间发出，此时抛出写ping异常。接下来是对当前时间判断是否需要发送ping或者动态规划下一次接收广播时间：</p>\n<p><img src=\"http://i.imgur.com/Gi7djvl.png\" alt=\"\"></p>\n<p>首先判断此次keepAlive时间内客户端是否有发送或者接收信息，如果没有则发送ping消息，并把下次ping的时间设置成当初传入的keepAlive，这里的判断条件有两种情况，注释也说明得比较清晰；如果在此次keepAlive时间内客户端有收发信息（除ping消息外），则重新规划下次ping的时间，这里主要是以上一次客户端发送消息的时间为准，以设置全局的keepAlive和当前时间做一个差运算，time - lastOutboundActivity即离上一次客户端发送信息时间越长，则设置下次ping时间越短，这个也很好理解，如果当前客户端收发信息频繁，则没必要在短时间内自定义发送ping，此时应该认为断开连接的异常机会较小，应当减少自定义ping。这种动态规划ping时间很巧妙，尽可能保证可以检测出连接异常，同时也减少ping的频率和消耗。</p>\n<h2 id=\"释放WakeLock\"><a href=\"#释放WakeLock\" class=\"headerlink\" title=\"释放WakeLock\"></a>释放WakeLock</h2><p>在上述分析中，成功发送ping消息后，获取手机WakeLock并针对此次ping的返回释放WakeLock。过程和介绍connect流程基本一致，也是走CommsSender–&gt;CommsReceiver–&gt;CommsCallback这三个线程的run方法，具体的代码这里就不跟了。最终走到CommsCallback的handleActionComplete方法，执行fireActionEvent方法对ping保存的token进行回调。记住，无论成功与否，必须释放本次创建的WakeLock，避免不必要的消耗。</p>\n<p>至此，mqtt的ping流程已经介绍完毕。</p>"},{"title":"Resource.arsc文件格式","date":"2018-01-28T15:39:34.391Z","_content":"\n# 前言 #\n在研究资源混淆的过程中了解到微信的资源混淆工具--[AndResGuard](https://github.com/shwenzhang/AndResGuard)，这个工具的强大之处不仅仅在于混淆了冗余的资源文件名称和明显减少apk的大小（这是官方说明，小弟小试了下效果不明显，有待考证），同时不涉及生成apk的编译流程，只需要输入apk和一些命令参数即可生成所需的混淆资源后的apk。<!-- more -->（美团也有一套混淆资源的方法，介绍是修改AAPT处理资源文件相关的源码，牛逼哄哄的样子：[没错，我是链接](http://tech.meituan.com/mt-android-resource-obfuscation.html)）。Anyway，对于追求完美的技术人员而言，并不能满足于一个现成的工具，了解其中原理加以修改才可以灵活运用。AndResGuard主要是通过修改resources.arsc文件来打到混淆的目的，因此，本文主要是对resources.arsc的文件格式进行阐述。\n至于详细的实现方案和流程可参考[AndResGuard原理](http://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&mid=208135658&idx=1&sn=ac9bd6b4927e9e82f9fa14e396183a8f#rd)\n\n# 数据结构总体介绍 #\n\nresources.arsc文件格式是由一系列的chunk构成。总体而言，可以大致分为五个chunk，分别是TYPETABLE，TYPEPACKAGE，TYPE_STRING， TYPETYPE和TYPESPEC；而这些chunk组成的结构就是资源索引表头部+字符串资源池+N个Package数据块。贴上一张传烂的图：\n\n![](http://i.imgur.com/UVU3hWW.png)\n\n是的，看完这图我也是懵逼的。没关系，下面作一个详细点的介绍。\n\n# 头部信息 #\n\n在介绍每个chunk之前，先说明下每个chunk均包含一个ResChunk_header的头部信息，具体的数据定义如下：\n\n\tstruct ResChunk_header\n\t{\n    // 是当前这个chunk的类型\n    uint16_t type;\n\n    // 是当前这个chunk的头部大小\n    uint16_t headerSize;\n\n    // 是当前这个chunk的大小\n    uint32_t size;\n\t};\n\n从上面的结构图可以看到，每一个chunk均是以ResChunk_header作为开头，在下面的介绍中，将会跳过。\n\n# 资源索引表头部（TYPETABLE） #\n\n![](http://i.imgur.com/K76gXh0.png)\n\n可以看到，除了头部信息，还有一个package数的数据，一个apk可能包含多个资源包，这里就是指被编译的资源包个数。具体体现在有多少个TYPEPACKAGE。\n\n# 字符串资源池（TYPE_STRING） #\n\n![](http://i.imgur.com/zWKmKf3.png)\n\n紧接着资源索引表头部的就是字符串资源池，这个chunk包含了所有package里定义的字符串。这个chunk的数据结构比较重要，在后面的TYPEPACKAGE里也包含着这一种chunk的数据结构，同时也是AndResGuard其中做修改数据的位置。下面简略地看下其数据结构介绍：\n\n### ResStringPool_header ###\nheader：标准的Chunk头部信息结构</br>\nstringCount：字符串的个数</br>\nstyleCount：字符串样式的个数</br>\nflags：字符串的属性,可取值包括0x000(UTF-16),0x001(字符串经过排序)、0X100(UTF-8)和他们的组合值</br>\nstringStart：字符串内容块相对于其头部的距离</br>\nstylesStart：字符串样式块相对于其头部的距离\n\n### 两个Array和两个Content ###\n紧接着ResStringPool_header就是字符串偏移数组和字符串样式偏移数组，字符串偏移数组每个元素记录着每个字符串相对于StringContent（图中数据‘字符串’）开始的索引；同样的，字符串样式偏移数组每个元素记录着每个字符串相对于StyleContent（图中数据‘style’）开始的索引。\n\n整个字符串资源区的结构示意图：\n\n![](http://i.imgur.com/pV5kgSm.png)\n\n\n# Package数据块（TYPEPACKAGE） #\n\n在资源索引表头部中指定了package数目，所以，在这里开始，package数据块（包含TYPETYPE和TYPESPEC）是一个紧接着一个（假如有多个package）。</br>\n下面，先介绍下TYPEPACKAGE这个chunk的数据结构：\n\n![](http://i.imgur.com/p0g4EWp.png)\n\n### ResTable_package ###\nheader：Chunk的头部信息数据结构</br>\nid：包的ID,等于Package Id,一般用户包的值Package Id为0X7F,系统资源包的Package Id为0X01</br>\nname：包名</br>\ntypeString：类型字符串资源池相对头部的偏移</br>\nlastPublicType：最后一个导出的Public类型字符串在类型字符串资源池中的索引，目前这个值设置为类型字符串资源池的元素个数。在解析的过程中没发现他的用途</br>\nkeyStrings：资源项名称字符串相对头部的偏移</br>\nlastPublicKey：最后一个导出的Public资源项名称字符串在资源项名称字符串资源池中的索引，目前这个值设置为资源项名称字符串资源池的元素个数。在解析的过程中没发现他的用途\n\n### Type String Pool & Key String Pool ###\n紧接着ResTable_package的是两个与字符串资源池有相同结构的字符串资源池，区别在于这里的资源池只是包含当前package的资源。\n\nType String Pool（图中数据‘资源类型字符串池’）是一个package中用到的类型字符串，如：anim，id，layout；\n\nKey String Pool（图中数据‘资源项名称字符串池’），比如string.xml内容如下：\n\n\t<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\t<resources>\n    <string name=\"app_name\">Test</string>\n    <string name=\"hello_world\">Hello world!</string>\n    <string name=\"action_settings\">Settings</string>\n\t</resources>\n\n那么这个pool就收集了app_name，hello_world   action_settings 这3个字符串。这个pool是AndResGuard作修改的一处位置。\n\n整个Package数据块区的结构示意图：\n\n![](http://i.imgur.com/Mhj3UOF.png)\n\n可以看到，在紧接着Type String Pool和Key String Pool后是剩下的两个chunk，在这里Type Specification Trunk和Type Info Trunk分别对应 TYPESPEC和TYPETYPE，下面作详细介绍。\n\n# 类型规范数据块（TYPESPEC） & 资源类型项数据块（TYPETYPE）#\n\n先来看一段TYPESPEC的介绍：\n\n\t类型规范数据块用来描述资源项的配置差异性。通过这个差异性描述，我们就可以知道每一个资源项的配置状况。知道了一个资源项的配置状况之后，Android资源管理框架在检测到设备的配置信息发生变化之后，就可以知道是否需要重新加载该资源项。类型规范数据块是按照类型来组织的，也就是说，每一种类型都对应有一个类型规范数据块。\n\n![](http://i.imgur.com/ERotuBl.png)\n\n国际惯例，大概了解下其数据结构：\n\n\theader：Chunk的头部信息结构\n\tid：标识资源的Type ID,Type ID是指资源的类型ID。资源的类型有animator、anim、color、drawable、layout、menu、raw、string和xml等等若干种，每一种都会被赋予一个ID。\n\tres0：保留,始终为0\n\tres1：保留,始终为0\n\tentryCount：等于本类型的资源项个数,指名称相同的资源项的个数。\n\n再来一段TYPETYPE的介绍：\n\n\t类型资源项数据块用来描述资源项的具体信息, 这样我们就可以知道每一个资源项的名称、值和配置等信息。 类型资源项数据同样是按照类型和配置来组织的,也就是说,一个具有n个配置的类型一共对应有n个类型资源项数据块。\n\n![](http://i.imgur.com/VBljfg6.png)\n\nTYPETYPE的数据结构：\n\n\theader：Chunk的头部信息结构\n\tid：标识资源的Type ID\n\tres0：保留,始终为0\n\tres1：保留,始终为0\n\tentryCount：等于本类型的资源项个数,指名称相同的资源项的个数。\n\tentriesStart：等于资源项数据块相对头部的偏移值。\n\tresConfig：指向一个ResTable_config,用来描述配置信息,地区,语言,分辨率等\n\n注意下的是，这里两个chunk的id均是标识资源的id，这里是指类似drawable和anim等类型，其他字段在这里不做介绍，结合AndResGuard重点介绍的是紧跟TYPETYPE后的ResTable_entry数组，这个数组是指具体每个元素的配置解释，而这里也是AndResGuard需要做修改的其中两个地方。\n\n说实话，看到两段描述的时候有点混乱，查阅资料和说明例子后以为理解了，结合AndResGuard源码尝试去理解更换两个chunk数据，又陷入了无限的懵逼状态。归根结底，是不能理解类型和配置是如何进行映射。毛爷爷说过，实践是检验真理的唯一标准，于是乎，小弟写了个简单的helloworld的demo，主要截上资源配置：\n\n![](http://i.imgur.com/4AZ99ZF.png)\n\n这里要留意两点，一是类型drawable有三种配置，分别是drawable-hdpi，drawable-mdpi和drawable-xhdpi，这三个配置里均有ic_launcher.png；第二点是，在drawable-mdpi文件下有test.png。\n\n然后就开始解析里面的resources.arsc，主要结果截图如下：\n\n图一：\n\n![](http://i.imgur.com/qNT1t9t.png)\n\n图二：\n\n![](http://i.imgur.com/0TKtzCp.png)\n\n关注图一，主要是说明两个TYPESPEC，以parse restype spec chunk...开始解析，第一块的type_name:attr，没有元素，所以\nentryCount=0；第二块的type_name:drawable，留意下entryCount=2，有两个元素，所以对应有两个TYPETYPE，这里是以parse restype info chunk...开始解析，这个也很好理解，因为demo是有两张图片，分别是ic_launcher和test，对应的是drawable-mdpi文件下的文件描述；</br>\n\n这时候关注下图二，这个是另外两个TYPETYPE chunk的截图，自然而然想到的是另外两个drawable的文件资源描述，图中每个圈是每一个entry，entry中的index是对应package chunk中资源项名称字符串池的字符串偏移值，解析出来的字符串时str:ic_launcher，value中的data其实是在 字符串资源池（TYPE_STRING）解析出来的数据，在内部也是通过一个偏移值去获取该值；图二还有一个细节，也是困扰小弟几天的问题，就是即使在drawable-mdpi文件下没有test.png，在其数据结构的trunk中的entryCount=2，而在具体的entry中datatype=TYPR_NULL,这就很好地理解了AndResGuard中替换资源名字的方法，保持每个resId的唯一性，同时也可以针对具体的配置进行文件名替换。</br>\n\n至此，最后的两个chunk也介绍完毕。归结而言，就是每个资源类型对应一个TYPESPEC，而紧跟每一种类型的就是其类型所包含的配置，每个配置就是对应一个TYPETYPE。\n\n\n# 关注AndResGuard #\n\n大概了解了resources.arsc结构，去了解AndResGuard混淆资源的方案就应该更为清晰了，简单看下替换方案：\n\n![](http://i.imgur.com/Z6EDzF0.png)\n\n首先，我们其实修改的是资源文件名(a.png)和资源文件的路径名（r\\a\\a.png），这样对应修改的就是TYPEPACKAGE和TYPE_STRING（对应方案1和3），而最后我们介绍的TYPETYPE和TYPESPEC是分别有TYPEPACKAGE和TYPE_STRING的字符串偏移值，这样对应也需要做修改（对应方案4），当然，缩短了文件命名必然会对整个table的大小造成改变，所以要重新计算并写入新的resources.arsc（对应方案5），结合源码分析，可能会有更深的理解。</br>\n\n由于本人没有对resources.arsc做整体的透彻理解，只是在AndResGuard项目基础上去选择性关注要修改的点，如果在分析过程中有出现纰漏或者错误的地方，希望指出。\n\n参考资料：\n[http://blog.csdn.net/jiangwei0910410003/article/details/50628894](http://blog.csdn.net/jiangwei0910410003/article/details/50628894)\n[http://www.cnblogs.com/njxxdx/p/4189971.html](http://www.cnblogs.com/njxxdx/p/4189971.html)\n\n\n\n","source":"_posts/Resource.arsc文件格式.md","raw":"title: Resource.arsc文件格式\ndate: 2016/6/14 17：53\n\ncategories:\n- Mobile\ntags:\n- android\n---\n\n# 前言 #\n在研究资源混淆的过程中了解到微信的资源混淆工具--[AndResGuard](https://github.com/shwenzhang/AndResGuard)，这个工具的强大之处不仅仅在于混淆了冗余的资源文件名称和明显减少apk的大小（这是官方说明，小弟小试了下效果不明显，有待考证），同时不涉及生成apk的编译流程，只需要输入apk和一些命令参数即可生成所需的混淆资源后的apk。<!-- more -->（美团也有一套混淆资源的方法，介绍是修改AAPT处理资源文件相关的源码，牛逼哄哄的样子：[没错，我是链接](http://tech.meituan.com/mt-android-resource-obfuscation.html)）。Anyway，对于追求完美的技术人员而言，并不能满足于一个现成的工具，了解其中原理加以修改才可以灵活运用。AndResGuard主要是通过修改resources.arsc文件来打到混淆的目的，因此，本文主要是对resources.arsc的文件格式进行阐述。\n至于详细的实现方案和流程可参考[AndResGuard原理](http://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&mid=208135658&idx=1&sn=ac9bd6b4927e9e82f9fa14e396183a8f#rd)\n\n# 数据结构总体介绍 #\n\nresources.arsc文件格式是由一系列的chunk构成。总体而言，可以大致分为五个chunk，分别是TYPETABLE，TYPEPACKAGE，TYPE_STRING， TYPETYPE和TYPESPEC；而这些chunk组成的结构就是资源索引表头部+字符串资源池+N个Package数据块。贴上一张传烂的图：\n\n![](http://i.imgur.com/UVU3hWW.png)\n\n是的，看完这图我也是懵逼的。没关系，下面作一个详细点的介绍。\n\n# 头部信息 #\n\n在介绍每个chunk之前，先说明下每个chunk均包含一个ResChunk_header的头部信息，具体的数据定义如下：\n\n\tstruct ResChunk_header\n\t{\n    // 是当前这个chunk的类型\n    uint16_t type;\n\n    // 是当前这个chunk的头部大小\n    uint16_t headerSize;\n\n    // 是当前这个chunk的大小\n    uint32_t size;\n\t};\n\n从上面的结构图可以看到，每一个chunk均是以ResChunk_header作为开头，在下面的介绍中，将会跳过。\n\n# 资源索引表头部（TYPETABLE） #\n\n![](http://i.imgur.com/K76gXh0.png)\n\n可以看到，除了头部信息，还有一个package数的数据，一个apk可能包含多个资源包，这里就是指被编译的资源包个数。具体体现在有多少个TYPEPACKAGE。\n\n# 字符串资源池（TYPE_STRING） #\n\n![](http://i.imgur.com/zWKmKf3.png)\n\n紧接着资源索引表头部的就是字符串资源池，这个chunk包含了所有package里定义的字符串。这个chunk的数据结构比较重要，在后面的TYPEPACKAGE里也包含着这一种chunk的数据结构，同时也是AndResGuard其中做修改数据的位置。下面简略地看下其数据结构介绍：\n\n### ResStringPool_header ###\nheader：标准的Chunk头部信息结构</br>\nstringCount：字符串的个数</br>\nstyleCount：字符串样式的个数</br>\nflags：字符串的属性,可取值包括0x000(UTF-16),0x001(字符串经过排序)、0X100(UTF-8)和他们的组合值</br>\nstringStart：字符串内容块相对于其头部的距离</br>\nstylesStart：字符串样式块相对于其头部的距离\n\n### 两个Array和两个Content ###\n紧接着ResStringPool_header就是字符串偏移数组和字符串样式偏移数组，字符串偏移数组每个元素记录着每个字符串相对于StringContent（图中数据‘字符串’）开始的索引；同样的，字符串样式偏移数组每个元素记录着每个字符串相对于StyleContent（图中数据‘style’）开始的索引。\n\n整个字符串资源区的结构示意图：\n\n![](http://i.imgur.com/pV5kgSm.png)\n\n\n# Package数据块（TYPEPACKAGE） #\n\n在资源索引表头部中指定了package数目，所以，在这里开始，package数据块（包含TYPETYPE和TYPESPEC）是一个紧接着一个（假如有多个package）。</br>\n下面，先介绍下TYPEPACKAGE这个chunk的数据结构：\n\n![](http://i.imgur.com/p0g4EWp.png)\n\n### ResTable_package ###\nheader：Chunk的头部信息数据结构</br>\nid：包的ID,等于Package Id,一般用户包的值Package Id为0X7F,系统资源包的Package Id为0X01</br>\nname：包名</br>\ntypeString：类型字符串资源池相对头部的偏移</br>\nlastPublicType：最后一个导出的Public类型字符串在类型字符串资源池中的索引，目前这个值设置为类型字符串资源池的元素个数。在解析的过程中没发现他的用途</br>\nkeyStrings：资源项名称字符串相对头部的偏移</br>\nlastPublicKey：最后一个导出的Public资源项名称字符串在资源项名称字符串资源池中的索引，目前这个值设置为资源项名称字符串资源池的元素个数。在解析的过程中没发现他的用途\n\n### Type String Pool & Key String Pool ###\n紧接着ResTable_package的是两个与字符串资源池有相同结构的字符串资源池，区别在于这里的资源池只是包含当前package的资源。\n\nType String Pool（图中数据‘资源类型字符串池’）是一个package中用到的类型字符串，如：anim，id，layout；\n\nKey String Pool（图中数据‘资源项名称字符串池’），比如string.xml内容如下：\n\n\t<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\t<resources>\n    <string name=\"app_name\">Test</string>\n    <string name=\"hello_world\">Hello world!</string>\n    <string name=\"action_settings\">Settings</string>\n\t</resources>\n\n那么这个pool就收集了app_name，hello_world   action_settings 这3个字符串。这个pool是AndResGuard作修改的一处位置。\n\n整个Package数据块区的结构示意图：\n\n![](http://i.imgur.com/Mhj3UOF.png)\n\n可以看到，在紧接着Type String Pool和Key String Pool后是剩下的两个chunk，在这里Type Specification Trunk和Type Info Trunk分别对应 TYPESPEC和TYPETYPE，下面作详细介绍。\n\n# 类型规范数据块（TYPESPEC） & 资源类型项数据块（TYPETYPE）#\n\n先来看一段TYPESPEC的介绍：\n\n\t类型规范数据块用来描述资源项的配置差异性。通过这个差异性描述，我们就可以知道每一个资源项的配置状况。知道了一个资源项的配置状况之后，Android资源管理框架在检测到设备的配置信息发生变化之后，就可以知道是否需要重新加载该资源项。类型规范数据块是按照类型来组织的，也就是说，每一种类型都对应有一个类型规范数据块。\n\n![](http://i.imgur.com/ERotuBl.png)\n\n国际惯例，大概了解下其数据结构：\n\n\theader：Chunk的头部信息结构\n\tid：标识资源的Type ID,Type ID是指资源的类型ID。资源的类型有animator、anim、color、drawable、layout、menu、raw、string和xml等等若干种，每一种都会被赋予一个ID。\n\tres0：保留,始终为0\n\tres1：保留,始终为0\n\tentryCount：等于本类型的资源项个数,指名称相同的资源项的个数。\n\n再来一段TYPETYPE的介绍：\n\n\t类型资源项数据块用来描述资源项的具体信息, 这样我们就可以知道每一个资源项的名称、值和配置等信息。 类型资源项数据同样是按照类型和配置来组织的,也就是说,一个具有n个配置的类型一共对应有n个类型资源项数据块。\n\n![](http://i.imgur.com/VBljfg6.png)\n\nTYPETYPE的数据结构：\n\n\theader：Chunk的头部信息结构\n\tid：标识资源的Type ID\n\tres0：保留,始终为0\n\tres1：保留,始终为0\n\tentryCount：等于本类型的资源项个数,指名称相同的资源项的个数。\n\tentriesStart：等于资源项数据块相对头部的偏移值。\n\tresConfig：指向一个ResTable_config,用来描述配置信息,地区,语言,分辨率等\n\n注意下的是，这里两个chunk的id均是标识资源的id，这里是指类似drawable和anim等类型，其他字段在这里不做介绍，结合AndResGuard重点介绍的是紧跟TYPETYPE后的ResTable_entry数组，这个数组是指具体每个元素的配置解释，而这里也是AndResGuard需要做修改的其中两个地方。\n\n说实话，看到两段描述的时候有点混乱，查阅资料和说明例子后以为理解了，结合AndResGuard源码尝试去理解更换两个chunk数据，又陷入了无限的懵逼状态。归根结底，是不能理解类型和配置是如何进行映射。毛爷爷说过，实践是检验真理的唯一标准，于是乎，小弟写了个简单的helloworld的demo，主要截上资源配置：\n\n![](http://i.imgur.com/4AZ99ZF.png)\n\n这里要留意两点，一是类型drawable有三种配置，分别是drawable-hdpi，drawable-mdpi和drawable-xhdpi，这三个配置里均有ic_launcher.png；第二点是，在drawable-mdpi文件下有test.png。\n\n然后就开始解析里面的resources.arsc，主要结果截图如下：\n\n图一：\n\n![](http://i.imgur.com/qNT1t9t.png)\n\n图二：\n\n![](http://i.imgur.com/0TKtzCp.png)\n\n关注图一，主要是说明两个TYPESPEC，以parse restype spec chunk...开始解析，第一块的type_name:attr，没有元素，所以\nentryCount=0；第二块的type_name:drawable，留意下entryCount=2，有两个元素，所以对应有两个TYPETYPE，这里是以parse restype info chunk...开始解析，这个也很好理解，因为demo是有两张图片，分别是ic_launcher和test，对应的是drawable-mdpi文件下的文件描述；</br>\n\n这时候关注下图二，这个是另外两个TYPETYPE chunk的截图，自然而然想到的是另外两个drawable的文件资源描述，图中每个圈是每一个entry，entry中的index是对应package chunk中资源项名称字符串池的字符串偏移值，解析出来的字符串时str:ic_launcher，value中的data其实是在 字符串资源池（TYPE_STRING）解析出来的数据，在内部也是通过一个偏移值去获取该值；图二还有一个细节，也是困扰小弟几天的问题，就是即使在drawable-mdpi文件下没有test.png，在其数据结构的trunk中的entryCount=2，而在具体的entry中datatype=TYPR_NULL,这就很好地理解了AndResGuard中替换资源名字的方法，保持每个resId的唯一性，同时也可以针对具体的配置进行文件名替换。</br>\n\n至此，最后的两个chunk也介绍完毕。归结而言，就是每个资源类型对应一个TYPESPEC，而紧跟每一种类型的就是其类型所包含的配置，每个配置就是对应一个TYPETYPE。\n\n\n# 关注AndResGuard #\n\n大概了解了resources.arsc结构，去了解AndResGuard混淆资源的方案就应该更为清晰了，简单看下替换方案：\n\n![](http://i.imgur.com/Z6EDzF0.png)\n\n首先，我们其实修改的是资源文件名(a.png)和资源文件的路径名（r\\a\\a.png），这样对应修改的就是TYPEPACKAGE和TYPE_STRING（对应方案1和3），而最后我们介绍的TYPETYPE和TYPESPEC是分别有TYPEPACKAGE和TYPE_STRING的字符串偏移值，这样对应也需要做修改（对应方案4），当然，缩短了文件命名必然会对整个table的大小造成改变，所以要重新计算并写入新的resources.arsc（对应方案5），结合源码分析，可能会有更深的理解。</br>\n\n由于本人没有对resources.arsc做整体的透彻理解，只是在AndResGuard项目基础上去选择性关注要修改的点，如果在分析过程中有出现纰漏或者错误的地方，希望指出。\n\n参考资料：\n[http://blog.csdn.net/jiangwei0910410003/article/details/50628894](http://blog.csdn.net/jiangwei0910410003/article/details/50628894)\n[http://www.cnblogs.com/njxxdx/p/4189971.html](http://www.cnblogs.com/njxxdx/p/4189971.html)\n\n\n\n","slug":"Resource.arsc文件格式","published":1,"updated":"2018-01-28T15:39:34.391Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjcyyg7k5000dnius6vpzyzbp","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>在研究资源混淆的过程中了解到微信的资源混淆工具–<a href=\"https://github.com/shwenzhang/AndResGuard\" target=\"_blank\" rel=\"noopener\">AndResGuard</a>，这个工具的强大之处不仅仅在于混淆了冗余的资源文件名称和明显减少apk的大小（这是官方说明，小弟小试了下效果不明显，有待考证），同时不涉及生成apk的编译流程，只需要输入apk和一些命令参数即可生成所需的混淆资源后的apk。<a id=\"more\"></a>（美团也有一套混淆资源的方法，介绍是修改AAPT处理资源文件相关的源码，牛逼哄哄的样子：<a href=\"http://tech.meituan.com/mt-android-resource-obfuscation.html\" target=\"_blank\" rel=\"noopener\">没错，我是链接</a>）。Anyway，对于追求完美的技术人员而言，并不能满足于一个现成的工具，了解其中原理加以修改才可以灵活运用。AndResGuard主要是通过修改resources.arsc文件来打到混淆的目的，因此，本文主要是对resources.arsc的文件格式进行阐述。<br>至于详细的实现方案和流程可参考<a href=\"http://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=208135658&amp;idx=1&amp;sn=ac9bd6b4927e9e82f9fa14e396183a8f#rd\" target=\"_blank\" rel=\"noopener\">AndResGuard原理</a></p>\n<h1 id=\"数据结构总体介绍\"><a href=\"#数据结构总体介绍\" class=\"headerlink\" title=\"数据结构总体介绍\"></a>数据结构总体介绍</h1><p>resources.arsc文件格式是由一系列的chunk构成。总体而言，可以大致分为五个chunk，分别是TYPETABLE，TYPEPACKAGE，TYPE_STRING， TYPETYPE和TYPESPEC；而这些chunk组成的结构就是资源索引表头部+字符串资源池+N个Package数据块。贴上一张传烂的图：</p>\n<p><img src=\"http://i.imgur.com/UVU3hWW.png\" alt=\"\"></p>\n<p>是的，看完这图我也是懵逼的。没关系，下面作一个详细点的介绍。</p>\n<h1 id=\"头部信息\"><a href=\"#头部信息\" class=\"headerlink\" title=\"头部信息\"></a>头部信息</h1><p>在介绍每个chunk之前，先说明下每个chunk均包含一个ResChunk_header的头部信息，具体的数据定义如下：</p>\n<pre><code>struct ResChunk_header\n{\n// 是当前这个chunk的类型\nuint16_t type;\n\n// 是当前这个chunk的头部大小\nuint16_t headerSize;\n\n// 是当前这个chunk的大小\nuint32_t size;\n};\n</code></pre><p>从上面的结构图可以看到，每一个chunk均是以ResChunk_header作为开头，在下面的介绍中，将会跳过。</p>\n<h1 id=\"资源索引表头部（TYPETABLE）\"><a href=\"#资源索引表头部（TYPETABLE）\" class=\"headerlink\" title=\"资源索引表头部（TYPETABLE）\"></a>资源索引表头部（TYPETABLE）</h1><p><img src=\"http://i.imgur.com/K76gXh0.png\" alt=\"\"></p>\n<p>可以看到，除了头部信息，还有一个package数的数据，一个apk可能包含多个资源包，这里就是指被编译的资源包个数。具体体现在有多少个TYPEPACKAGE。</p>\n<h1 id=\"字符串资源池（TYPE-STRING）\"><a href=\"#字符串资源池（TYPE-STRING）\" class=\"headerlink\" title=\"字符串资源池（TYPE_STRING）\"></a>字符串资源池（TYPE_STRING）</h1><p><img src=\"http://i.imgur.com/zWKmKf3.png\" alt=\"\"></p>\n<p>紧接着资源索引表头部的就是字符串资源池，这个chunk包含了所有package里定义的字符串。这个chunk的数据结构比较重要，在后面的TYPEPACKAGE里也包含着这一种chunk的数据结构，同时也是AndResGuard其中做修改数据的位置。下面简略地看下其数据结构介绍：</p>\n<h3 id=\"ResStringPool-header\"><a href=\"#ResStringPool-header\" class=\"headerlink\" title=\"ResStringPool_header\"></a>ResStringPool_header</h3><p>header：标准的Chunk头部信息结构<br><br>stringCount：字符串的个数<br><br>styleCount：字符串样式的个数<br><br>flags：字符串的属性,可取值包括0x000(UTF-16),0x001(字符串经过排序)、0X100(UTF-8)和他们的组合值<br><br>stringStart：字符串内容块相对于其头部的距离<br><br>stylesStart：字符串样式块相对于其头部的距离</p>\n<h3 id=\"两个Array和两个Content\"><a href=\"#两个Array和两个Content\" class=\"headerlink\" title=\"两个Array和两个Content\"></a>两个Array和两个Content</h3><p>紧接着ResStringPool_header就是字符串偏移数组和字符串样式偏移数组，字符串偏移数组每个元素记录着每个字符串相对于StringContent（图中数据‘字符串’）开始的索引；同样的，字符串样式偏移数组每个元素记录着每个字符串相对于StyleContent（图中数据‘style’）开始的索引。</p>\n<p>整个字符串资源区的结构示意图：</p>\n<p><img src=\"http://i.imgur.com/pV5kgSm.png\" alt=\"\"></p>\n<h1 id=\"Package数据块（TYPEPACKAGE）\"><a href=\"#Package数据块（TYPEPACKAGE）\" class=\"headerlink\" title=\"Package数据块（TYPEPACKAGE）\"></a>Package数据块（TYPEPACKAGE）</h1><p>在资源索引表头部中指定了package数目，所以，在这里开始，package数据块（包含TYPETYPE和TYPESPEC）是一个紧接着一个（假如有多个package）。<br><br>下面，先介绍下TYPEPACKAGE这个chunk的数据结构：</p>\n<p><img src=\"http://i.imgur.com/p0g4EWp.png\" alt=\"\"></p>\n<h3 id=\"ResTable-package\"><a href=\"#ResTable-package\" class=\"headerlink\" title=\"ResTable_package\"></a>ResTable_package</h3><p>header：Chunk的头部信息数据结构<br><br>id：包的ID,等于Package Id,一般用户包的值Package Id为0X7F,系统资源包的Package Id为0X01<br><br>name：包名<br><br>typeString：类型字符串资源池相对头部的偏移<br><br>lastPublicType：最后一个导出的Public类型字符串在类型字符串资源池中的索引，目前这个值设置为类型字符串资源池的元素个数。在解析的过程中没发现他的用途<br><br>keyStrings：资源项名称字符串相对头部的偏移<br><br>lastPublicKey：最后一个导出的Public资源项名称字符串在资源项名称字符串资源池中的索引，目前这个值设置为资源项名称字符串资源池的元素个数。在解析的过程中没发现他的用途</p>\n<h3 id=\"Type-String-Pool-amp-Key-String-Pool\"><a href=\"#Type-String-Pool-amp-Key-String-Pool\" class=\"headerlink\" title=\"Type String Pool &amp; Key String Pool\"></a>Type String Pool &amp; Key String Pool</h3><p>紧接着ResTable_package的是两个与字符串资源池有相同结构的字符串资源池，区别在于这里的资源池只是包含当前package的资源。</p>\n<p>Type String Pool（图中数据‘资源类型字符串池’）是一个package中用到的类型字符串，如：anim，id，layout；</p>\n<p>Key String Pool（图中数据‘资源项名称字符串池’），比如string.xml内容如下：</p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;resources&gt;\n&lt;string name=&quot;app_name&quot;&gt;Test&lt;/string&gt;\n&lt;string name=&quot;hello_world&quot;&gt;Hello world!&lt;/string&gt;\n&lt;string name=&quot;action_settings&quot;&gt;Settings&lt;/string&gt;\n&lt;/resources&gt;\n</code></pre><p>那么这个pool就收集了app_name，hello_world   action_settings 这3个字符串。这个pool是AndResGuard作修改的一处位置。</p>\n<p>整个Package数据块区的结构示意图：</p>\n<p><img src=\"http://i.imgur.com/Mhj3UOF.png\" alt=\"\"></p>\n<p>可以看到，在紧接着Type String Pool和Key String Pool后是剩下的两个chunk，在这里Type Specification Trunk和Type Info Trunk分别对应 TYPESPEC和TYPETYPE，下面作详细介绍。</p>\n<h1 id=\"类型规范数据块（TYPESPEC）-amp-资源类型项数据块（TYPETYPE）\"><a href=\"#类型规范数据块（TYPESPEC）-amp-资源类型项数据块（TYPETYPE）\" class=\"headerlink\" title=\"类型规范数据块（TYPESPEC） &amp; 资源类型项数据块（TYPETYPE）\"></a>类型规范数据块（TYPESPEC） &amp; 资源类型项数据块（TYPETYPE）</h1><p>先来看一段TYPESPEC的介绍：</p>\n<pre><code>类型规范数据块用来描述资源项的配置差异性。通过这个差异性描述，我们就可以知道每一个资源项的配置状况。知道了一个资源项的配置状况之后，Android资源管理框架在检测到设备的配置信息发生变化之后，就可以知道是否需要重新加载该资源项。类型规范数据块是按照类型来组织的，也就是说，每一种类型都对应有一个类型规范数据块。\n</code></pre><p><img src=\"http://i.imgur.com/ERotuBl.png\" alt=\"\"></p>\n<p>国际惯例，大概了解下其数据结构：</p>\n<pre><code>header：Chunk的头部信息结构\nid：标识资源的Type ID,Type ID是指资源的类型ID。资源的类型有animator、anim、color、drawable、layout、menu、raw、string和xml等等若干种，每一种都会被赋予一个ID。\nres0：保留,始终为0\nres1：保留,始终为0\nentryCount：等于本类型的资源项个数,指名称相同的资源项的个数。\n</code></pre><p>再来一段TYPETYPE的介绍：</p>\n<pre><code>类型资源项数据块用来描述资源项的具体信息, 这样我们就可以知道每一个资源项的名称、值和配置等信息。 类型资源项数据同样是按照类型和配置来组织的,也就是说,一个具有n个配置的类型一共对应有n个类型资源项数据块。\n</code></pre><p><img src=\"http://i.imgur.com/VBljfg6.png\" alt=\"\"></p>\n<p>TYPETYPE的数据结构：</p>\n<pre><code>header：Chunk的头部信息结构\nid：标识资源的Type ID\nres0：保留,始终为0\nres1：保留,始终为0\nentryCount：等于本类型的资源项个数,指名称相同的资源项的个数。\nentriesStart：等于资源项数据块相对头部的偏移值。\nresConfig：指向一个ResTable_config,用来描述配置信息,地区,语言,分辨率等\n</code></pre><p>注意下的是，这里两个chunk的id均是标识资源的id，这里是指类似drawable和anim等类型，其他字段在这里不做介绍，结合AndResGuard重点介绍的是紧跟TYPETYPE后的ResTable_entry数组，这个数组是指具体每个元素的配置解释，而这里也是AndResGuard需要做修改的其中两个地方。</p>\n<p>说实话，看到两段描述的时候有点混乱，查阅资料和说明例子后以为理解了，结合AndResGuard源码尝试去理解更换两个chunk数据，又陷入了无限的懵逼状态。归根结底，是不能理解类型和配置是如何进行映射。毛爷爷说过，实践是检验真理的唯一标准，于是乎，小弟写了个简单的helloworld的demo，主要截上资源配置：</p>\n<p><img src=\"http://i.imgur.com/4AZ99ZF.png\" alt=\"\"></p>\n<p>这里要留意两点，一是类型drawable有三种配置，分别是drawable-hdpi，drawable-mdpi和drawable-xhdpi，这三个配置里均有ic_launcher.png；第二点是，在drawable-mdpi文件下有test.png。</p>\n<p>然后就开始解析里面的resources.arsc，主要结果截图如下：</p>\n<p>图一：</p>\n<p><img src=\"http://i.imgur.com/qNT1t9t.png\" alt=\"\"></p>\n<p>图二：</p>\n<p><img src=\"http://i.imgur.com/0TKtzCp.png\" alt=\"\"></p>\n<p>关注图一，主要是说明两个TYPESPEC，以parse restype spec chunk…开始解析，第一块的type_name:attr，没有元素，所以<br>entryCount=0；第二块的type_name:drawable，留意下entryCount=2，有两个元素，所以对应有两个TYPETYPE，这里是以parse restype info chunk…开始解析，这个也很好理解，因为demo是有两张图片，分别是ic_launcher和test，对应的是drawable-mdpi文件下的文件描述；<br></p>\n<p>这时候关注下图二，这个是另外两个TYPETYPE chunk的截图，自然而然想到的是另外两个drawable的文件资源描述，图中每个圈是每一个entry，entry中的index是对应package chunk中资源项名称字符串池的字符串偏移值，解析出来的字符串时str:ic_launcher，value中的data其实是在 字符串资源池（TYPE_STRING）解析出来的数据，在内部也是通过一个偏移值去获取该值；图二还有一个细节，也是困扰小弟几天的问题，就是即使在drawable-mdpi文件下没有test.png，在其数据结构的trunk中的entryCount=2，而在具体的entry中datatype=TYPR_NULL,这就很好地理解了AndResGuard中替换资源名字的方法，保持每个resId的唯一性，同时也可以针对具体的配置进行文件名替换。<br></p>\n<p>至此，最后的两个chunk也介绍完毕。归结而言，就是每个资源类型对应一个TYPESPEC，而紧跟每一种类型的就是其类型所包含的配置，每个配置就是对应一个TYPETYPE。</p>\n<h1 id=\"关注AndResGuard\"><a href=\"#关注AndResGuard\" class=\"headerlink\" title=\"关注AndResGuard\"></a>关注AndResGuard</h1><p>大概了解了resources.arsc结构，去了解AndResGuard混淆资源的方案就应该更为清晰了，简单看下替换方案：</p>\n<p><img src=\"http://i.imgur.com/Z6EDzF0.png\" alt=\"\"></p>\n<p>首先，我们其实修改的是资源文件名(a.png)和资源文件的路径名（r\\a\\a.png），这样对应修改的就是TYPEPACKAGE和TYPE_STRING（对应方案1和3），而最后我们介绍的TYPETYPE和TYPESPEC是分别有TYPEPACKAGE和TYPE_STRING的字符串偏移值，这样对应也需要做修改（对应方案4），当然，缩短了文件命名必然会对整个table的大小造成改变，所以要重新计算并写入新的resources.arsc（对应方案5），结合源码分析，可能会有更深的理解。<br></p>\n<p>由于本人没有对resources.arsc做整体的透彻理解，只是在AndResGuard项目基础上去选择性关注要修改的点，如果在分析过程中有出现纰漏或者错误的地方，希望指出。</p>\n<p>参考资料：<br><a href=\"http://blog.csdn.net/jiangwei0910410003/article/details/50628894\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/jiangwei0910410003/article/details/50628894</a><br><a href=\"http://www.cnblogs.com/njxxdx/p/4189971.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/njxxdx/p/4189971.html</a></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>在研究资源混淆的过程中了解到微信的资源混淆工具–<a href=\"https://github.com/shwenzhang/AndResGuard\" target=\"_blank\" rel=\"noopener\">AndResGuard</a>，这个工具的强大之处不仅仅在于混淆了冗余的资源文件名称和明显减少apk的大小（这是官方说明，小弟小试了下效果不明显，有待考证），同时不涉及生成apk的编译流程，只需要输入apk和一些命令参数即可生成所需的混淆资源后的apk。","more":"（美团也有一套混淆资源的方法，介绍是修改AAPT处理资源文件相关的源码，牛逼哄哄的样子：<a href=\"http://tech.meituan.com/mt-android-resource-obfuscation.html\" target=\"_blank\" rel=\"noopener\">没错，我是链接</a>）。Anyway，对于追求完美的技术人员而言，并不能满足于一个现成的工具，了解其中原理加以修改才可以灵活运用。AndResGuard主要是通过修改resources.arsc文件来打到混淆的目的，因此，本文主要是对resources.arsc的文件格式进行阐述。<br>至于详细的实现方案和流程可参考<a href=\"http://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=208135658&amp;idx=1&amp;sn=ac9bd6b4927e9e82f9fa14e396183a8f#rd\" target=\"_blank\" rel=\"noopener\">AndResGuard原理</a></p>\n<h1 id=\"数据结构总体介绍\"><a href=\"#数据结构总体介绍\" class=\"headerlink\" title=\"数据结构总体介绍\"></a>数据结构总体介绍</h1><p>resources.arsc文件格式是由一系列的chunk构成。总体而言，可以大致分为五个chunk，分别是TYPETABLE，TYPEPACKAGE，TYPE_STRING， TYPETYPE和TYPESPEC；而这些chunk组成的结构就是资源索引表头部+字符串资源池+N个Package数据块。贴上一张传烂的图：</p>\n<p><img src=\"http://i.imgur.com/UVU3hWW.png\" alt=\"\"></p>\n<p>是的，看完这图我也是懵逼的。没关系，下面作一个详细点的介绍。</p>\n<h1 id=\"头部信息\"><a href=\"#头部信息\" class=\"headerlink\" title=\"头部信息\"></a>头部信息</h1><p>在介绍每个chunk之前，先说明下每个chunk均包含一个ResChunk_header的头部信息，具体的数据定义如下：</p>\n<pre><code>struct ResChunk_header\n{\n// 是当前这个chunk的类型\nuint16_t type;\n\n// 是当前这个chunk的头部大小\nuint16_t headerSize;\n\n// 是当前这个chunk的大小\nuint32_t size;\n};\n</code></pre><p>从上面的结构图可以看到，每一个chunk均是以ResChunk_header作为开头，在下面的介绍中，将会跳过。</p>\n<h1 id=\"资源索引表头部（TYPETABLE）\"><a href=\"#资源索引表头部（TYPETABLE）\" class=\"headerlink\" title=\"资源索引表头部（TYPETABLE）\"></a>资源索引表头部（TYPETABLE）</h1><p><img src=\"http://i.imgur.com/K76gXh0.png\" alt=\"\"></p>\n<p>可以看到，除了头部信息，还有一个package数的数据，一个apk可能包含多个资源包，这里就是指被编译的资源包个数。具体体现在有多少个TYPEPACKAGE。</p>\n<h1 id=\"字符串资源池（TYPE-STRING）\"><a href=\"#字符串资源池（TYPE-STRING）\" class=\"headerlink\" title=\"字符串资源池（TYPE_STRING）\"></a>字符串资源池（TYPE_STRING）</h1><p><img src=\"http://i.imgur.com/zWKmKf3.png\" alt=\"\"></p>\n<p>紧接着资源索引表头部的就是字符串资源池，这个chunk包含了所有package里定义的字符串。这个chunk的数据结构比较重要，在后面的TYPEPACKAGE里也包含着这一种chunk的数据结构，同时也是AndResGuard其中做修改数据的位置。下面简略地看下其数据结构介绍：</p>\n<h3 id=\"ResStringPool-header\"><a href=\"#ResStringPool-header\" class=\"headerlink\" title=\"ResStringPool_header\"></a>ResStringPool_header</h3><p>header：标准的Chunk头部信息结构<br><br>stringCount：字符串的个数<br><br>styleCount：字符串样式的个数<br><br>flags：字符串的属性,可取值包括0x000(UTF-16),0x001(字符串经过排序)、0X100(UTF-8)和他们的组合值<br><br>stringStart：字符串内容块相对于其头部的距离<br><br>stylesStart：字符串样式块相对于其头部的距离</p>\n<h3 id=\"两个Array和两个Content\"><a href=\"#两个Array和两个Content\" class=\"headerlink\" title=\"两个Array和两个Content\"></a>两个Array和两个Content</h3><p>紧接着ResStringPool_header就是字符串偏移数组和字符串样式偏移数组，字符串偏移数组每个元素记录着每个字符串相对于StringContent（图中数据‘字符串’）开始的索引；同样的，字符串样式偏移数组每个元素记录着每个字符串相对于StyleContent（图中数据‘style’）开始的索引。</p>\n<p>整个字符串资源区的结构示意图：</p>\n<p><img src=\"http://i.imgur.com/pV5kgSm.png\" alt=\"\"></p>\n<h1 id=\"Package数据块（TYPEPACKAGE）\"><a href=\"#Package数据块（TYPEPACKAGE）\" class=\"headerlink\" title=\"Package数据块（TYPEPACKAGE）\"></a>Package数据块（TYPEPACKAGE）</h1><p>在资源索引表头部中指定了package数目，所以，在这里开始，package数据块（包含TYPETYPE和TYPESPEC）是一个紧接着一个（假如有多个package）。<br><br>下面，先介绍下TYPEPACKAGE这个chunk的数据结构：</p>\n<p><img src=\"http://i.imgur.com/p0g4EWp.png\" alt=\"\"></p>\n<h3 id=\"ResTable-package\"><a href=\"#ResTable-package\" class=\"headerlink\" title=\"ResTable_package\"></a>ResTable_package</h3><p>header：Chunk的头部信息数据结构<br><br>id：包的ID,等于Package Id,一般用户包的值Package Id为0X7F,系统资源包的Package Id为0X01<br><br>name：包名<br><br>typeString：类型字符串资源池相对头部的偏移<br><br>lastPublicType：最后一个导出的Public类型字符串在类型字符串资源池中的索引，目前这个值设置为类型字符串资源池的元素个数。在解析的过程中没发现他的用途<br><br>keyStrings：资源项名称字符串相对头部的偏移<br><br>lastPublicKey：最后一个导出的Public资源项名称字符串在资源项名称字符串资源池中的索引，目前这个值设置为资源项名称字符串资源池的元素个数。在解析的过程中没发现他的用途</p>\n<h3 id=\"Type-String-Pool-amp-Key-String-Pool\"><a href=\"#Type-String-Pool-amp-Key-String-Pool\" class=\"headerlink\" title=\"Type String Pool &amp; Key String Pool\"></a>Type String Pool &amp; Key String Pool</h3><p>紧接着ResTable_package的是两个与字符串资源池有相同结构的字符串资源池，区别在于这里的资源池只是包含当前package的资源。</p>\n<p>Type String Pool（图中数据‘资源类型字符串池’）是一个package中用到的类型字符串，如：anim，id，layout；</p>\n<p>Key String Pool（图中数据‘资源项名称字符串池’），比如string.xml内容如下：</p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;resources&gt;\n&lt;string name=&quot;app_name&quot;&gt;Test&lt;/string&gt;\n&lt;string name=&quot;hello_world&quot;&gt;Hello world!&lt;/string&gt;\n&lt;string name=&quot;action_settings&quot;&gt;Settings&lt;/string&gt;\n&lt;/resources&gt;\n</code></pre><p>那么这个pool就收集了app_name，hello_world   action_settings 这3个字符串。这个pool是AndResGuard作修改的一处位置。</p>\n<p>整个Package数据块区的结构示意图：</p>\n<p><img src=\"http://i.imgur.com/Mhj3UOF.png\" alt=\"\"></p>\n<p>可以看到，在紧接着Type String Pool和Key String Pool后是剩下的两个chunk，在这里Type Specification Trunk和Type Info Trunk分别对应 TYPESPEC和TYPETYPE，下面作详细介绍。</p>\n<h1 id=\"类型规范数据块（TYPESPEC）-amp-资源类型项数据块（TYPETYPE）\"><a href=\"#类型规范数据块（TYPESPEC）-amp-资源类型项数据块（TYPETYPE）\" class=\"headerlink\" title=\"类型规范数据块（TYPESPEC） &amp; 资源类型项数据块（TYPETYPE）\"></a>类型规范数据块（TYPESPEC） &amp; 资源类型项数据块（TYPETYPE）</h1><p>先来看一段TYPESPEC的介绍：</p>\n<pre><code>类型规范数据块用来描述资源项的配置差异性。通过这个差异性描述，我们就可以知道每一个资源项的配置状况。知道了一个资源项的配置状况之后，Android资源管理框架在检测到设备的配置信息发生变化之后，就可以知道是否需要重新加载该资源项。类型规范数据块是按照类型来组织的，也就是说，每一种类型都对应有一个类型规范数据块。\n</code></pre><p><img src=\"http://i.imgur.com/ERotuBl.png\" alt=\"\"></p>\n<p>国际惯例，大概了解下其数据结构：</p>\n<pre><code>header：Chunk的头部信息结构\nid：标识资源的Type ID,Type ID是指资源的类型ID。资源的类型有animator、anim、color、drawable、layout、menu、raw、string和xml等等若干种，每一种都会被赋予一个ID。\nres0：保留,始终为0\nres1：保留,始终为0\nentryCount：等于本类型的资源项个数,指名称相同的资源项的个数。\n</code></pre><p>再来一段TYPETYPE的介绍：</p>\n<pre><code>类型资源项数据块用来描述资源项的具体信息, 这样我们就可以知道每一个资源项的名称、值和配置等信息。 类型资源项数据同样是按照类型和配置来组织的,也就是说,一个具有n个配置的类型一共对应有n个类型资源项数据块。\n</code></pre><p><img src=\"http://i.imgur.com/VBljfg6.png\" alt=\"\"></p>\n<p>TYPETYPE的数据结构：</p>\n<pre><code>header：Chunk的头部信息结构\nid：标识资源的Type ID\nres0：保留,始终为0\nres1：保留,始终为0\nentryCount：等于本类型的资源项个数,指名称相同的资源项的个数。\nentriesStart：等于资源项数据块相对头部的偏移值。\nresConfig：指向一个ResTable_config,用来描述配置信息,地区,语言,分辨率等\n</code></pre><p>注意下的是，这里两个chunk的id均是标识资源的id，这里是指类似drawable和anim等类型，其他字段在这里不做介绍，结合AndResGuard重点介绍的是紧跟TYPETYPE后的ResTable_entry数组，这个数组是指具体每个元素的配置解释，而这里也是AndResGuard需要做修改的其中两个地方。</p>\n<p>说实话，看到两段描述的时候有点混乱，查阅资料和说明例子后以为理解了，结合AndResGuard源码尝试去理解更换两个chunk数据，又陷入了无限的懵逼状态。归根结底，是不能理解类型和配置是如何进行映射。毛爷爷说过，实践是检验真理的唯一标准，于是乎，小弟写了个简单的helloworld的demo，主要截上资源配置：</p>\n<p><img src=\"http://i.imgur.com/4AZ99ZF.png\" alt=\"\"></p>\n<p>这里要留意两点，一是类型drawable有三种配置，分别是drawable-hdpi，drawable-mdpi和drawable-xhdpi，这三个配置里均有ic_launcher.png；第二点是，在drawable-mdpi文件下有test.png。</p>\n<p>然后就开始解析里面的resources.arsc，主要结果截图如下：</p>\n<p>图一：</p>\n<p><img src=\"http://i.imgur.com/qNT1t9t.png\" alt=\"\"></p>\n<p>图二：</p>\n<p><img src=\"http://i.imgur.com/0TKtzCp.png\" alt=\"\"></p>\n<p>关注图一，主要是说明两个TYPESPEC，以parse restype spec chunk…开始解析，第一块的type_name:attr，没有元素，所以<br>entryCount=0；第二块的type_name:drawable，留意下entryCount=2，有两个元素，所以对应有两个TYPETYPE，这里是以parse restype info chunk…开始解析，这个也很好理解，因为demo是有两张图片，分别是ic_launcher和test，对应的是drawable-mdpi文件下的文件描述；<br></p>\n<p>这时候关注下图二，这个是另外两个TYPETYPE chunk的截图，自然而然想到的是另外两个drawable的文件资源描述，图中每个圈是每一个entry，entry中的index是对应package chunk中资源项名称字符串池的字符串偏移值，解析出来的字符串时str:ic_launcher，value中的data其实是在 字符串资源池（TYPE_STRING）解析出来的数据，在内部也是通过一个偏移值去获取该值；图二还有一个细节，也是困扰小弟几天的问题，就是即使在drawable-mdpi文件下没有test.png，在其数据结构的trunk中的entryCount=2，而在具体的entry中datatype=TYPR_NULL,这就很好地理解了AndResGuard中替换资源名字的方法，保持每个resId的唯一性，同时也可以针对具体的配置进行文件名替换。<br></p>\n<p>至此，最后的两个chunk也介绍完毕。归结而言，就是每个资源类型对应一个TYPESPEC，而紧跟每一种类型的就是其类型所包含的配置，每个配置就是对应一个TYPETYPE。</p>\n<h1 id=\"关注AndResGuard\"><a href=\"#关注AndResGuard\" class=\"headerlink\" title=\"关注AndResGuard\"></a>关注AndResGuard</h1><p>大概了解了resources.arsc结构，去了解AndResGuard混淆资源的方案就应该更为清晰了，简单看下替换方案：</p>\n<p><img src=\"http://i.imgur.com/Z6EDzF0.png\" alt=\"\"></p>\n<p>首先，我们其实修改的是资源文件名(a.png)和资源文件的路径名（r\\a\\a.png），这样对应修改的就是TYPEPACKAGE和TYPE_STRING（对应方案1和3），而最后我们介绍的TYPETYPE和TYPESPEC是分别有TYPEPACKAGE和TYPE_STRING的字符串偏移值，这样对应也需要做修改（对应方案4），当然，缩短了文件命名必然会对整个table的大小造成改变，所以要重新计算并写入新的resources.arsc（对应方案5），结合源码分析，可能会有更深的理解。<br></p>\n<p>由于本人没有对resources.arsc做整体的透彻理解，只是在AndResGuard项目基础上去选择性关注要修改的点，如果在分析过程中有出现纰漏或者错误的地方，希望指出。</p>\n<p>参考资料：<br><a href=\"http://blog.csdn.net/jiangwei0910410003/article/details/50628894\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/jiangwei0910410003/article/details/50628894</a><br><a href=\"http://www.cnblogs.com/njxxdx/p/4189971.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/njxxdx/p/4189971.html</a></p>"},{"title":"python脚本实现图片压缩","date":"2018-01-28T15:39:34.391Z","_content":"\n# 前言\n\n在我们android开发过程中，无可避免地都需要对图片资源进行压缩，尽可能减少最终apk包的大小。目前压缩的方法可谓是五花八门，笔者这里主要介绍利用python脚本进行图片的批量压缩。<!-- more -->\n\n# Tinypng\n\n打开它的官网 [https://tinypng.com](https://tinypng.com/) 发现其提供线上上传图片进行压缩，看到例子介绍压缩率还是蛮可观的，而且压缩前后对图片影响不大。我们点进去***DEVELOPER API***,可以看到其支持不少编程语言进行压缩：\n\n![](http://i.imgur.com/Kw8u1l6.png)\n\n为了和下面介绍的方法统一，这里介绍python语言的使用，笔者用的是windows系统，下面介绍请参考windows配置。\n\n1.首先，需要申请一个API key配置：\n\n![](http://i.imgur.com/wSSlLG0.png)\n2.接着安装tinify的python插件，在cmd命令行输入：\n\n\tpip install --upgrade tinify\n\n3.现在就可以开始编写python脚本了，贴上核心代码： \n\n\timport tinify\n\t....\n\ttinify_keys = \"\"YOUR_API_KEY\"\"\n\t...\n\tsource = tinify.from_file(\"unoptimized.jpg\")\n\tsource.to_file(\"optimized.jpg\")\n\nTinypng还有很多对图片进行处理的接口，这里主要是介绍压缩就没有展开细说。其实利用Tinypng对图片进行压缩还是蛮简单的，但是蛋疼的是申请的API key每个月只支持500张的免费压缩：\n\n![](http://i.imgur.com/SQeVvT0.png)\n\n这对于我们开发人员来说是远远不够的（当然，你可以申请多个API key或者直接付钱），所以就得继续寻找看有没有更好的替代方案。\n\n# pngquant\n\npngquant是国外一个有损的PNG压缩库，介绍称结合vector quantization算法生成高质量的色彩范围，用脚本同样可以处理批量图片压缩。其支持命令行和源码库形式使用，这里介绍的是使用命令行方式：\n\n1.首先，在 [pngquant官网](https://pngquant.org/)  下载适合windows系统的包：\n\n![](http://i.imgur.com/niSwhMV.png)\n\n下载下来的包含两个预处理的bat命令和pngquant.exe：\n\n![](http://i.imgur.com/AZyrNsD.png)\n\n因为我们自己编写python批处理脚本，所以这里只需要用到压缩的pngquant.exe工具；\n\n2.现在就可以开始编写python脚本了，贴上核心代码：\n\n\timport subprocess\n\t#需修改为你自己本地pnguant.exe路径\n\tPNGQUANT_PATH = r'Your path\\pngquant.exe'\n\t...\n\tcmd_command = '\"{0}\" 256 -s1 --force --quality=50-50 \"{1}\" -o \"{2}\"'.format(PNGQUANT_PATH, \"unoptimized.png\", \"optimized.png\")\n\t#执行命令\n    p = subprocess.Popen(cmd_command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\n    retval = p.wait()\n\n以上就是对pngquant压缩代码的介绍，经测试发现，这种压缩方式有的情况下会出现压缩后的大小比压缩前还要大（压缩率为负数），笔者尝试调整--quality参数从20-100均不能解决问题（当然，并不能为了大小而影响图片质量，笔者认为参数quality在50已经是设置的最低值，这里只是做测试），暂时没找到有效的参数设置去解决，如果读者找到原因，希望可以分享下方法。\n\n# Pillow (PIL Fork)\n\nPillow是python内置的PIL（Python Imaging Library）的一个分支，当初使用这个库主要是因为其支持python 3.0+版本，主要是对图片进行等比例缩放。后面做了测试发现，Pillow支持对png图片的压缩还是蛮可观的（比Tinypng逊色点），下面就简单介绍下其使用：[Pillow官网](https://pillow.readthedocs.io/en/3.3.x/) \n\n1.安装Pillow的python插件：\n\n***注意，如果你电脑已经安装过python的 PIL库，请先卸掉再安装Pillow***\n\n![](http://i.imgur.com/sJppxxf.png)\n\n\tpip install Pillow\n\n或者<br>\n\t\n\teasy_install Pillow\n\n2.现在就可以开始编写python脚本了，贴上核心代码：\n\n\tfrom PIL import Image\n\t...\n\tim = Image.open(\"unoptimized.png\")\n\tif file.endswith(\".png\"):\n\t\tim = im.convert('P')\n    im.save(\"optimized.png\",optimize=True)\n\n可以看到，上面做了一个图片是否为png的判断，主要是Pillow对png图片压缩能做到更好的处理。\n\n# 总结：\n\n针对以上三种的图片压缩工具，如果你有足够多的API key或者图片只在最终发包使用前才压缩，优先考虑Tinypng，因为这个是压缩效果最好；而次之选择考虑Pillow，其较为接近Tinypng的压缩效果和出现压缩率为负数的图片几率数少；鉴于笔者没有找到有效解决pngquant出现压缩率为负数较多情况下的出现，所以笔者尽可能会减少使用。***特别注意的是，不要对同一张图片进行多次压缩，这样必然会影响图片的质量，得不偿失。***\n\n源码参考：[https://github.com/hellokugo/imgCompress](https://github.com/hellokugo/imgCompress) ","source":"_posts/python脚本实现图片压缩.md","raw":"title: python脚本实现图片压缩\ndate: 2016/9/10 16：00\n\ncategories:\n- Python\ntags:\n- python\n---\n\n# 前言\n\n在我们android开发过程中，无可避免地都需要对图片资源进行压缩，尽可能减少最终apk包的大小。目前压缩的方法可谓是五花八门，笔者这里主要介绍利用python脚本进行图片的批量压缩。<!-- more -->\n\n# Tinypng\n\n打开它的官网 [https://tinypng.com](https://tinypng.com/) 发现其提供线上上传图片进行压缩，看到例子介绍压缩率还是蛮可观的，而且压缩前后对图片影响不大。我们点进去***DEVELOPER API***,可以看到其支持不少编程语言进行压缩：\n\n![](http://i.imgur.com/Kw8u1l6.png)\n\n为了和下面介绍的方法统一，这里介绍python语言的使用，笔者用的是windows系统，下面介绍请参考windows配置。\n\n1.首先，需要申请一个API key配置：\n\n![](http://i.imgur.com/wSSlLG0.png)\n2.接着安装tinify的python插件，在cmd命令行输入：\n\n\tpip install --upgrade tinify\n\n3.现在就可以开始编写python脚本了，贴上核心代码： \n\n\timport tinify\n\t....\n\ttinify_keys = \"\"YOUR_API_KEY\"\"\n\t...\n\tsource = tinify.from_file(\"unoptimized.jpg\")\n\tsource.to_file(\"optimized.jpg\")\n\nTinypng还有很多对图片进行处理的接口，这里主要是介绍压缩就没有展开细说。其实利用Tinypng对图片进行压缩还是蛮简单的，但是蛋疼的是申请的API key每个月只支持500张的免费压缩：\n\n![](http://i.imgur.com/SQeVvT0.png)\n\n这对于我们开发人员来说是远远不够的（当然，你可以申请多个API key或者直接付钱），所以就得继续寻找看有没有更好的替代方案。\n\n# pngquant\n\npngquant是国外一个有损的PNG压缩库，介绍称结合vector quantization算法生成高质量的色彩范围，用脚本同样可以处理批量图片压缩。其支持命令行和源码库形式使用，这里介绍的是使用命令行方式：\n\n1.首先，在 [pngquant官网](https://pngquant.org/)  下载适合windows系统的包：\n\n![](http://i.imgur.com/niSwhMV.png)\n\n下载下来的包含两个预处理的bat命令和pngquant.exe：\n\n![](http://i.imgur.com/AZyrNsD.png)\n\n因为我们自己编写python批处理脚本，所以这里只需要用到压缩的pngquant.exe工具；\n\n2.现在就可以开始编写python脚本了，贴上核心代码：\n\n\timport subprocess\n\t#需修改为你自己本地pnguant.exe路径\n\tPNGQUANT_PATH = r'Your path\\pngquant.exe'\n\t...\n\tcmd_command = '\"{0}\" 256 -s1 --force --quality=50-50 \"{1}\" -o \"{2}\"'.format(PNGQUANT_PATH, \"unoptimized.png\", \"optimized.png\")\n\t#执行命令\n    p = subprocess.Popen(cmd_command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\n    retval = p.wait()\n\n以上就是对pngquant压缩代码的介绍，经测试发现，这种压缩方式有的情况下会出现压缩后的大小比压缩前还要大（压缩率为负数），笔者尝试调整--quality参数从20-100均不能解决问题（当然，并不能为了大小而影响图片质量，笔者认为参数quality在50已经是设置的最低值，这里只是做测试），暂时没找到有效的参数设置去解决，如果读者找到原因，希望可以分享下方法。\n\n# Pillow (PIL Fork)\n\nPillow是python内置的PIL（Python Imaging Library）的一个分支，当初使用这个库主要是因为其支持python 3.0+版本，主要是对图片进行等比例缩放。后面做了测试发现，Pillow支持对png图片的压缩还是蛮可观的（比Tinypng逊色点），下面就简单介绍下其使用：[Pillow官网](https://pillow.readthedocs.io/en/3.3.x/) \n\n1.安装Pillow的python插件：\n\n***注意，如果你电脑已经安装过python的 PIL库，请先卸掉再安装Pillow***\n\n![](http://i.imgur.com/sJppxxf.png)\n\n\tpip install Pillow\n\n或者<br>\n\t\n\teasy_install Pillow\n\n2.现在就可以开始编写python脚本了，贴上核心代码：\n\n\tfrom PIL import Image\n\t...\n\tim = Image.open(\"unoptimized.png\")\n\tif file.endswith(\".png\"):\n\t\tim = im.convert('P')\n    im.save(\"optimized.png\",optimize=True)\n\n可以看到，上面做了一个图片是否为png的判断，主要是Pillow对png图片压缩能做到更好的处理。\n\n# 总结：\n\n针对以上三种的图片压缩工具，如果你有足够多的API key或者图片只在最终发包使用前才压缩，优先考虑Tinypng，因为这个是压缩效果最好；而次之选择考虑Pillow，其较为接近Tinypng的压缩效果和出现压缩率为负数的图片几率数少；鉴于笔者没有找到有效解决pngquant出现压缩率为负数较多情况下的出现，所以笔者尽可能会减少使用。***特别注意的是，不要对同一张图片进行多次压缩，这样必然会影响图片的质量，得不偿失。***\n\n源码参考：[https://github.com/hellokugo/imgCompress](https://github.com/hellokugo/imgCompress) ","slug":"python脚本实现图片压缩","published":1,"updated":"2018-01-28T15:39:34.391Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjcyyg7k9000hnius9pkz8xmz","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>在我们android开发过程中，无可避免地都需要对图片资源进行压缩，尽可能减少最终apk包的大小。目前压缩的方法可谓是五花八门，笔者这里主要介绍利用python脚本进行图片的批量压缩。<a id=\"more\"></a></p>\n<h1 id=\"Tinypng\"><a href=\"#Tinypng\" class=\"headerlink\" title=\"Tinypng\"></a>Tinypng</h1><p>打开它的官网 <a href=\"https://tinypng.com/\" target=\"_blank\" rel=\"noopener\">https://tinypng.com</a> 发现其提供线上上传图片进行压缩，看到例子介绍压缩率还是蛮可观的，而且压缩前后对图片影响不大。我们点进去<strong><em>DEVELOPER API</em></strong>,可以看到其支持不少编程语言进行压缩：</p>\n<p><img src=\"http://i.imgur.com/Kw8u1l6.png\" alt=\"\"></p>\n<p>为了和下面介绍的方法统一，这里介绍python语言的使用，笔者用的是windows系统，下面介绍请参考windows配置。</p>\n<p>1.首先，需要申请一个API key配置：</p>\n<p><img src=\"http://i.imgur.com/wSSlLG0.png\" alt=\"\"><br>2.接着安装tinify的python插件，在cmd命令行输入：</p>\n<pre><code>pip install --upgrade tinify\n</code></pre><p>3.现在就可以开始编写python脚本了，贴上核心代码： </p>\n<pre><code>import tinify\n....\ntinify_keys = &quot;&quot;YOUR_API_KEY&quot;&quot;\n...\nsource = tinify.from_file(&quot;unoptimized.jpg&quot;)\nsource.to_file(&quot;optimized.jpg&quot;)\n</code></pre><p>Tinypng还有很多对图片进行处理的接口，这里主要是介绍压缩就没有展开细说。其实利用Tinypng对图片进行压缩还是蛮简单的，但是蛋疼的是申请的API key每个月只支持500张的免费压缩：</p>\n<p><img src=\"http://i.imgur.com/SQeVvT0.png\" alt=\"\"></p>\n<p>这对于我们开发人员来说是远远不够的（当然，你可以申请多个API key或者直接付钱），所以就得继续寻找看有没有更好的替代方案。</p>\n<h1 id=\"pngquant\"><a href=\"#pngquant\" class=\"headerlink\" title=\"pngquant\"></a>pngquant</h1><p>pngquant是国外一个有损的PNG压缩库，介绍称结合vector quantization算法生成高质量的色彩范围，用脚本同样可以处理批量图片压缩。其支持命令行和源码库形式使用，这里介绍的是使用命令行方式：</p>\n<p>1.首先，在 <a href=\"https://pngquant.org/\" target=\"_blank\" rel=\"noopener\">pngquant官网</a>  下载适合windows系统的包：</p>\n<p><img src=\"http://i.imgur.com/niSwhMV.png\" alt=\"\"></p>\n<p>下载下来的包含两个预处理的bat命令和pngquant.exe：</p>\n<p><img src=\"http://i.imgur.com/AZyrNsD.png\" alt=\"\"></p>\n<p>因为我们自己编写python批处理脚本，所以这里只需要用到压缩的pngquant.exe工具；</p>\n<p>2.现在就可以开始编写python脚本了，贴上核心代码：</p>\n<pre><code>import subprocess\n#需修改为你自己本地pnguant.exe路径\nPNGQUANT_PATH = r&apos;Your path\\pngquant.exe&apos;\n...\ncmd_command = &apos;&quot;{0}&quot; 256 -s1 --force --quality=50-50 &quot;{1}&quot; -o &quot;{2}&quot;&apos;.format(PNGQUANT_PATH, &quot;unoptimized.png&quot;, &quot;optimized.png&quot;)\n#执行命令\np = subprocess.Popen(cmd_command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\nretval = p.wait()\n</code></pre><p>以上就是对pngquant压缩代码的介绍，经测试发现，这种压缩方式有的情况下会出现压缩后的大小比压缩前还要大（压缩率为负数），笔者尝试调整–quality参数从20-100均不能解决问题（当然，并不能为了大小而影响图片质量，笔者认为参数quality在50已经是设置的最低值，这里只是做测试），暂时没找到有效的参数设置去解决，如果读者找到原因，希望可以分享下方法。</p>\n<h1 id=\"Pillow-PIL-Fork\"><a href=\"#Pillow-PIL-Fork\" class=\"headerlink\" title=\"Pillow (PIL Fork)\"></a>Pillow (PIL Fork)</h1><p>Pillow是python内置的PIL（Python Imaging Library）的一个分支，当初使用这个库主要是因为其支持python 3.0+版本，主要是对图片进行等比例缩放。后面做了测试发现，Pillow支持对png图片的压缩还是蛮可观的（比Tinypng逊色点），下面就简单介绍下其使用：<a href=\"https://pillow.readthedocs.io/en/3.3.x/\" target=\"_blank\" rel=\"noopener\">Pillow官网</a> </p>\n<p>1.安装Pillow的python插件：</p>\n<p><strong><em>注意，如果你电脑已经安装过python的 PIL库，请先卸掉再安装Pillow</em></strong></p>\n<p><img src=\"http://i.imgur.com/sJppxxf.png\" alt=\"\"></p>\n<pre><code>pip install Pillow\n</code></pre><p>或者<br></p>\n<pre><code>easy_install Pillow\n</code></pre><p>2.现在就可以开始编写python脚本了，贴上核心代码：</p>\n<pre><code>from PIL import Image\n...\nim = Image.open(&quot;unoptimized.png&quot;)\nif file.endswith(&quot;.png&quot;):\n    im = im.convert(&apos;P&apos;)\nim.save(&quot;optimized.png&quot;,optimize=True)\n</code></pre><p>可以看到，上面做了一个图片是否为png的判断，主要是Pillow对png图片压缩能做到更好的处理。</p>\n<h1 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h1><p>针对以上三种的图片压缩工具，如果你有足够多的API key或者图片只在最终发包使用前才压缩，优先考虑Tinypng，因为这个是压缩效果最好；而次之选择考虑Pillow，其较为接近Tinypng的压缩效果和出现压缩率为负数的图片几率数少；鉴于笔者没有找到有效解决pngquant出现压缩率为负数较多情况下的出现，所以笔者尽可能会减少使用。<strong><em>特别注意的是，不要对同一张图片进行多次压缩，这样必然会影响图片的质量，得不偿失。</em></strong></p>\n<p>源码参考：<a href=\"https://github.com/hellokugo/imgCompress\" target=\"_blank\" rel=\"noopener\">https://github.com/hellokugo/imgCompress</a> </p>\n","site":{"data":{}},"excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>在我们android开发过程中，无可避免地都需要对图片资源进行压缩，尽可能减少最终apk包的大小。目前压缩的方法可谓是五花八门，笔者这里主要介绍利用python脚本进行图片的批量压缩。","more":"</p>\n<h1 id=\"Tinypng\"><a href=\"#Tinypng\" class=\"headerlink\" title=\"Tinypng\"></a>Tinypng</h1><p>打开它的官网 <a href=\"https://tinypng.com/\" target=\"_blank\" rel=\"noopener\">https://tinypng.com</a> 发现其提供线上上传图片进行压缩，看到例子介绍压缩率还是蛮可观的，而且压缩前后对图片影响不大。我们点进去<strong><em>DEVELOPER API</em></strong>,可以看到其支持不少编程语言进行压缩：</p>\n<p><img src=\"http://i.imgur.com/Kw8u1l6.png\" alt=\"\"></p>\n<p>为了和下面介绍的方法统一，这里介绍python语言的使用，笔者用的是windows系统，下面介绍请参考windows配置。</p>\n<p>1.首先，需要申请一个API key配置：</p>\n<p><img src=\"http://i.imgur.com/wSSlLG0.png\" alt=\"\"><br>2.接着安装tinify的python插件，在cmd命令行输入：</p>\n<pre><code>pip install --upgrade tinify\n</code></pre><p>3.现在就可以开始编写python脚本了，贴上核心代码： </p>\n<pre><code>import tinify\n....\ntinify_keys = &quot;&quot;YOUR_API_KEY&quot;&quot;\n...\nsource = tinify.from_file(&quot;unoptimized.jpg&quot;)\nsource.to_file(&quot;optimized.jpg&quot;)\n</code></pre><p>Tinypng还有很多对图片进行处理的接口，这里主要是介绍压缩就没有展开细说。其实利用Tinypng对图片进行压缩还是蛮简单的，但是蛋疼的是申请的API key每个月只支持500张的免费压缩：</p>\n<p><img src=\"http://i.imgur.com/SQeVvT0.png\" alt=\"\"></p>\n<p>这对于我们开发人员来说是远远不够的（当然，你可以申请多个API key或者直接付钱），所以就得继续寻找看有没有更好的替代方案。</p>\n<h1 id=\"pngquant\"><a href=\"#pngquant\" class=\"headerlink\" title=\"pngquant\"></a>pngquant</h1><p>pngquant是国外一个有损的PNG压缩库，介绍称结合vector quantization算法生成高质量的色彩范围，用脚本同样可以处理批量图片压缩。其支持命令行和源码库形式使用，这里介绍的是使用命令行方式：</p>\n<p>1.首先，在 <a href=\"https://pngquant.org/\" target=\"_blank\" rel=\"noopener\">pngquant官网</a>  下载适合windows系统的包：</p>\n<p><img src=\"http://i.imgur.com/niSwhMV.png\" alt=\"\"></p>\n<p>下载下来的包含两个预处理的bat命令和pngquant.exe：</p>\n<p><img src=\"http://i.imgur.com/AZyrNsD.png\" alt=\"\"></p>\n<p>因为我们自己编写python批处理脚本，所以这里只需要用到压缩的pngquant.exe工具；</p>\n<p>2.现在就可以开始编写python脚本了，贴上核心代码：</p>\n<pre><code>import subprocess\n#需修改为你自己本地pnguant.exe路径\nPNGQUANT_PATH = r&apos;Your path\\pngquant.exe&apos;\n...\ncmd_command = &apos;&quot;{0}&quot; 256 -s1 --force --quality=50-50 &quot;{1}&quot; -o &quot;{2}&quot;&apos;.format(PNGQUANT_PATH, &quot;unoptimized.png&quot;, &quot;optimized.png&quot;)\n#执行命令\np = subprocess.Popen(cmd_command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\nretval = p.wait()\n</code></pre><p>以上就是对pngquant压缩代码的介绍，经测试发现，这种压缩方式有的情况下会出现压缩后的大小比压缩前还要大（压缩率为负数），笔者尝试调整–quality参数从20-100均不能解决问题（当然，并不能为了大小而影响图片质量，笔者认为参数quality在50已经是设置的最低值，这里只是做测试），暂时没找到有效的参数设置去解决，如果读者找到原因，希望可以分享下方法。</p>\n<h1 id=\"Pillow-PIL-Fork\"><a href=\"#Pillow-PIL-Fork\" class=\"headerlink\" title=\"Pillow (PIL Fork)\"></a>Pillow (PIL Fork)</h1><p>Pillow是python内置的PIL（Python Imaging Library）的一个分支，当初使用这个库主要是因为其支持python 3.0+版本，主要是对图片进行等比例缩放。后面做了测试发现，Pillow支持对png图片的压缩还是蛮可观的（比Tinypng逊色点），下面就简单介绍下其使用：<a href=\"https://pillow.readthedocs.io/en/3.3.x/\" target=\"_blank\" rel=\"noopener\">Pillow官网</a> </p>\n<p>1.安装Pillow的python插件：</p>\n<p><strong><em>注意，如果你电脑已经安装过python的 PIL库，请先卸掉再安装Pillow</em></strong></p>\n<p><img src=\"http://i.imgur.com/sJppxxf.png\" alt=\"\"></p>\n<pre><code>pip install Pillow\n</code></pre><p>或者<br></p>\n<pre><code>easy_install Pillow\n</code></pre><p>2.现在就可以开始编写python脚本了，贴上核心代码：</p>\n<pre><code>from PIL import Image\n...\nim = Image.open(&quot;unoptimized.png&quot;)\nif file.endswith(&quot;.png&quot;):\n    im = im.convert(&apos;P&apos;)\nim.save(&quot;optimized.png&quot;,optimize=True)\n</code></pre><p>可以看到，上面做了一个图片是否为png的判断，主要是Pillow对png图片压缩能做到更好的处理。</p>\n<h1 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h1><p>针对以上三种的图片压缩工具，如果你有足够多的API key或者图片只在最终发包使用前才压缩，优先考虑Tinypng，因为这个是压缩效果最好；而次之选择考虑Pillow，其较为接近Tinypng的压缩效果和出现压缩率为负数的图片几率数少；鉴于笔者没有找到有效解决pngquant出现压缩率为负数较多情况下的出现，所以笔者尽可能会减少使用。<strong><em>特别注意的是，不要对同一张图片进行多次压缩，这样必然会影响图片的质量，得不偿失。</em></strong></p>\n<p>源码参考：<a href=\"https://github.com/hellokugo/imgCompress\" target=\"_blank\" rel=\"noopener\">https://github.com/hellokugo/imgCompress</a> </p>"},{"title":"优化动态加载方案","date":"2018-01-28T15:39:34.392Z","_content":"\n# 前言\n\n在之前的动态加载方案中，是可以将多个apk（这里可以理解为封装的第三方sdk）模块进行动态加载。但在这里面有一个很蛋疼的问题，就是由于android系统底层对资源加载方式的不一样导致处理方式也不同，具体可参考 [那些年蘑菇街Android组件与插件化背后的故事 -- 插件篇(一)](http://mogu.io/117-117) ，在文章的最后提及到：<!-- more -->\n\n![](http://i.imgur.com/9di4nJj.png)\n\n所以以往对资源的处理只是简单地把第三方sdk的资源默认放到母包res下，这样母包包体依旧很大并未能做到正常的“动态”，而且针对代码存在getresources().getidentifier（R.id.**）这种加载方式还会造成混乱报错，并且不同系统的差异也可能需要做相应的处理。由于笔者对android底层和整套资源加载的模式不熟悉，所以在这个问题上一直找不到方向。直至微信推出自家的 [微信 Android 热补丁实践演进之路](http://www.tuicool.com/articles/uym2QrU) 一文中提及到google官方在AS上实现的热修复方案，看到不一样的资源加载方式。\n\n# InstantRun\n\n关于InstantRun的使用和原理在网上已经有不少的介绍（仅供参考：[Instant Run工作原理及用法](http://www.jianshu.com/p/2e23ba9ff14b) && [从Instant-Run出发，谈谈Android上的热修复](http://www.tuicool.com/articles/uQJjA3b)），这里就不再累赘。\n由于InstantRun的出发点是用于开发过程的热修复，所以有些技术点在这里是不需要我们做太多关注。笔者在研究过程中发现其有两大亮点，一是其加载代码方式，我们知道，以往做的动态加载是用参考了google官方MultiDex思想，在PathClassLoader的Element数组添加插件，是单classLoader策略，而InstantRun是采用多classLoader策略，做到不需要重启应用就可以把修复类加载进来；二是资源加载的方式，以往我们进行动态加载资源是在程序启动过程中把第三方的资源逐一添加到母包的AssetManager的path路径中，而InstantRun则是直接替换整份资源._ap文件，在程序启动过程中读取该文件。._ap文件其实就是一个压缩包，解压后：\n\n![](http://i.imgur.com/F87b3Cs.png)\n\n可以看到，其实就是一份资源包。我们能否在这种加载方式找到适合我们动态加载的方法呢？答案是肯定的。\n\n# 优化动态加载\n\n## 思路：\n\n以往的动态加载是以这种格式：\n\n\t母包：\n\t \t母包代码 + 母包资源 + 第三方资源 + 包含第三方声明AndroidManifest.xml\n\n\t插件（封装的第三方sdk）：\n\t\t插件代码 + 插件资源 + AndroidManifest.xml= .apk文件（其实就是整一份封装文件）\n\n这种方式的加载，已经验证代码动态加载是没有问题，目前如何处理资源呢？尝试以下格式：\n\n\t母包：\n\t \t母包代码（不包含R.java） + 母包资源（有可能加上第三方style等资源） + 包含第三方声明AndroidManifest.xml\n\n\t插件（不仅仅是封装的第三方sdk）：\n\t\t在本地依赖第三方sdk后的R文件（打成一个apk用作动态加载）；\n\t\t在本地依赖第三方sdk后的资源.ap_文件；\n\t\t插件代码 = .apk文件（仅含代码classes.dex的apk文件）；\n\t\t\n        \n\n## 说明：\n\n1. 由于AndroidManifest.xml在安装apk的时候就已经固定了（即使._ap文件有这个文件，但是做替换好像没效果）。所以，需要集成的sdk还是需要预写在母包的AndroidManifest.xml；\n\n2. 由于AndroidManifest.xml有第三方sdk的声明，所以一些Activity有可能会定义类似style格式，这时候在母包的资源如果没有引用的style资源文件就会编译不过，所以这些资源也必须预放在母包的AndroidManifest.xml下；\n\n3. [public.xml](http://stackoverflow.com/questions/9348614/what-is-the-use-of-the-res-values-public-xml-file-on-android)，这个文件一般在开发过程中比较少用到，但是我们反编译之后就会在res/values文件夹下看到，简单来说，这个文件是用来固定资源id，这里用到的作用后面再细说；\n\n4. 我们反编译apk后发现，原本代码写的资源引用类似R.id.&&都被一个字符串常量所替换了，这是为什么呢？细心点就会发现，这个常量值在aapt生成的R.java文件中是和资源一一对应的，在编译后这些资源引用都替换成常量，加快了查找资源的效率。但是这种优化在动态加载资源往往就容易出现问题，因为一旦这些值被固定了，后续添加的资源有可能会打乱之前的资源id对应关系，这样肯定会出现资源紊乱报错。因此，这里牺牲了效率，在aapt打包过程中不把代码中的资源引用固定，还是保留R.id.&&，这样在查找资源还是会从R文件里面找对应常量。\n\n5. 由于资源被统一成一份了，在资源查找过程用的R.java文件应该是新的一份，这样必须得采用动态加载R.java。在 [QQ空间实现热修复方案](https://mp.weixin.qq.com/s?__biz=MzI1MTA1MzM2Nw==&mid=400118620&idx=1&sn=b4fdd5055731290eef12ad0d17f39d4a) 中提及到，假如不对母包的R.java处理（母包还是有R.java），在动态加载的时候先把我们集成新的一份R.java加载，原本的R.java就不会加载到，但是用这种方式加载在5.0以下系统的手机会把不做处理的类打上***CLASS_ISPREVERIFIED***标志。所以，这里有两个思路，一是按照QQ空间方法使用字节码插入代码（比较保险），二是本例介绍的在编译母包apk的时候先把R.java抽出来再做动态加载。当然了，第二种方法为了保险起见，默认应该要把母包的R.java生成的apk放到类似assets目录下，保证即使没有集成新的R.java也可以正常运行。\n\n## 实践：\n\n这里随机选取了几个有代表性的封装第三方sdk进行测试（多米广告sdk、掌阅登陆和支付、话付宝综合支付），简要说说如何进行集成：\n\n### 接管母包生成过程\n\n针对业务的母包代码工程，在编译前先做几步处理：\n\n\t1. 把接入的第三方sdk的AndroidManifest.xml做拷贝；\n\t2. 查找拷贝后的AndroidManifest.xml是否包括引用的第三方资源文件，如果有，则进行相应资源文件拷贝。\n\n\n接下来就是命令行生成母包apk的介绍（可以用python脚本集成）：\n\n1.生成R文件\n\n\taapt p -f -m -J gen -S res -I E:\\android-sdk\\android-sdk-windows\\android-sdk-windows\\platforms\\android-20\\android.jar -M AndroidManifest.xml -A assets --non-constant-id\n\n--non-constant-id 很关键，加上这个参数代表R文件的资源声明不是final，即在后面编译代码中通过R.id.&& 引用的资源不会转换资源成id常量。执行该命令后在gen目录下就会生成R.java。\n\n2.编译java文件，生成class文件\n\n\tjavac -source 1.6 -target 1.7 -encoding UTF-8 -bootclasspath E:\\android-sdk\\android-sdk-windows\\android-sdk-windows\\platforms\\android-20\\android.jar -d bin -cp jar1;jar2;jar3 src\\com\\example\\Test\\*.java gen\\com\\example\\TestHehe\\R.java\t\n\n执行该命令后在bin目录下就会有对应的class文件。\n\n***注意：在上面说明提及到，我们生成的母包是不把R文件放到母包的代码里面，所以在这一步需要把R文件生成的class文件都要删除。***\n\n3.利用android自带dx工具将class转换为dex文件\n\n\tdx --dex --output=bin\\classes.dex bin libs\n\n该命令是指把bin目录下的class文件（第二步生成）和jar代码（这里是指libs文件夹下）生成class.dex，放到bin目录下。\n\n4.将所有资源打包生成apk文件（此时还没有dex代码）\n\n\taapt p -f -M AndroidManifest.xml -S res -A assets -I E:\\android-sdk\\android-sdk-windows\\android-sdk-windows\\platforms\\android-20\\android.jar -F bin\\test.apk\n\n执行该命令后，就是把所有资源文件打成一个apk，这时候是不包含代码（即classes.dex）。\n\n5.把dex代码文件打进刚生成的apk文件\n\n\taapt_win add E:\\GodSDKLetvMobileSDK\\bin\\test.apk bin\\classes.dex\n\n这一步就是把第三步生成的dex打进apk。至此，一个未签名的apk就打包成功了。下一步需要对该apk进行签名，这里就不再累赘，大家可自行google之。\n\n### 生成插件过程\n\n如上所述，这里需要做的只有三步：\n\n\t1. 合并第三方资源sdk的R文件并导出一个apk用作动态加载；\n\t2. 把每个需要集成的第三方sdk导出对应的仅有代码的apk（和第一步的apk一样，只有classes.dex文件，不包含资源）\n\t3. 合并第三方资源sdk生成的.ap_文件；\n\n第一步可以结合接管生成母包apk过程去搞，第二步可以直接利用开发工具生成的封装第三方apk，用zip打开apk删除除class.dex外的文件即可。这里重点说下第三步。\n\n### public.xml\n\n如何生成.ap_ 文件？其实生成命令和生成母包apk过程中的第四步一样，只要把生成bin目录下的apk改成.ap_ 即可，归根结底，apk和.ap_都是压缩包格式。然而，就用一个这么简单的命令就完成了？其实在测试过程中忽略了一个问题，我们处理的资源加载只是代码显式调用的加载，如果是其他地方的调用呢？类似资源layout文件或者AndroidManifest.xml中引用字符串@string或者样式@style，我们这种方式就处理不了，因为它并不是通过R.id.&&去引用资源，这样就有种蛋蛋的忧伤了。在以为要回到原点的时候，查阅老罗的 [Android应用程序资源的编译和打包过程分析](http://shyluo.blog.51cto.com/5725845/1229261) 一文提及到public.xml文件的作用，发现这个文件可以把资源id给固定下来。这样就提供了一种思路，既然我改变不了你，我就顺从你吧。只要我保证AndroidManifest.xml中引用的资源id不被改变，其他资源的id顺序就无关紧要了（因为都其他都可以通过R.id.&&方式去找到id）。贴上测试加上的public.xml文件示例：\n\n\t<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\t<resources>\n    \t<public type=\"drawable\" name=\"button_bg\" id=\"0x7f040001\" />\n    \t<public type=\"drawable\" name=\"ic_launcher\" id=\"0x7f040000\" />\n    \t<public type=\"drawable\" name=\"icon\" id=\"0x7f040002\" />\n    \n    \t<public type=\"style\" name=\"zypay_activity_fee\" id=\"0x7f030004\" />\n    \t<public type=\"style\" name=\"zypay_dlg_fullscreen\" id=\"0x7f030005\" />\n\t</resources>\n\n在这里大家可能会有疑惑，既然用public.xml可以把资源id固定，那倒不如直接把母包所有的资源id都固定一份，而保留原本android默认的引用资源常量的方式不是更好？经测试发现，public.xml文件并不能写入“id”这种类型，这种方式还是会在找“id”资源报错，尝试用ids.xml文件固定id也不能解决问题，具体原因待查，目前还是两者采用结合的方式。\n\n# 最后\n\n对比之前的动态加载方案，主要有以下优劣：\n\n1. 相比以前简单粗暴地直接把需要接入的第三方sdk所有资源加到母包资源，虽然优化方案无可避免地需要把AndroidManifest.xml声明引用的资源文件拷贝到母包，但是母包大小也是减小了不少；\n\n2. 优化方案主要修改了android查找资源机制，牺牲了效率，由于笔者测试的机型较少，出现的性能问题还需要进一步考证；\n\n3. 相比以前方案下发的仅是第三方的apk包（代码 + 资源），而优化后需要下发资源.ap_、R文件的apk和第三方apk（仅含代码），前后对比的下载流量还需要多测试;\n\n4. 由于母包并没有R.java文件，要谨慎处理没有下载第三方sdk相关或者下载过程中失败需要动态加载默认的R.java这个过程，不然整个程序就直接挂掉；相比之前的方案，即使没有动态加载成功游戏也可以正常运行。\n\n5. 优化方案可以避免getresources().getidentifier（R.id.**）这种引用资源方式的报错和不用考虑机型所带来的资源加载差异的兼容。\n\n6. 其实这种优化思想同样适用于当前资源热修复方案。我们知道，如果直接用google官方的InstantRun资源替换思想，仅仅是支持替换图片（而且文件名要一样）和在不影响原本资源id顺序前提下增删资源（因为热修复前的资源引用是固定的）。所以在InstantRun的资源加载基础上，动态加载新的R.java和修改资源引用方式，在热修复上应该都是可以正常走通。\n\n","source":"_posts/优化动态加载方案.md","raw":"title: 优化动态加载方案\ndate: 2016/9/10 12：53\n\ncategories:\n- Mobile\ntags:\n- android\n---\n\n# 前言\n\n在之前的动态加载方案中，是可以将多个apk（这里可以理解为封装的第三方sdk）模块进行动态加载。但在这里面有一个很蛋疼的问题，就是由于android系统底层对资源加载方式的不一样导致处理方式也不同，具体可参考 [那些年蘑菇街Android组件与插件化背后的故事 -- 插件篇(一)](http://mogu.io/117-117) ，在文章的最后提及到：<!-- more -->\n\n![](http://i.imgur.com/9di4nJj.png)\n\n所以以往对资源的处理只是简单地把第三方sdk的资源默认放到母包res下，这样母包包体依旧很大并未能做到正常的“动态”，而且针对代码存在getresources().getidentifier（R.id.**）这种加载方式还会造成混乱报错，并且不同系统的差异也可能需要做相应的处理。由于笔者对android底层和整套资源加载的模式不熟悉，所以在这个问题上一直找不到方向。直至微信推出自家的 [微信 Android 热补丁实践演进之路](http://www.tuicool.com/articles/uym2QrU) 一文中提及到google官方在AS上实现的热修复方案，看到不一样的资源加载方式。\n\n# InstantRun\n\n关于InstantRun的使用和原理在网上已经有不少的介绍（仅供参考：[Instant Run工作原理及用法](http://www.jianshu.com/p/2e23ba9ff14b) && [从Instant-Run出发，谈谈Android上的热修复](http://www.tuicool.com/articles/uQJjA3b)），这里就不再累赘。\n由于InstantRun的出发点是用于开发过程的热修复，所以有些技术点在这里是不需要我们做太多关注。笔者在研究过程中发现其有两大亮点，一是其加载代码方式，我们知道，以往做的动态加载是用参考了google官方MultiDex思想，在PathClassLoader的Element数组添加插件，是单classLoader策略，而InstantRun是采用多classLoader策略，做到不需要重启应用就可以把修复类加载进来；二是资源加载的方式，以往我们进行动态加载资源是在程序启动过程中把第三方的资源逐一添加到母包的AssetManager的path路径中，而InstantRun则是直接替换整份资源._ap文件，在程序启动过程中读取该文件。._ap文件其实就是一个压缩包，解压后：\n\n![](http://i.imgur.com/F87b3Cs.png)\n\n可以看到，其实就是一份资源包。我们能否在这种加载方式找到适合我们动态加载的方法呢？答案是肯定的。\n\n# 优化动态加载\n\n## 思路：\n\n以往的动态加载是以这种格式：\n\n\t母包：\n\t \t母包代码 + 母包资源 + 第三方资源 + 包含第三方声明AndroidManifest.xml\n\n\t插件（封装的第三方sdk）：\n\t\t插件代码 + 插件资源 + AndroidManifest.xml= .apk文件（其实就是整一份封装文件）\n\n这种方式的加载，已经验证代码动态加载是没有问题，目前如何处理资源呢？尝试以下格式：\n\n\t母包：\n\t \t母包代码（不包含R.java） + 母包资源（有可能加上第三方style等资源） + 包含第三方声明AndroidManifest.xml\n\n\t插件（不仅仅是封装的第三方sdk）：\n\t\t在本地依赖第三方sdk后的R文件（打成一个apk用作动态加载）；\n\t\t在本地依赖第三方sdk后的资源.ap_文件；\n\t\t插件代码 = .apk文件（仅含代码classes.dex的apk文件）；\n\t\t\n        \n\n## 说明：\n\n1. 由于AndroidManifest.xml在安装apk的时候就已经固定了（即使._ap文件有这个文件，但是做替换好像没效果）。所以，需要集成的sdk还是需要预写在母包的AndroidManifest.xml；\n\n2. 由于AndroidManifest.xml有第三方sdk的声明，所以一些Activity有可能会定义类似style格式，这时候在母包的资源如果没有引用的style资源文件就会编译不过，所以这些资源也必须预放在母包的AndroidManifest.xml下；\n\n3. [public.xml](http://stackoverflow.com/questions/9348614/what-is-the-use-of-the-res-values-public-xml-file-on-android)，这个文件一般在开发过程中比较少用到，但是我们反编译之后就会在res/values文件夹下看到，简单来说，这个文件是用来固定资源id，这里用到的作用后面再细说；\n\n4. 我们反编译apk后发现，原本代码写的资源引用类似R.id.&&都被一个字符串常量所替换了，这是为什么呢？细心点就会发现，这个常量值在aapt生成的R.java文件中是和资源一一对应的，在编译后这些资源引用都替换成常量，加快了查找资源的效率。但是这种优化在动态加载资源往往就容易出现问题，因为一旦这些值被固定了，后续添加的资源有可能会打乱之前的资源id对应关系，这样肯定会出现资源紊乱报错。因此，这里牺牲了效率，在aapt打包过程中不把代码中的资源引用固定，还是保留R.id.&&，这样在查找资源还是会从R文件里面找对应常量。\n\n5. 由于资源被统一成一份了，在资源查找过程用的R.java文件应该是新的一份，这样必须得采用动态加载R.java。在 [QQ空间实现热修复方案](https://mp.weixin.qq.com/s?__biz=MzI1MTA1MzM2Nw==&mid=400118620&idx=1&sn=b4fdd5055731290eef12ad0d17f39d4a) 中提及到，假如不对母包的R.java处理（母包还是有R.java），在动态加载的时候先把我们集成新的一份R.java加载，原本的R.java就不会加载到，但是用这种方式加载在5.0以下系统的手机会把不做处理的类打上***CLASS_ISPREVERIFIED***标志。所以，这里有两个思路，一是按照QQ空间方法使用字节码插入代码（比较保险），二是本例介绍的在编译母包apk的时候先把R.java抽出来再做动态加载。当然了，第二种方法为了保险起见，默认应该要把母包的R.java生成的apk放到类似assets目录下，保证即使没有集成新的R.java也可以正常运行。\n\n## 实践：\n\n这里随机选取了几个有代表性的封装第三方sdk进行测试（多米广告sdk、掌阅登陆和支付、话付宝综合支付），简要说说如何进行集成：\n\n### 接管母包生成过程\n\n针对业务的母包代码工程，在编译前先做几步处理：\n\n\t1. 把接入的第三方sdk的AndroidManifest.xml做拷贝；\n\t2. 查找拷贝后的AndroidManifest.xml是否包括引用的第三方资源文件，如果有，则进行相应资源文件拷贝。\n\n\n接下来就是命令行生成母包apk的介绍（可以用python脚本集成）：\n\n1.生成R文件\n\n\taapt p -f -m -J gen -S res -I E:\\android-sdk\\android-sdk-windows\\android-sdk-windows\\platforms\\android-20\\android.jar -M AndroidManifest.xml -A assets --non-constant-id\n\n--non-constant-id 很关键，加上这个参数代表R文件的资源声明不是final，即在后面编译代码中通过R.id.&& 引用的资源不会转换资源成id常量。执行该命令后在gen目录下就会生成R.java。\n\n2.编译java文件，生成class文件\n\n\tjavac -source 1.6 -target 1.7 -encoding UTF-8 -bootclasspath E:\\android-sdk\\android-sdk-windows\\android-sdk-windows\\platforms\\android-20\\android.jar -d bin -cp jar1;jar2;jar3 src\\com\\example\\Test\\*.java gen\\com\\example\\TestHehe\\R.java\t\n\n执行该命令后在bin目录下就会有对应的class文件。\n\n***注意：在上面说明提及到，我们生成的母包是不把R文件放到母包的代码里面，所以在这一步需要把R文件生成的class文件都要删除。***\n\n3.利用android自带dx工具将class转换为dex文件\n\n\tdx --dex --output=bin\\classes.dex bin libs\n\n该命令是指把bin目录下的class文件（第二步生成）和jar代码（这里是指libs文件夹下）生成class.dex，放到bin目录下。\n\n4.将所有资源打包生成apk文件（此时还没有dex代码）\n\n\taapt p -f -M AndroidManifest.xml -S res -A assets -I E:\\android-sdk\\android-sdk-windows\\android-sdk-windows\\platforms\\android-20\\android.jar -F bin\\test.apk\n\n执行该命令后，就是把所有资源文件打成一个apk，这时候是不包含代码（即classes.dex）。\n\n5.把dex代码文件打进刚生成的apk文件\n\n\taapt_win add E:\\GodSDKLetvMobileSDK\\bin\\test.apk bin\\classes.dex\n\n这一步就是把第三步生成的dex打进apk。至此，一个未签名的apk就打包成功了。下一步需要对该apk进行签名，这里就不再累赘，大家可自行google之。\n\n### 生成插件过程\n\n如上所述，这里需要做的只有三步：\n\n\t1. 合并第三方资源sdk的R文件并导出一个apk用作动态加载；\n\t2. 把每个需要集成的第三方sdk导出对应的仅有代码的apk（和第一步的apk一样，只有classes.dex文件，不包含资源）\n\t3. 合并第三方资源sdk生成的.ap_文件；\n\n第一步可以结合接管生成母包apk过程去搞，第二步可以直接利用开发工具生成的封装第三方apk，用zip打开apk删除除class.dex外的文件即可。这里重点说下第三步。\n\n### public.xml\n\n如何生成.ap_ 文件？其实生成命令和生成母包apk过程中的第四步一样，只要把生成bin目录下的apk改成.ap_ 即可，归根结底，apk和.ap_都是压缩包格式。然而，就用一个这么简单的命令就完成了？其实在测试过程中忽略了一个问题，我们处理的资源加载只是代码显式调用的加载，如果是其他地方的调用呢？类似资源layout文件或者AndroidManifest.xml中引用字符串@string或者样式@style，我们这种方式就处理不了，因为它并不是通过R.id.&&去引用资源，这样就有种蛋蛋的忧伤了。在以为要回到原点的时候，查阅老罗的 [Android应用程序资源的编译和打包过程分析](http://shyluo.blog.51cto.com/5725845/1229261) 一文提及到public.xml文件的作用，发现这个文件可以把资源id给固定下来。这样就提供了一种思路，既然我改变不了你，我就顺从你吧。只要我保证AndroidManifest.xml中引用的资源id不被改变，其他资源的id顺序就无关紧要了（因为都其他都可以通过R.id.&&方式去找到id）。贴上测试加上的public.xml文件示例：\n\n\t<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\t<resources>\n    \t<public type=\"drawable\" name=\"button_bg\" id=\"0x7f040001\" />\n    \t<public type=\"drawable\" name=\"ic_launcher\" id=\"0x7f040000\" />\n    \t<public type=\"drawable\" name=\"icon\" id=\"0x7f040002\" />\n    \n    \t<public type=\"style\" name=\"zypay_activity_fee\" id=\"0x7f030004\" />\n    \t<public type=\"style\" name=\"zypay_dlg_fullscreen\" id=\"0x7f030005\" />\n\t</resources>\n\n在这里大家可能会有疑惑，既然用public.xml可以把资源id固定，那倒不如直接把母包所有的资源id都固定一份，而保留原本android默认的引用资源常量的方式不是更好？经测试发现，public.xml文件并不能写入“id”这种类型，这种方式还是会在找“id”资源报错，尝试用ids.xml文件固定id也不能解决问题，具体原因待查，目前还是两者采用结合的方式。\n\n# 最后\n\n对比之前的动态加载方案，主要有以下优劣：\n\n1. 相比以前简单粗暴地直接把需要接入的第三方sdk所有资源加到母包资源，虽然优化方案无可避免地需要把AndroidManifest.xml声明引用的资源文件拷贝到母包，但是母包大小也是减小了不少；\n\n2. 优化方案主要修改了android查找资源机制，牺牲了效率，由于笔者测试的机型较少，出现的性能问题还需要进一步考证；\n\n3. 相比以前方案下发的仅是第三方的apk包（代码 + 资源），而优化后需要下发资源.ap_、R文件的apk和第三方apk（仅含代码），前后对比的下载流量还需要多测试;\n\n4. 由于母包并没有R.java文件，要谨慎处理没有下载第三方sdk相关或者下载过程中失败需要动态加载默认的R.java这个过程，不然整个程序就直接挂掉；相比之前的方案，即使没有动态加载成功游戏也可以正常运行。\n\n5. 优化方案可以避免getresources().getidentifier（R.id.**）这种引用资源方式的报错和不用考虑机型所带来的资源加载差异的兼容。\n\n6. 其实这种优化思想同样适用于当前资源热修复方案。我们知道，如果直接用google官方的InstantRun资源替换思想，仅仅是支持替换图片（而且文件名要一样）和在不影响原本资源id顺序前提下增删资源（因为热修复前的资源引用是固定的）。所以在InstantRun的资源加载基础上，动态加载新的R.java和修改资源引用方式，在热修复上应该都是可以正常走通。\n\n","slug":"优化动态加载方案","published":1,"updated":"2018-01-28T15:39:34.392Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjcyyg7kd000kniusnl79yvgi","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>在之前的动态加载方案中，是可以将多个apk（这里可以理解为封装的第三方sdk）模块进行动态加载。但在这里面有一个很蛋疼的问题，就是由于android系统底层对资源加载方式的不一样导致处理方式也不同，具体可参考 <a href=\"http://mogu.io/117-117\" target=\"_blank\" rel=\"noopener\">那些年蘑菇街Android组件与插件化背后的故事 – 插件篇(一)</a> ，在文章的最后提及到：<a id=\"more\"></a></p>\n<p><img src=\"http://i.imgur.com/9di4nJj.png\" alt=\"\"></p>\n<p>所以以往对资源的处理只是简单地把第三方sdk的资源默认放到母包res下，这样母包包体依旧很大并未能做到正常的“动态”，而且针对代码存在getresources().getidentifier（R.id.**）这种加载方式还会造成混乱报错，并且不同系统的差异也可能需要做相应的处理。由于笔者对android底层和整套资源加载的模式不熟悉，所以在这个问题上一直找不到方向。直至微信推出自家的 <a href=\"http://www.tuicool.com/articles/uym2QrU\" target=\"_blank\" rel=\"noopener\">微信 Android 热补丁实践演进之路</a> 一文中提及到google官方在AS上实现的热修复方案，看到不一样的资源加载方式。</p>\n<h1 id=\"InstantRun\"><a href=\"#InstantRun\" class=\"headerlink\" title=\"InstantRun\"></a>InstantRun</h1><p>关于InstantRun的使用和原理在网上已经有不少的介绍（仅供参考：<a href=\"http://www.jianshu.com/p/2e23ba9ff14b\" target=\"_blank\" rel=\"noopener\">Instant Run工作原理及用法</a> &amp;&amp; <a href=\"http://www.tuicool.com/articles/uQJjA3b\" target=\"_blank\" rel=\"noopener\">从Instant-Run出发，谈谈Android上的热修复</a>），这里就不再累赘。<br>由于InstantRun的出发点是用于开发过程的热修复，所以有些技术点在这里是不需要我们做太多关注。笔者在研究过程中发现其有两大亮点，一是其加载代码方式，我们知道，以往做的动态加载是用参考了google官方MultiDex思想，在PathClassLoader的Element数组添加插件，是单classLoader策略，而InstantRun是采用多classLoader策略，做到不需要重启应用就可以把修复类加载进来；二是资源加载的方式，以往我们进行动态加载资源是在程序启动过程中把第三方的资源逐一添加到母包的AssetManager的path路径中，而InstantRun则是直接替换整份资源._ap文件，在程序启动过程中读取该文件。._ap文件其实就是一个压缩包，解压后：</p>\n<p><img src=\"http://i.imgur.com/F87b3Cs.png\" alt=\"\"></p>\n<p>可以看到，其实就是一份资源包。我们能否在这种加载方式找到适合我们动态加载的方法呢？答案是肯定的。</p>\n<h1 id=\"优化动态加载\"><a href=\"#优化动态加载\" class=\"headerlink\" title=\"优化动态加载\"></a>优化动态加载</h1><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>以往的动态加载是以这种格式：</p>\n<pre><code>母包：\n     母包代码 + 母包资源 + 第三方资源 + 包含第三方声明AndroidManifest.xml\n\n插件（封装的第三方sdk）：\n    插件代码 + 插件资源 + AndroidManifest.xml= .apk文件（其实就是整一份封装文件）\n</code></pre><p>这种方式的加载，已经验证代码动态加载是没有问题，目前如何处理资源呢？尝试以下格式：</p>\n<pre><code>母包：\n     母包代码（不包含R.java） + 母包资源（有可能加上第三方style等资源） + 包含第三方声明AndroidManifest.xml\n\n插件（不仅仅是封装的第三方sdk）：\n    在本地依赖第三方sdk后的R文件（打成一个apk用作动态加载）；\n    在本地依赖第三方sdk后的资源.ap_文件；\n    插件代码 = .apk文件（仅含代码classes.dex的apk文件）；\n</code></pre><h2 id=\"说明：\"><a href=\"#说明：\" class=\"headerlink\" title=\"说明：\"></a>说明：</h2><ol>\n<li><p>由于AndroidManifest.xml在安装apk的时候就已经固定了（即使._ap文件有这个文件，但是做替换好像没效果）。所以，需要集成的sdk还是需要预写在母包的AndroidManifest.xml；</p>\n</li>\n<li><p>由于AndroidManifest.xml有第三方sdk的声明，所以一些Activity有可能会定义类似style格式，这时候在母包的资源如果没有引用的style资源文件就会编译不过，所以这些资源也必须预放在母包的AndroidManifest.xml下；</p>\n</li>\n<li><p><a href=\"http://stackoverflow.com/questions/9348614/what-is-the-use-of-the-res-values-public-xml-file-on-android\" target=\"_blank\" rel=\"noopener\">public.xml</a>，这个文件一般在开发过程中比较少用到，但是我们反编译之后就会在res/values文件夹下看到，简单来说，这个文件是用来固定资源id，这里用到的作用后面再细说；</p>\n</li>\n<li><p>我们反编译apk后发现，原本代码写的资源引用类似R.id.&amp;&amp;都被一个字符串常量所替换了，这是为什么呢？细心点就会发现，这个常量值在aapt生成的R.java文件中是和资源一一对应的，在编译后这些资源引用都替换成常量，加快了查找资源的效率。但是这种优化在动态加载资源往往就容易出现问题，因为一旦这些值被固定了，后续添加的资源有可能会打乱之前的资源id对应关系，这样肯定会出现资源紊乱报错。因此，这里牺牲了效率，在aapt打包过程中不把代码中的资源引用固定，还是保留R.id.&amp;&amp;，这样在查找资源还是会从R文件里面找对应常量。</p>\n</li>\n<li><p>由于资源被统一成一份了，在资源查找过程用的R.java文件应该是新的一份，这样必须得采用动态加载R.java。在 <a href=\"https://mp.weixin.qq.com/s?__biz=MzI1MTA1MzM2Nw==&amp;mid=400118620&amp;idx=1&amp;sn=b4fdd5055731290eef12ad0d17f39d4a\" target=\"_blank\" rel=\"noopener\">QQ空间实现热修复方案</a> 中提及到，假如不对母包的R.java处理（母包还是有R.java），在动态加载的时候先把我们集成新的一份R.java加载，原本的R.java就不会加载到，但是用这种方式加载在5.0以下系统的手机会把不做处理的类打上<strong><em>CLASS_ISPREVERIFIED</em></strong>标志。所以，这里有两个思路，一是按照QQ空间方法使用字节码插入代码（比较保险），二是本例介绍的在编译母包apk的时候先把R.java抽出来再做动态加载。当然了，第二种方法为了保险起见，默认应该要把母包的R.java生成的apk放到类似assets目录下，保证即使没有集成新的R.java也可以正常运行。</p>\n</li>\n</ol>\n<h2 id=\"实践：\"><a href=\"#实践：\" class=\"headerlink\" title=\"实践：\"></a>实践：</h2><p>这里随机选取了几个有代表性的封装第三方sdk进行测试（多米广告sdk、掌阅登陆和支付、话付宝综合支付），简要说说如何进行集成：</p>\n<h3 id=\"接管母包生成过程\"><a href=\"#接管母包生成过程\" class=\"headerlink\" title=\"接管母包生成过程\"></a>接管母包生成过程</h3><p>针对业务的母包代码工程，在编译前先做几步处理：</p>\n<pre><code>1. 把接入的第三方sdk的AndroidManifest.xml做拷贝；\n2. 查找拷贝后的AndroidManifest.xml是否包括引用的第三方资源文件，如果有，则进行相应资源文件拷贝。\n</code></pre><p>接下来就是命令行生成母包apk的介绍（可以用python脚本集成）：</p>\n<p>1.生成R文件</p>\n<pre><code>aapt p -f -m -J gen -S res -I E:\\android-sdk\\android-sdk-windows\\android-sdk-windows\\platforms\\android-20\\android.jar -M AndroidManifest.xml -A assets --non-constant-id\n</code></pre><p>–non-constant-id 很关键，加上这个参数代表R文件的资源声明不是final，即在后面编译代码中通过R.id.&amp;&amp; 引用的资源不会转换资源成id常量。执行该命令后在gen目录下就会生成R.java。</p>\n<p>2.编译java文件，生成class文件</p>\n<pre><code>javac -source 1.6 -target 1.7 -encoding UTF-8 -bootclasspath E:\\android-sdk\\android-sdk-windows\\android-sdk-windows\\platforms\\android-20\\android.jar -d bin -cp jar1;jar2;jar3 src\\com\\example\\Test\\*.java gen\\com\\example\\TestHehe\\R.java    \n</code></pre><p>执行该命令后在bin目录下就会有对应的class文件。</p>\n<p><strong><em>注意：在上面说明提及到，我们生成的母包是不把R文件放到母包的代码里面，所以在这一步需要把R文件生成的class文件都要删除。</em></strong></p>\n<p>3.利用android自带dx工具将class转换为dex文件</p>\n<pre><code>dx --dex --output=bin\\classes.dex bin libs\n</code></pre><p>该命令是指把bin目录下的class文件（第二步生成）和jar代码（这里是指libs文件夹下）生成class.dex，放到bin目录下。</p>\n<p>4.将所有资源打包生成apk文件（此时还没有dex代码）</p>\n<pre><code>aapt p -f -M AndroidManifest.xml -S res -A assets -I E:\\android-sdk\\android-sdk-windows\\android-sdk-windows\\platforms\\android-20\\android.jar -F bin\\test.apk\n</code></pre><p>执行该命令后，就是把所有资源文件打成一个apk，这时候是不包含代码（即classes.dex）。</p>\n<p>5.把dex代码文件打进刚生成的apk文件</p>\n<pre><code>aapt_win add E:\\GodSDKLetvMobileSDK\\bin\\test.apk bin\\classes.dex\n</code></pre><p>这一步就是把第三步生成的dex打进apk。至此，一个未签名的apk就打包成功了。下一步需要对该apk进行签名，这里就不再累赘，大家可自行google之。</p>\n<h3 id=\"生成插件过程\"><a href=\"#生成插件过程\" class=\"headerlink\" title=\"生成插件过程\"></a>生成插件过程</h3><p>如上所述，这里需要做的只有三步：</p>\n<pre><code>1. 合并第三方资源sdk的R文件并导出一个apk用作动态加载；\n2. 把每个需要集成的第三方sdk导出对应的仅有代码的apk（和第一步的apk一样，只有classes.dex文件，不包含资源）\n3. 合并第三方资源sdk生成的.ap_文件；\n</code></pre><p>第一步可以结合接管生成母包apk过程去搞，第二步可以直接利用开发工具生成的封装第三方apk，用zip打开apk删除除class.dex外的文件即可。这里重点说下第三步。</p>\n<h3 id=\"public-xml\"><a href=\"#public-xml\" class=\"headerlink\" title=\"public.xml\"></a>public.xml</h3><p>如何生成.ap<em> 文件？其实生成命令和生成母包apk过程中的第四步一样，只要把生成bin目录下的apk改成.ap</em> 即可，归根结底，apk和.ap_都是压缩包格式。然而，就用一个这么简单的命令就完成了？其实在测试过程中忽略了一个问题，我们处理的资源加载只是代码显式调用的加载，如果是其他地方的调用呢？类似资源layout文件或者AndroidManifest.xml中引用字符串@string或者样式@style，我们这种方式就处理不了，因为它并不是通过R.id.&amp;&amp;去引用资源，这样就有种蛋蛋的忧伤了。在以为要回到原点的时候，查阅老罗的 <a href=\"http://shyluo.blog.51cto.com/5725845/1229261\" target=\"_blank\" rel=\"noopener\">Android应用程序资源的编译和打包过程分析</a> 一文提及到public.xml文件的作用，发现这个文件可以把资源id给固定下来。这样就提供了一种思路，既然我改变不了你，我就顺从你吧。只要我保证AndroidManifest.xml中引用的资源id不被改变，其他资源的id顺序就无关紧要了（因为都其他都可以通过R.id.&amp;&amp;方式去找到id）。贴上测试加上的public.xml文件示例：</p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;resources&gt;\n    &lt;public type=&quot;drawable&quot; name=&quot;button_bg&quot; id=&quot;0x7f040001&quot; /&gt;\n    &lt;public type=&quot;drawable&quot; name=&quot;ic_launcher&quot; id=&quot;0x7f040000&quot; /&gt;\n    &lt;public type=&quot;drawable&quot; name=&quot;icon&quot; id=&quot;0x7f040002&quot; /&gt;\n\n    &lt;public type=&quot;style&quot; name=&quot;zypay_activity_fee&quot; id=&quot;0x7f030004&quot; /&gt;\n    &lt;public type=&quot;style&quot; name=&quot;zypay_dlg_fullscreen&quot; id=&quot;0x7f030005&quot; /&gt;\n&lt;/resources&gt;\n</code></pre><p>在这里大家可能会有疑惑，既然用public.xml可以把资源id固定，那倒不如直接把母包所有的资源id都固定一份，而保留原本android默认的引用资源常量的方式不是更好？经测试发现，public.xml文件并不能写入“id”这种类型，这种方式还是会在找“id”资源报错，尝试用ids.xml文件固定id也不能解决问题，具体原因待查，目前还是两者采用结合的方式。</p>\n<h1 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h1><p>对比之前的动态加载方案，主要有以下优劣：</p>\n<ol>\n<li><p>相比以前简单粗暴地直接把需要接入的第三方sdk所有资源加到母包资源，虽然优化方案无可避免地需要把AndroidManifest.xml声明引用的资源文件拷贝到母包，但是母包大小也是减小了不少；</p>\n</li>\n<li><p>优化方案主要修改了android查找资源机制，牺牲了效率，由于笔者测试的机型较少，出现的性能问题还需要进一步考证；</p>\n</li>\n<li><p>相比以前方案下发的仅是第三方的apk包（代码 + 资源），而优化后需要下发资源.ap_、R文件的apk和第三方apk（仅含代码），前后对比的下载流量还需要多测试;</p>\n</li>\n<li><p>由于母包并没有R.java文件，要谨慎处理没有下载第三方sdk相关或者下载过程中失败需要动态加载默认的R.java这个过程，不然整个程序就直接挂掉；相比之前的方案，即使没有动态加载成功游戏也可以正常运行。</p>\n</li>\n<li><p>优化方案可以避免getresources().getidentifier（R.id.**）这种引用资源方式的报错和不用考虑机型所带来的资源加载差异的兼容。</p>\n</li>\n<li><p>其实这种优化思想同样适用于当前资源热修复方案。我们知道，如果直接用google官方的InstantRun资源替换思想，仅仅是支持替换图片（而且文件名要一样）和在不影响原本资源id顺序前提下增删资源（因为热修复前的资源引用是固定的）。所以在InstantRun的资源加载基础上，动态加载新的R.java和修改资源引用方式，在热修复上应该都是可以正常走通。</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>在之前的动态加载方案中，是可以将多个apk（这里可以理解为封装的第三方sdk）模块进行动态加载。但在这里面有一个很蛋疼的问题，就是由于android系统底层对资源加载方式的不一样导致处理方式也不同，具体可参考 <a href=\"http://mogu.io/117-117\" target=\"_blank\" rel=\"noopener\">那些年蘑菇街Android组件与插件化背后的故事 – 插件篇(一)</a> ，在文章的最后提及到：","more":"</p>\n<p><img src=\"http://i.imgur.com/9di4nJj.png\" alt=\"\"></p>\n<p>所以以往对资源的处理只是简单地把第三方sdk的资源默认放到母包res下，这样母包包体依旧很大并未能做到正常的“动态”，而且针对代码存在getresources().getidentifier（R.id.**）这种加载方式还会造成混乱报错，并且不同系统的差异也可能需要做相应的处理。由于笔者对android底层和整套资源加载的模式不熟悉，所以在这个问题上一直找不到方向。直至微信推出自家的 <a href=\"http://www.tuicool.com/articles/uym2QrU\" target=\"_blank\" rel=\"noopener\">微信 Android 热补丁实践演进之路</a> 一文中提及到google官方在AS上实现的热修复方案，看到不一样的资源加载方式。</p>\n<h1 id=\"InstantRun\"><a href=\"#InstantRun\" class=\"headerlink\" title=\"InstantRun\"></a>InstantRun</h1><p>关于InstantRun的使用和原理在网上已经有不少的介绍（仅供参考：<a href=\"http://www.jianshu.com/p/2e23ba9ff14b\" target=\"_blank\" rel=\"noopener\">Instant Run工作原理及用法</a> &amp;&amp; <a href=\"http://www.tuicool.com/articles/uQJjA3b\" target=\"_blank\" rel=\"noopener\">从Instant-Run出发，谈谈Android上的热修复</a>），这里就不再累赘。<br>由于InstantRun的出发点是用于开发过程的热修复，所以有些技术点在这里是不需要我们做太多关注。笔者在研究过程中发现其有两大亮点，一是其加载代码方式，我们知道，以往做的动态加载是用参考了google官方MultiDex思想，在PathClassLoader的Element数组添加插件，是单classLoader策略，而InstantRun是采用多classLoader策略，做到不需要重启应用就可以把修复类加载进来；二是资源加载的方式，以往我们进行动态加载资源是在程序启动过程中把第三方的资源逐一添加到母包的AssetManager的path路径中，而InstantRun则是直接替换整份资源._ap文件，在程序启动过程中读取该文件。._ap文件其实就是一个压缩包，解压后：</p>\n<p><img src=\"http://i.imgur.com/F87b3Cs.png\" alt=\"\"></p>\n<p>可以看到，其实就是一份资源包。我们能否在这种加载方式找到适合我们动态加载的方法呢？答案是肯定的。</p>\n<h1 id=\"优化动态加载\"><a href=\"#优化动态加载\" class=\"headerlink\" title=\"优化动态加载\"></a>优化动态加载</h1><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>以往的动态加载是以这种格式：</p>\n<pre><code>母包：\n     母包代码 + 母包资源 + 第三方资源 + 包含第三方声明AndroidManifest.xml\n\n插件（封装的第三方sdk）：\n    插件代码 + 插件资源 + AndroidManifest.xml= .apk文件（其实就是整一份封装文件）\n</code></pre><p>这种方式的加载，已经验证代码动态加载是没有问题，目前如何处理资源呢？尝试以下格式：</p>\n<pre><code>母包：\n     母包代码（不包含R.java） + 母包资源（有可能加上第三方style等资源） + 包含第三方声明AndroidManifest.xml\n\n插件（不仅仅是封装的第三方sdk）：\n    在本地依赖第三方sdk后的R文件（打成一个apk用作动态加载）；\n    在本地依赖第三方sdk后的资源.ap_文件；\n    插件代码 = .apk文件（仅含代码classes.dex的apk文件）；\n</code></pre><h2 id=\"说明：\"><a href=\"#说明：\" class=\"headerlink\" title=\"说明：\"></a>说明：</h2><ol>\n<li><p>由于AndroidManifest.xml在安装apk的时候就已经固定了（即使._ap文件有这个文件，但是做替换好像没效果）。所以，需要集成的sdk还是需要预写在母包的AndroidManifest.xml；</p>\n</li>\n<li><p>由于AndroidManifest.xml有第三方sdk的声明，所以一些Activity有可能会定义类似style格式，这时候在母包的资源如果没有引用的style资源文件就会编译不过，所以这些资源也必须预放在母包的AndroidManifest.xml下；</p>\n</li>\n<li><p><a href=\"http://stackoverflow.com/questions/9348614/what-is-the-use-of-the-res-values-public-xml-file-on-android\" target=\"_blank\" rel=\"noopener\">public.xml</a>，这个文件一般在开发过程中比较少用到，但是我们反编译之后就会在res/values文件夹下看到，简单来说，这个文件是用来固定资源id，这里用到的作用后面再细说；</p>\n</li>\n<li><p>我们反编译apk后发现，原本代码写的资源引用类似R.id.&amp;&amp;都被一个字符串常量所替换了，这是为什么呢？细心点就会发现，这个常量值在aapt生成的R.java文件中是和资源一一对应的，在编译后这些资源引用都替换成常量，加快了查找资源的效率。但是这种优化在动态加载资源往往就容易出现问题，因为一旦这些值被固定了，后续添加的资源有可能会打乱之前的资源id对应关系，这样肯定会出现资源紊乱报错。因此，这里牺牲了效率，在aapt打包过程中不把代码中的资源引用固定，还是保留R.id.&amp;&amp;，这样在查找资源还是会从R文件里面找对应常量。</p>\n</li>\n<li><p>由于资源被统一成一份了，在资源查找过程用的R.java文件应该是新的一份，这样必须得采用动态加载R.java。在 <a href=\"https://mp.weixin.qq.com/s?__biz=MzI1MTA1MzM2Nw==&amp;mid=400118620&amp;idx=1&amp;sn=b4fdd5055731290eef12ad0d17f39d4a\" target=\"_blank\" rel=\"noopener\">QQ空间实现热修复方案</a> 中提及到，假如不对母包的R.java处理（母包还是有R.java），在动态加载的时候先把我们集成新的一份R.java加载，原本的R.java就不会加载到，但是用这种方式加载在5.0以下系统的手机会把不做处理的类打上<strong><em>CLASS_ISPREVERIFIED</em></strong>标志。所以，这里有两个思路，一是按照QQ空间方法使用字节码插入代码（比较保险），二是本例介绍的在编译母包apk的时候先把R.java抽出来再做动态加载。当然了，第二种方法为了保险起见，默认应该要把母包的R.java生成的apk放到类似assets目录下，保证即使没有集成新的R.java也可以正常运行。</p>\n</li>\n</ol>\n<h2 id=\"实践：\"><a href=\"#实践：\" class=\"headerlink\" title=\"实践：\"></a>实践：</h2><p>这里随机选取了几个有代表性的封装第三方sdk进行测试（多米广告sdk、掌阅登陆和支付、话付宝综合支付），简要说说如何进行集成：</p>\n<h3 id=\"接管母包生成过程\"><a href=\"#接管母包生成过程\" class=\"headerlink\" title=\"接管母包生成过程\"></a>接管母包生成过程</h3><p>针对业务的母包代码工程，在编译前先做几步处理：</p>\n<pre><code>1. 把接入的第三方sdk的AndroidManifest.xml做拷贝；\n2. 查找拷贝后的AndroidManifest.xml是否包括引用的第三方资源文件，如果有，则进行相应资源文件拷贝。\n</code></pre><p>接下来就是命令行生成母包apk的介绍（可以用python脚本集成）：</p>\n<p>1.生成R文件</p>\n<pre><code>aapt p -f -m -J gen -S res -I E:\\android-sdk\\android-sdk-windows\\android-sdk-windows\\platforms\\android-20\\android.jar -M AndroidManifest.xml -A assets --non-constant-id\n</code></pre><p>–non-constant-id 很关键，加上这个参数代表R文件的资源声明不是final，即在后面编译代码中通过R.id.&amp;&amp; 引用的资源不会转换资源成id常量。执行该命令后在gen目录下就会生成R.java。</p>\n<p>2.编译java文件，生成class文件</p>\n<pre><code>javac -source 1.6 -target 1.7 -encoding UTF-8 -bootclasspath E:\\android-sdk\\android-sdk-windows\\android-sdk-windows\\platforms\\android-20\\android.jar -d bin -cp jar1;jar2;jar3 src\\com\\example\\Test\\*.java gen\\com\\example\\TestHehe\\R.java    \n</code></pre><p>执行该命令后在bin目录下就会有对应的class文件。</p>\n<p><strong><em>注意：在上面说明提及到，我们生成的母包是不把R文件放到母包的代码里面，所以在这一步需要把R文件生成的class文件都要删除。</em></strong></p>\n<p>3.利用android自带dx工具将class转换为dex文件</p>\n<pre><code>dx --dex --output=bin\\classes.dex bin libs\n</code></pre><p>该命令是指把bin目录下的class文件（第二步生成）和jar代码（这里是指libs文件夹下）生成class.dex，放到bin目录下。</p>\n<p>4.将所有资源打包生成apk文件（此时还没有dex代码）</p>\n<pre><code>aapt p -f -M AndroidManifest.xml -S res -A assets -I E:\\android-sdk\\android-sdk-windows\\android-sdk-windows\\platforms\\android-20\\android.jar -F bin\\test.apk\n</code></pre><p>执行该命令后，就是把所有资源文件打成一个apk，这时候是不包含代码（即classes.dex）。</p>\n<p>5.把dex代码文件打进刚生成的apk文件</p>\n<pre><code>aapt_win add E:\\GodSDKLetvMobileSDK\\bin\\test.apk bin\\classes.dex\n</code></pre><p>这一步就是把第三步生成的dex打进apk。至此，一个未签名的apk就打包成功了。下一步需要对该apk进行签名，这里就不再累赘，大家可自行google之。</p>\n<h3 id=\"生成插件过程\"><a href=\"#生成插件过程\" class=\"headerlink\" title=\"生成插件过程\"></a>生成插件过程</h3><p>如上所述，这里需要做的只有三步：</p>\n<pre><code>1. 合并第三方资源sdk的R文件并导出一个apk用作动态加载；\n2. 把每个需要集成的第三方sdk导出对应的仅有代码的apk（和第一步的apk一样，只有classes.dex文件，不包含资源）\n3. 合并第三方资源sdk生成的.ap_文件；\n</code></pre><p>第一步可以结合接管生成母包apk过程去搞，第二步可以直接利用开发工具生成的封装第三方apk，用zip打开apk删除除class.dex外的文件即可。这里重点说下第三步。</p>\n<h3 id=\"public-xml\"><a href=\"#public-xml\" class=\"headerlink\" title=\"public.xml\"></a>public.xml</h3><p>如何生成.ap<em> 文件？其实生成命令和生成母包apk过程中的第四步一样，只要把生成bin目录下的apk改成.ap</em> 即可，归根结底，apk和.ap_都是压缩包格式。然而，就用一个这么简单的命令就完成了？其实在测试过程中忽略了一个问题，我们处理的资源加载只是代码显式调用的加载，如果是其他地方的调用呢？类似资源layout文件或者AndroidManifest.xml中引用字符串@string或者样式@style，我们这种方式就处理不了，因为它并不是通过R.id.&amp;&amp;去引用资源，这样就有种蛋蛋的忧伤了。在以为要回到原点的时候，查阅老罗的 <a href=\"http://shyluo.blog.51cto.com/5725845/1229261\" target=\"_blank\" rel=\"noopener\">Android应用程序资源的编译和打包过程分析</a> 一文提及到public.xml文件的作用，发现这个文件可以把资源id给固定下来。这样就提供了一种思路，既然我改变不了你，我就顺从你吧。只要我保证AndroidManifest.xml中引用的资源id不被改变，其他资源的id顺序就无关紧要了（因为都其他都可以通过R.id.&amp;&amp;方式去找到id）。贴上测试加上的public.xml文件示例：</p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;resources&gt;\n    &lt;public type=&quot;drawable&quot; name=&quot;button_bg&quot; id=&quot;0x7f040001&quot; /&gt;\n    &lt;public type=&quot;drawable&quot; name=&quot;ic_launcher&quot; id=&quot;0x7f040000&quot; /&gt;\n    &lt;public type=&quot;drawable&quot; name=&quot;icon&quot; id=&quot;0x7f040002&quot; /&gt;\n\n    &lt;public type=&quot;style&quot; name=&quot;zypay_activity_fee&quot; id=&quot;0x7f030004&quot; /&gt;\n    &lt;public type=&quot;style&quot; name=&quot;zypay_dlg_fullscreen&quot; id=&quot;0x7f030005&quot; /&gt;\n&lt;/resources&gt;\n</code></pre><p>在这里大家可能会有疑惑，既然用public.xml可以把资源id固定，那倒不如直接把母包所有的资源id都固定一份，而保留原本android默认的引用资源常量的方式不是更好？经测试发现，public.xml文件并不能写入“id”这种类型，这种方式还是会在找“id”资源报错，尝试用ids.xml文件固定id也不能解决问题，具体原因待查，目前还是两者采用结合的方式。</p>\n<h1 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h1><p>对比之前的动态加载方案，主要有以下优劣：</p>\n<ol>\n<li><p>相比以前简单粗暴地直接把需要接入的第三方sdk所有资源加到母包资源，虽然优化方案无可避免地需要把AndroidManifest.xml声明引用的资源文件拷贝到母包，但是母包大小也是减小了不少；</p>\n</li>\n<li><p>优化方案主要修改了android查找资源机制，牺牲了效率，由于笔者测试的机型较少，出现的性能问题还需要进一步考证；</p>\n</li>\n<li><p>相比以前方案下发的仅是第三方的apk包（代码 + 资源），而优化后需要下发资源.ap_、R文件的apk和第三方apk（仅含代码），前后对比的下载流量还需要多测试;</p>\n</li>\n<li><p>由于母包并没有R.java文件，要谨慎处理没有下载第三方sdk相关或者下载过程中失败需要动态加载默认的R.java这个过程，不然整个程序就直接挂掉；相比之前的方案，即使没有动态加载成功游戏也可以正常运行。</p>\n</li>\n<li><p>优化方案可以避免getresources().getidentifier（R.id.**）这种引用资源方式的报错和不用考虑机型所带来的资源加载差异的兼容。</p>\n</li>\n<li><p>其实这种优化思想同样适用于当前资源热修复方案。我们知道，如果直接用google官方的InstantRun资源替换思想，仅仅是支持替换图片（而且文件名要一样）和在不影响原本资源id顺序前提下增删资源（因为热修复前的资源引用是固定的）。所以在InstantRun的资源加载基础上，动态加载新的R.java和修改资源引用方式，在热修复上应该都是可以正常走通。</p>\n</li>\n</ol>"},{"title":"微信Tinker资源热修复解析","date":"2018-01-28T15:39:34.392Z","_content":"\n\n# 前言\n\n微信的热修复框架 [Tinker](https://github.com/Tencent/tinker) 开源已有一段时间了，同时他们也配套地开放了一个免费的 [补丁后台](http://www.tinkerpatch.com/) 供我们完整地体验了整个热修复流程，根据详细的文档和demo演示接入，目前的使用已经趋于稳定。相比当前比较热门的热修复框架，Tinker对于开发者而言是更加透明而且容易理解。<!-- more -->俗话说，工欲善其事必先利其器。既然Tinker的源码已经开放，就不能单单地停留在使用的层面上，遇到问题看文档也不能根本解决问题，所以，窥探Tinker内部实现原理，可以在接入过程出现问题较快定位，而且了解实现原理对于自身的学习也是有很大帮助。\n\n# 说明\n\nTinker是支持代码、资源和lib（so）层面上的修复，个人认为，代码层面的修复采用微信自研的dexDiff才是Tinker的核心。由于笔者对dex的结构还没熟悉，所以这里不针对代码修复流程进行解析，[Tinker Dexdiff算法解析](https://www.zybuluo.com/dodola/note/554061) 一文对其中dexDiff解析还是比较详尽，前提条件下对dex结构和bytecode有了解才可以阅读下去。本文主要解析的是Tinker实现资源修复流程。\n\n# 思路\n\nTinker文档上主要演示的是如何在AS通过gradle来构建生成patch包，同时也有介绍如何通过tinker-patch-cli.jar命令行去生成patch。下载Tinker的源码，工程结构：\n\n![](http://i.imgur.com/xaIhAsb.png)\n\n其中，工程tinker-build正是tinker-patch-cli.jar的构建代码：\n\n![](http://i.imgur.com/4xPMJ6e.png)\n\nCliMain.java正是入口类。\n\n## 解析输入参数和tinker_config.xml\n\nTalk is cheap，show me the code. 打开CliMain.java，入口main方法：\n\n![](http://i.imgur.com/uxmG7tQ.png)\n\n这里首先获取当前运行命令行的目录，以便后续没有指定output等做拼凑，然后开始解析输入参数。解析完一系列参数后：\n\n![](http://i.imgur.com/uqjpzqd.png)\n\n这里面做了三件事，首先，解析tinker_config.xml文件，这个文件在tinker-build的tool_output下有，当然，可以根据自己的需要去定制条件。由于本文主要介绍资源patch，所以只看资源条件:\n\n![](http://i.imgur.com/HbzJQMl.png)\n\npattern指定要做patch的指定文件，ignoreChange指定你不想做patch的文件（即使前后发生改变也过滤不做patch），largeModSize指定做bsdiff的阈值。\n\n解析完tinker_config.xml，定义输出文件的logger；然后开始做patch。\n\n## tinkerPatch\n\ntinkerPatch方法笔者认为可以分成三部分进行分析。第一部分是patch的核心，当然包含资源、代码和libs的patch；第二部分是生成配置文件，主要是对配置的tinkerId和一些patch信息的输出记录；第三部分则是生成patch包，具体代码：\n\n![](http://i.imgur.com/h3gHyJp.png)\n\n下面重点解析第一部分。\n\n### AndroidManifest check，水很深\n\n跟代码进到decoder.patch，看到这一行\n\n\t//check manifest change first\n    manifestDecoder.patch(oldFile, newFile);\n\n事实上，这简单的一句check manifest change，里面涉及要了解的东西不少，跟进去看：\n\n![](http://i.imgur.com/MFdoKc5.png)\n\n这里获取新旧apk的mainfest信息，定义AndroidParser对象，保存解析得到的四大组件和metaData标签等信息，还有通过各种转义解析得到整一份AndroidMainfest的string返回，他们对应的核心类均是继承自XmlStreamer的ApkMetaTranslator和XmlTranslator。\n\n - 如果要具体深入了解里面的解析原理，必须得对Android的resource.arsc和AndroidManifest.xml文件的二进制格式有一定了解，当然还涉及escapeXml10等转义知识，不然基本上读着读着就懵逼。By the way，你大可不用去了解其解析，因为笔者在了解其解析Manifest的ResourceId Chunk读取的/r_values.ini文件时发现，其实这里的解析用到的是github上一个开源项目，Tinker应该是在此基础上加以修改完善。\n - 有兴趣的同学可以去了解下：https://github.com/clearthesky/apk-parser。当然，你也可以直接在jcenter搜索Tinker定制的apk-parser-lib。\n\n接下来在获取到的AndroidManifest解析信息后，对minSdkVersion进行判断处理，主要是对config输入的ignoreWarning进行风险规避，这个在Tinker的wiki上也有说明：\n\n![](http://i.imgur.com/jxzFFey.png)\n\n这里是针对第一种情况处理，后面对ignoreWarning的判断将不再说明。</br>\n最后则是将新旧的AndroidMainfest的标签信息进行一一比对，如果ignoreWarning为false，则抛出异常。因为目前Tinker还不支持AndroidMainfest的热修复。\n\n### 资源文件对比筛选\n\n通过对AndroidMainfest的新旧对比之后，如果对比成功则开始进行资源文件的对比筛选：\n\n\tFiles.walkFileTree(mNewApkDir.toPath(), new ApkFilesVisitor(config, mNewApkDir.toPath(), mOldApkDir.toPath(), dexPatchDecoder, soPatchDecoder, resPatchDecoder));\n\n跟进ApkFilesVisitor的visitFile方法，跳过代码和libs的patch，直接到资源patch：\n\n![](http://i.imgur.com/TZguPmv.png)\n\n资源patch在ResDiffDecoder类中的patch方法中实现，其主要是做了以下工作:\n\n1. 解压后的新旧apk中，oldFile对应的newFile不存在，则认为新的apk对oldFile资源删除，保存在deletedSet中（正如其注释上说的，这段代码永远不会走，所以没有任何实质作用，deletedSet下面会重新添加成员）；\n2. 解压后的新旧apk中，newFile对应的oldFile不存在，则认为新的apk新添了newFile资源，保存在addedSet中，并且把newFile拷贝到tinker_result目录下；\n3. 如果不存在上述两种情况，而且oldFile和newFile存在，对比oldFile和newFile的md5，相同则认为该资源文件没有做任何修改，直接返回；\n4. 如果该文件不在指定的ignoreChangePattern清单里，并且不是AndroidMainfest.xml文件，走到这里：\n\n![](http://i.imgur.com/moYNpBO.png)\n\n假如该文件是resources.arsc，开始进行新旧resources.arsc的对比。如果之前有阅读过 [Resource.arsc文件格式](https://hellokugo.github.io/2016/09/03/Resource.arsc%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/) 这篇文章，这里理解应该不难。要注意的是，每个chunk的headSize对应着不同的位置大小。最后则是重定义equals方法去比较各个chunk是否一致：\n\n![](http://i.imgur.com/VmVebFg.png)\t\n\n5.如果在进行上述4步还没有return，说明新旧apk都存在该资源文件，并且有做修改：\n\n![](http://i.imgur.com/sfvXFcX.png)\n\n这里首先判断该文件是否大于指定的largeModSize，这个在config可以指定，如果是大于该值，用bsDiff算法得到newFile，并保存在largeModifiedSet中；如果小于该largeModSize，直接保存在modifiedSet，并拷贝到tinker_result目录下。\n\n### 解压修改文件\n\n其实上述生成步骤走完，tinker_result就是最终的patch包，而接下来要做的是配置文件的写入，大体上和客户端合patch流程是一致的。跟代码走到\n\n\tresPatchDecoder.onAllPatchesEnd();\n\n具体处理在ResDiffDecoder类中的onAllPatchesEnd方法中实现，其主要是做了以下工作:\n\n1. 对pattern的文件判断和返回的筛选patch文件判空进行处理；\n2. 判断是否用gradle构建生成patch，这里分析命令行生成patch，所以里面逻辑跳过；\n3. 重新对返回的patch保存进行筛选，具体是\n - 再次遍历解压后的新旧apk资源文件，筛选出删除的资源，保存在deletedSet（在上述patch分类资源时deletedSet其实一直为空，只有在这里才会被赋值）；\n - 返回的四个patch set把AndroidManfest.xml剔除，因为这个文件是不可能做修改；\n - 返回的四个patch set把指定的ignoreChange清单文件剔除；\n4. 新建一个最终的资源合成包resources_out.zip，开始往该zip包添加最终资源（下面展开细说）：\n\n\t![](http://i.imgur.com/pqfC4ra.png)\n5. 7zip压缩，这里分析没有设置该参数，跳过；\n6. 记录基准包的resources.arsc获取Crc和新包的resources.arsc获取md5到res_meta.txt，用以在做合成patch时的安全校验；\n7. 记录四个patch set的信息到res_meta.txt\n\n### 合成resources_out.zip过程\n\n在上述第四步合成resources_out.zip过程中，涉及到将一个压缩文件内的指定文件压到另外一个压缩包内。这里巧妙地根据zip格式去做筛选压缩。具体实现代码在com.tencent.tinker.build.util的genResOutputFile方法中：\n\n![](http://i.imgur.com/EKi0Fmz.png)\n\n跟进去TinkerZipFile，走到readCentralDir()方法。当时在看到这个名称的时候，仿佛有那么一点的熟悉。因为之前在搞zip的EOCD读取渠道号的时候也看到类似代码。果不其然，这里也有涉及到EOCD，但其只作为获取central directory的桥梁，大致流程是 \n\n\t获取EOCD->解析EOCD的centralDirOffset（CDO）和EntriesNum（num）->根据CDO去查找num个entry->保存entry的name和entry的键值对\n\n其实这里获取的entry name，即是zip中每个文件名。关于zip格式，可以参考下其wiki介绍 [Zip (file format)](https://en.wikipedia.org/wiki/Zip_(file_format))。然后做文件筛选压到resources_out.zip（下面均简指目标zip）中，主要步骤如下：\n\n1. 对于旧apk而言，只要是未被删除和修改的资源都压到目标zip，同时排除AndroidManifest.xml（目前这里面有bug，删除的资源也会被压到目标zip，是路径未被转义导致字符串不匹配，已提pr）；\n2. 对旧apk中是否存在AndroidManifest.xml判空，有则直接压到目标zip，没有直接抛错；\n3. 分别对修改和新增的筛选set从newZipFile（注意，这里不是指新apk，是指在patch筛选过程中对资源拷贝的tinker_result目录的tempZip）压指定资源到目标zip\n4. 返回目标zip的md5值\n\n走到这里，patch资源信息记录已经完成了，剩下的就是对新旧tinkerId和packageConfig的记录，最后就是把tinker_result目录打成patch apk。如果有阅读客户端合资源patch的源码，会发现和生成resources_out.zip的过程大同小异。\n\n# 最后\n\n总体而言，整个资源patch流程还是比较清晰明了，只是对相关的资源二进制文件进行读取，并没有想象中去修改resource.arsc实现资源patch。和之前分享的 [优化动态加载方案](https://hellokugo.github.io/2016/09/10/%E4%BC%98%E5%8C%96%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%96%B9%E6%A1%88/) 文章对资源进行动态加载的思想一样，都是沿用google官方的InstantRun全量替换资源的._ap文件（在这里就是一个patch）方案。So，RTFC永远是王道。","source":"_posts/微信Tinker资源热修复解析.md","raw":"title: 微信Tinker资源热修复解析\ndate: 2016/11/30 20：10\n\ncategories:\n- Android\ntags:\n- Android，Tinker\n---\n\n\n# 前言\n\n微信的热修复框架 [Tinker](https://github.com/Tencent/tinker) 开源已有一段时间了，同时他们也配套地开放了一个免费的 [补丁后台](http://www.tinkerpatch.com/) 供我们完整地体验了整个热修复流程，根据详细的文档和demo演示接入，目前的使用已经趋于稳定。相比当前比较热门的热修复框架，Tinker对于开发者而言是更加透明而且容易理解。<!-- more -->俗话说，工欲善其事必先利其器。既然Tinker的源码已经开放，就不能单单地停留在使用的层面上，遇到问题看文档也不能根本解决问题，所以，窥探Tinker内部实现原理，可以在接入过程出现问题较快定位，而且了解实现原理对于自身的学习也是有很大帮助。\n\n# 说明\n\nTinker是支持代码、资源和lib（so）层面上的修复，个人认为，代码层面的修复采用微信自研的dexDiff才是Tinker的核心。由于笔者对dex的结构还没熟悉，所以这里不针对代码修复流程进行解析，[Tinker Dexdiff算法解析](https://www.zybuluo.com/dodola/note/554061) 一文对其中dexDiff解析还是比较详尽，前提条件下对dex结构和bytecode有了解才可以阅读下去。本文主要解析的是Tinker实现资源修复流程。\n\n# 思路\n\nTinker文档上主要演示的是如何在AS通过gradle来构建生成patch包，同时也有介绍如何通过tinker-patch-cli.jar命令行去生成patch。下载Tinker的源码，工程结构：\n\n![](http://i.imgur.com/xaIhAsb.png)\n\n其中，工程tinker-build正是tinker-patch-cli.jar的构建代码：\n\n![](http://i.imgur.com/4xPMJ6e.png)\n\nCliMain.java正是入口类。\n\n## 解析输入参数和tinker_config.xml\n\nTalk is cheap，show me the code. 打开CliMain.java，入口main方法：\n\n![](http://i.imgur.com/uxmG7tQ.png)\n\n这里首先获取当前运行命令行的目录，以便后续没有指定output等做拼凑，然后开始解析输入参数。解析完一系列参数后：\n\n![](http://i.imgur.com/uqjpzqd.png)\n\n这里面做了三件事，首先，解析tinker_config.xml文件，这个文件在tinker-build的tool_output下有，当然，可以根据自己的需要去定制条件。由于本文主要介绍资源patch，所以只看资源条件:\n\n![](http://i.imgur.com/HbzJQMl.png)\n\npattern指定要做patch的指定文件，ignoreChange指定你不想做patch的文件（即使前后发生改变也过滤不做patch），largeModSize指定做bsdiff的阈值。\n\n解析完tinker_config.xml，定义输出文件的logger；然后开始做patch。\n\n## tinkerPatch\n\ntinkerPatch方法笔者认为可以分成三部分进行分析。第一部分是patch的核心，当然包含资源、代码和libs的patch；第二部分是生成配置文件，主要是对配置的tinkerId和一些patch信息的输出记录；第三部分则是生成patch包，具体代码：\n\n![](http://i.imgur.com/h3gHyJp.png)\n\n下面重点解析第一部分。\n\n### AndroidManifest check，水很深\n\n跟代码进到decoder.patch，看到这一行\n\n\t//check manifest change first\n    manifestDecoder.patch(oldFile, newFile);\n\n事实上，这简单的一句check manifest change，里面涉及要了解的东西不少，跟进去看：\n\n![](http://i.imgur.com/MFdoKc5.png)\n\n这里获取新旧apk的mainfest信息，定义AndroidParser对象，保存解析得到的四大组件和metaData标签等信息，还有通过各种转义解析得到整一份AndroidMainfest的string返回，他们对应的核心类均是继承自XmlStreamer的ApkMetaTranslator和XmlTranslator。\n\n - 如果要具体深入了解里面的解析原理，必须得对Android的resource.arsc和AndroidManifest.xml文件的二进制格式有一定了解，当然还涉及escapeXml10等转义知识，不然基本上读着读着就懵逼。By the way，你大可不用去了解其解析，因为笔者在了解其解析Manifest的ResourceId Chunk读取的/r_values.ini文件时发现，其实这里的解析用到的是github上一个开源项目，Tinker应该是在此基础上加以修改完善。\n - 有兴趣的同学可以去了解下：https://github.com/clearthesky/apk-parser。当然，你也可以直接在jcenter搜索Tinker定制的apk-parser-lib。\n\n接下来在获取到的AndroidManifest解析信息后，对minSdkVersion进行判断处理，主要是对config输入的ignoreWarning进行风险规避，这个在Tinker的wiki上也有说明：\n\n![](http://i.imgur.com/jxzFFey.png)\n\n这里是针对第一种情况处理，后面对ignoreWarning的判断将不再说明。</br>\n最后则是将新旧的AndroidMainfest的标签信息进行一一比对，如果ignoreWarning为false，则抛出异常。因为目前Tinker还不支持AndroidMainfest的热修复。\n\n### 资源文件对比筛选\n\n通过对AndroidMainfest的新旧对比之后，如果对比成功则开始进行资源文件的对比筛选：\n\n\tFiles.walkFileTree(mNewApkDir.toPath(), new ApkFilesVisitor(config, mNewApkDir.toPath(), mOldApkDir.toPath(), dexPatchDecoder, soPatchDecoder, resPatchDecoder));\n\n跟进ApkFilesVisitor的visitFile方法，跳过代码和libs的patch，直接到资源patch：\n\n![](http://i.imgur.com/TZguPmv.png)\n\n资源patch在ResDiffDecoder类中的patch方法中实现，其主要是做了以下工作:\n\n1. 解压后的新旧apk中，oldFile对应的newFile不存在，则认为新的apk对oldFile资源删除，保存在deletedSet中（正如其注释上说的，这段代码永远不会走，所以没有任何实质作用，deletedSet下面会重新添加成员）；\n2. 解压后的新旧apk中，newFile对应的oldFile不存在，则认为新的apk新添了newFile资源，保存在addedSet中，并且把newFile拷贝到tinker_result目录下；\n3. 如果不存在上述两种情况，而且oldFile和newFile存在，对比oldFile和newFile的md5，相同则认为该资源文件没有做任何修改，直接返回；\n4. 如果该文件不在指定的ignoreChangePattern清单里，并且不是AndroidMainfest.xml文件，走到这里：\n\n![](http://i.imgur.com/moYNpBO.png)\n\n假如该文件是resources.arsc，开始进行新旧resources.arsc的对比。如果之前有阅读过 [Resource.arsc文件格式](https://hellokugo.github.io/2016/09/03/Resource.arsc%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/) 这篇文章，这里理解应该不难。要注意的是，每个chunk的headSize对应着不同的位置大小。最后则是重定义equals方法去比较各个chunk是否一致：\n\n![](http://i.imgur.com/VmVebFg.png)\t\n\n5.如果在进行上述4步还没有return，说明新旧apk都存在该资源文件，并且有做修改：\n\n![](http://i.imgur.com/sfvXFcX.png)\n\n这里首先判断该文件是否大于指定的largeModSize，这个在config可以指定，如果是大于该值，用bsDiff算法得到newFile，并保存在largeModifiedSet中；如果小于该largeModSize，直接保存在modifiedSet，并拷贝到tinker_result目录下。\n\n### 解压修改文件\n\n其实上述生成步骤走完，tinker_result就是最终的patch包，而接下来要做的是配置文件的写入，大体上和客户端合patch流程是一致的。跟代码走到\n\n\tresPatchDecoder.onAllPatchesEnd();\n\n具体处理在ResDiffDecoder类中的onAllPatchesEnd方法中实现，其主要是做了以下工作:\n\n1. 对pattern的文件判断和返回的筛选patch文件判空进行处理；\n2. 判断是否用gradle构建生成patch，这里分析命令行生成patch，所以里面逻辑跳过；\n3. 重新对返回的patch保存进行筛选，具体是\n - 再次遍历解压后的新旧apk资源文件，筛选出删除的资源，保存在deletedSet（在上述patch分类资源时deletedSet其实一直为空，只有在这里才会被赋值）；\n - 返回的四个patch set把AndroidManfest.xml剔除，因为这个文件是不可能做修改；\n - 返回的四个patch set把指定的ignoreChange清单文件剔除；\n4. 新建一个最终的资源合成包resources_out.zip，开始往该zip包添加最终资源（下面展开细说）：\n\n\t![](http://i.imgur.com/pqfC4ra.png)\n5. 7zip压缩，这里分析没有设置该参数，跳过；\n6. 记录基准包的resources.arsc获取Crc和新包的resources.arsc获取md5到res_meta.txt，用以在做合成patch时的安全校验；\n7. 记录四个patch set的信息到res_meta.txt\n\n### 合成resources_out.zip过程\n\n在上述第四步合成resources_out.zip过程中，涉及到将一个压缩文件内的指定文件压到另外一个压缩包内。这里巧妙地根据zip格式去做筛选压缩。具体实现代码在com.tencent.tinker.build.util的genResOutputFile方法中：\n\n![](http://i.imgur.com/EKi0Fmz.png)\n\n跟进去TinkerZipFile，走到readCentralDir()方法。当时在看到这个名称的时候，仿佛有那么一点的熟悉。因为之前在搞zip的EOCD读取渠道号的时候也看到类似代码。果不其然，这里也有涉及到EOCD，但其只作为获取central directory的桥梁，大致流程是 \n\n\t获取EOCD->解析EOCD的centralDirOffset（CDO）和EntriesNum（num）->根据CDO去查找num个entry->保存entry的name和entry的键值对\n\n其实这里获取的entry name，即是zip中每个文件名。关于zip格式，可以参考下其wiki介绍 [Zip (file format)](https://en.wikipedia.org/wiki/Zip_(file_format))。然后做文件筛选压到resources_out.zip（下面均简指目标zip）中，主要步骤如下：\n\n1. 对于旧apk而言，只要是未被删除和修改的资源都压到目标zip，同时排除AndroidManifest.xml（目前这里面有bug，删除的资源也会被压到目标zip，是路径未被转义导致字符串不匹配，已提pr）；\n2. 对旧apk中是否存在AndroidManifest.xml判空，有则直接压到目标zip，没有直接抛错；\n3. 分别对修改和新增的筛选set从newZipFile（注意，这里不是指新apk，是指在patch筛选过程中对资源拷贝的tinker_result目录的tempZip）压指定资源到目标zip\n4. 返回目标zip的md5值\n\n走到这里，patch资源信息记录已经完成了，剩下的就是对新旧tinkerId和packageConfig的记录，最后就是把tinker_result目录打成patch apk。如果有阅读客户端合资源patch的源码，会发现和生成resources_out.zip的过程大同小异。\n\n# 最后\n\n总体而言，整个资源patch流程还是比较清晰明了，只是对相关的资源二进制文件进行读取，并没有想象中去修改resource.arsc实现资源patch。和之前分享的 [优化动态加载方案](https://hellokugo.github.io/2016/09/10/%E4%BC%98%E5%8C%96%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%96%B9%E6%A1%88/) 文章对资源进行动态加载的思想一样，都是沿用google官方的InstantRun全量替换资源的._ap文件（在这里就是一个patch）方案。So，RTFC永远是王道。","slug":"微信Tinker资源热修复解析","published":1,"updated":"2018-01-28T15:39:34.392Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjcyyg7kh000onius2wucunog","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>微信的热修复框架 <a href=\"https://github.com/Tencent/tinker\" target=\"_blank\" rel=\"noopener\">Tinker</a> 开源已有一段时间了，同时他们也配套地开放了一个免费的 <a href=\"http://www.tinkerpatch.com/\" target=\"_blank\" rel=\"noopener\">补丁后台</a> 供我们完整地体验了整个热修复流程，根据详细的文档和demo演示接入，目前的使用已经趋于稳定。相比当前比较热门的热修复框架，Tinker对于开发者而言是更加透明而且容易理解。<a id=\"more\"></a>俗话说，工欲善其事必先利其器。既然Tinker的源码已经开放，就不能单单地停留在使用的层面上，遇到问题看文档也不能根本解决问题，所以，窥探Tinker内部实现原理，可以在接入过程出现问题较快定位，而且了解实现原理对于自身的学习也是有很大帮助。</p>\n<h1 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h1><p>Tinker是支持代码、资源和lib（so）层面上的修复，个人认为，代码层面的修复采用微信自研的dexDiff才是Tinker的核心。由于笔者对dex的结构还没熟悉，所以这里不针对代码修复流程进行解析，<a href=\"https://www.zybuluo.com/dodola/note/554061\" target=\"_blank\" rel=\"noopener\">Tinker Dexdiff算法解析</a> 一文对其中dexDiff解析还是比较详尽，前提条件下对dex结构和bytecode有了解才可以阅读下去。本文主要解析的是Tinker实现资源修复流程。</p>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>Tinker文档上主要演示的是如何在AS通过gradle来构建生成patch包，同时也有介绍如何通过tinker-patch-cli.jar命令行去生成patch。下载Tinker的源码，工程结构：</p>\n<p><img src=\"http://i.imgur.com/xaIhAsb.png\" alt=\"\"></p>\n<p>其中，工程tinker-build正是tinker-patch-cli.jar的构建代码：</p>\n<p><img src=\"http://i.imgur.com/4xPMJ6e.png\" alt=\"\"></p>\n<p>CliMain.java正是入口类。</p>\n<h2 id=\"解析输入参数和tinker-config-xml\"><a href=\"#解析输入参数和tinker-config-xml\" class=\"headerlink\" title=\"解析输入参数和tinker_config.xml\"></a>解析输入参数和tinker_config.xml</h2><p>Talk is cheap，show me the code. 打开CliMain.java，入口main方法：</p>\n<p><img src=\"http://i.imgur.com/uxmG7tQ.png\" alt=\"\"></p>\n<p>这里首先获取当前运行命令行的目录，以便后续没有指定output等做拼凑，然后开始解析输入参数。解析完一系列参数后：</p>\n<p><img src=\"http://i.imgur.com/uqjpzqd.png\" alt=\"\"></p>\n<p>这里面做了三件事，首先，解析tinker_config.xml文件，这个文件在tinker-build的tool_output下有，当然，可以根据自己的需要去定制条件。由于本文主要介绍资源patch，所以只看资源条件:</p>\n<p><img src=\"http://i.imgur.com/HbzJQMl.png\" alt=\"\"></p>\n<p>pattern指定要做patch的指定文件，ignoreChange指定你不想做patch的文件（即使前后发生改变也过滤不做patch），largeModSize指定做bsdiff的阈值。</p>\n<p>解析完tinker_config.xml，定义输出文件的logger；然后开始做patch。</p>\n<h2 id=\"tinkerPatch\"><a href=\"#tinkerPatch\" class=\"headerlink\" title=\"tinkerPatch\"></a>tinkerPatch</h2><p>tinkerPatch方法笔者认为可以分成三部分进行分析。第一部分是patch的核心，当然包含资源、代码和libs的patch；第二部分是生成配置文件，主要是对配置的tinkerId和一些patch信息的输出记录；第三部分则是生成patch包，具体代码：</p>\n<p><img src=\"http://i.imgur.com/h3gHyJp.png\" alt=\"\"></p>\n<p>下面重点解析第一部分。</p>\n<h3 id=\"AndroidManifest-check，水很深\"><a href=\"#AndroidManifest-check，水很深\" class=\"headerlink\" title=\"AndroidManifest check，水很深\"></a>AndroidManifest check，水很深</h3><p>跟代码进到decoder.patch，看到这一行</p>\n<pre><code>//check manifest change first\nmanifestDecoder.patch(oldFile, newFile);\n</code></pre><p>事实上，这简单的一句check manifest change，里面涉及要了解的东西不少，跟进去看：</p>\n<p><img src=\"http://i.imgur.com/MFdoKc5.png\" alt=\"\"></p>\n<p>这里获取新旧apk的mainfest信息，定义AndroidParser对象，保存解析得到的四大组件和metaData标签等信息，还有通过各种转义解析得到整一份AndroidMainfest的string返回，他们对应的核心类均是继承自XmlStreamer的ApkMetaTranslator和XmlTranslator。</p>\n<ul>\n<li>如果要具体深入了解里面的解析原理，必须得对Android的resource.arsc和AndroidManifest.xml文件的二进制格式有一定了解，当然还涉及escapeXml10等转义知识，不然基本上读着读着就懵逼。By the way，你大可不用去了解其解析，因为笔者在了解其解析Manifest的ResourceId Chunk读取的/r_values.ini文件时发现，其实这里的解析用到的是github上一个开源项目，Tinker应该是在此基础上加以修改完善。</li>\n<li>有兴趣的同学可以去了解下：<a href=\"https://github.com/clearthesky/apk-parser。当然，你也可以直接在jcenter搜索Tinker定制的apk-parser-lib。\" target=\"_blank\" rel=\"noopener\">https://github.com/clearthesky/apk-parser。当然，你也可以直接在jcenter搜索Tinker定制的apk-parser-lib。</a></li>\n</ul>\n<p>接下来在获取到的AndroidManifest解析信息后，对minSdkVersion进行判断处理，主要是对config输入的ignoreWarning进行风险规避，这个在Tinker的wiki上也有说明：</p>\n<p><img src=\"http://i.imgur.com/jxzFFey.png\" alt=\"\"></p>\n<p>这里是针对第一种情况处理，后面对ignoreWarning的判断将不再说明。<br><br>最后则是将新旧的AndroidMainfest的标签信息进行一一比对，如果ignoreWarning为false，则抛出异常。因为目前Tinker还不支持AndroidMainfest的热修复。</p>\n<h3 id=\"资源文件对比筛选\"><a href=\"#资源文件对比筛选\" class=\"headerlink\" title=\"资源文件对比筛选\"></a>资源文件对比筛选</h3><p>通过对AndroidMainfest的新旧对比之后，如果对比成功则开始进行资源文件的对比筛选：</p>\n<pre><code>Files.walkFileTree(mNewApkDir.toPath(), new ApkFilesVisitor(config, mNewApkDir.toPath(), mOldApkDir.toPath(), dexPatchDecoder, soPatchDecoder, resPatchDecoder));\n</code></pre><p>跟进ApkFilesVisitor的visitFile方法，跳过代码和libs的patch，直接到资源patch：</p>\n<p><img src=\"http://i.imgur.com/TZguPmv.png\" alt=\"\"></p>\n<p>资源patch在ResDiffDecoder类中的patch方法中实现，其主要是做了以下工作:</p>\n<ol>\n<li>解压后的新旧apk中，oldFile对应的newFile不存在，则认为新的apk对oldFile资源删除，保存在deletedSet中（正如其注释上说的，这段代码永远不会走，所以没有任何实质作用，deletedSet下面会重新添加成员）；</li>\n<li>解压后的新旧apk中，newFile对应的oldFile不存在，则认为新的apk新添了newFile资源，保存在addedSet中，并且把newFile拷贝到tinker_result目录下；</li>\n<li>如果不存在上述两种情况，而且oldFile和newFile存在，对比oldFile和newFile的md5，相同则认为该资源文件没有做任何修改，直接返回；</li>\n<li>如果该文件不在指定的ignoreChangePattern清单里，并且不是AndroidMainfest.xml文件，走到这里：</li>\n</ol>\n<p><img src=\"http://i.imgur.com/moYNpBO.png\" alt=\"\"></p>\n<p>假如该文件是resources.arsc，开始进行新旧resources.arsc的对比。如果之前有阅读过 <a href=\"https://hellokugo.github.io/2016/09/03/Resource.arsc%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/\">Resource.arsc文件格式</a> 这篇文章，这里理解应该不难。要注意的是，每个chunk的headSize对应着不同的位置大小。最后则是重定义equals方法去比较各个chunk是否一致：</p>\n<p><img src=\"http://i.imgur.com/VmVebFg.png\" alt=\"\">    </p>\n<p>5.如果在进行上述4步还没有return，说明新旧apk都存在该资源文件，并且有做修改：</p>\n<p><img src=\"http://i.imgur.com/sfvXFcX.png\" alt=\"\"></p>\n<p>这里首先判断该文件是否大于指定的largeModSize，这个在config可以指定，如果是大于该值，用bsDiff算法得到newFile，并保存在largeModifiedSet中；如果小于该largeModSize，直接保存在modifiedSet，并拷贝到tinker_result目录下。</p>\n<h3 id=\"解压修改文件\"><a href=\"#解压修改文件\" class=\"headerlink\" title=\"解压修改文件\"></a>解压修改文件</h3><p>其实上述生成步骤走完，tinker_result就是最终的patch包，而接下来要做的是配置文件的写入，大体上和客户端合patch流程是一致的。跟代码走到</p>\n<pre><code>resPatchDecoder.onAllPatchesEnd();\n</code></pre><p>具体处理在ResDiffDecoder类中的onAllPatchesEnd方法中实现，其主要是做了以下工作:</p>\n<ol>\n<li>对pattern的文件判断和返回的筛选patch文件判空进行处理；</li>\n<li>判断是否用gradle构建生成patch，这里分析命令行生成patch，所以里面逻辑跳过；</li>\n<li>重新对返回的patch保存进行筛选，具体是<ul>\n<li>再次遍历解压后的新旧apk资源文件，筛选出删除的资源，保存在deletedSet（在上述patch分类资源时deletedSet其实一直为空，只有在这里才会被赋值）；</li>\n<li>返回的四个patch set把AndroidManfest.xml剔除，因为这个文件是不可能做修改；</li>\n<li>返回的四个patch set把指定的ignoreChange清单文件剔除；</li>\n</ul>\n</li>\n<li><p>新建一个最终的资源合成包resources_out.zip，开始往该zip包添加最终资源（下面展开细说）：</p>\n<p> <img src=\"http://i.imgur.com/pqfC4ra.png\" alt=\"\"></p>\n</li>\n<li>7zip压缩，这里分析没有设置该参数，跳过；</li>\n<li>记录基准包的resources.arsc获取Crc和新包的resources.arsc获取md5到res_meta.txt，用以在做合成patch时的安全校验；</li>\n<li>记录四个patch set的信息到res_meta.txt</li>\n</ol>\n<h3 id=\"合成resources-out-zip过程\"><a href=\"#合成resources-out-zip过程\" class=\"headerlink\" title=\"合成resources_out.zip过程\"></a>合成resources_out.zip过程</h3><p>在上述第四步合成resources_out.zip过程中，涉及到将一个压缩文件内的指定文件压到另外一个压缩包内。这里巧妙地根据zip格式去做筛选压缩。具体实现代码在com.tencent.tinker.build.util的genResOutputFile方法中：</p>\n<p><img src=\"http://i.imgur.com/EKi0Fmz.png\" alt=\"\"></p>\n<p>跟进去TinkerZipFile，走到readCentralDir()方法。当时在看到这个名称的时候，仿佛有那么一点的熟悉。因为之前在搞zip的EOCD读取渠道号的时候也看到类似代码。果不其然，这里也有涉及到EOCD，但其只作为获取central directory的桥梁，大致流程是 </p>\n<pre><code>获取EOCD-&gt;解析EOCD的centralDirOffset（CDO）和EntriesNum（num）-&gt;根据CDO去查找num个entry-&gt;保存entry的name和entry的键值对\n</code></pre><p>其实这里获取的entry name，即是zip中每个文件名。关于zip格式，可以参考下其wiki介绍 <a href=\"https://en.wikipedia.org/wiki/Zip_(file_format\" target=\"_blank\" rel=\"noopener\">Zip (file format)</a>)。然后做文件筛选压到resources_out.zip（下面均简指目标zip）中，主要步骤如下：</p>\n<ol>\n<li>对于旧apk而言，只要是未被删除和修改的资源都压到目标zip，同时排除AndroidManifest.xml（目前这里面有bug，删除的资源也会被压到目标zip，是路径未被转义导致字符串不匹配，已提pr）；</li>\n<li>对旧apk中是否存在AndroidManifest.xml判空，有则直接压到目标zip，没有直接抛错；</li>\n<li>分别对修改和新增的筛选set从newZipFile（注意，这里不是指新apk，是指在patch筛选过程中对资源拷贝的tinker_result目录的tempZip）压指定资源到目标zip</li>\n<li>返回目标zip的md5值</li>\n</ol>\n<p>走到这里，patch资源信息记录已经完成了，剩下的就是对新旧tinkerId和packageConfig的记录，最后就是把tinker_result目录打成patch apk。如果有阅读客户端合资源patch的源码，会发现和生成resources_out.zip的过程大同小异。</p>\n<h1 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h1><p>总体而言，整个资源patch流程还是比较清晰明了，只是对相关的资源二进制文件进行读取，并没有想象中去修改resource.arsc实现资源patch。和之前分享的 <a href=\"https://hellokugo.github.io/2016/09/10/%E4%BC%98%E5%8C%96%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%96%B9%E6%A1%88/\">优化动态加载方案</a> 文章对资源进行动态加载的思想一样，都是沿用google官方的InstantRun全量替换资源的._ap文件（在这里就是一个patch）方案。So，RTFC永远是王道。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>微信的热修复框架 <a href=\"https://github.com/Tencent/tinker\" target=\"_blank\" rel=\"noopener\">Tinker</a> 开源已有一段时间了，同时他们也配套地开放了一个免费的 <a href=\"http://www.tinkerpatch.com/\" target=\"_blank\" rel=\"noopener\">补丁后台</a> 供我们完整地体验了整个热修复流程，根据详细的文档和demo演示接入，目前的使用已经趋于稳定。相比当前比较热门的热修复框架，Tinker对于开发者而言是更加透明而且容易理解。","more":"俗话说，工欲善其事必先利其器。既然Tinker的源码已经开放，就不能单单地停留在使用的层面上，遇到问题看文档也不能根本解决问题，所以，窥探Tinker内部实现原理，可以在接入过程出现问题较快定位，而且了解实现原理对于自身的学习也是有很大帮助。</p>\n<h1 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h1><p>Tinker是支持代码、资源和lib（so）层面上的修复，个人认为，代码层面的修复采用微信自研的dexDiff才是Tinker的核心。由于笔者对dex的结构还没熟悉，所以这里不针对代码修复流程进行解析，<a href=\"https://www.zybuluo.com/dodola/note/554061\" target=\"_blank\" rel=\"noopener\">Tinker Dexdiff算法解析</a> 一文对其中dexDiff解析还是比较详尽，前提条件下对dex结构和bytecode有了解才可以阅读下去。本文主要解析的是Tinker实现资源修复流程。</p>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>Tinker文档上主要演示的是如何在AS通过gradle来构建生成patch包，同时也有介绍如何通过tinker-patch-cli.jar命令行去生成patch。下载Tinker的源码，工程结构：</p>\n<p><img src=\"http://i.imgur.com/xaIhAsb.png\" alt=\"\"></p>\n<p>其中，工程tinker-build正是tinker-patch-cli.jar的构建代码：</p>\n<p><img src=\"http://i.imgur.com/4xPMJ6e.png\" alt=\"\"></p>\n<p>CliMain.java正是入口类。</p>\n<h2 id=\"解析输入参数和tinker-config-xml\"><a href=\"#解析输入参数和tinker-config-xml\" class=\"headerlink\" title=\"解析输入参数和tinker_config.xml\"></a>解析输入参数和tinker_config.xml</h2><p>Talk is cheap，show me the code. 打开CliMain.java，入口main方法：</p>\n<p><img src=\"http://i.imgur.com/uxmG7tQ.png\" alt=\"\"></p>\n<p>这里首先获取当前运行命令行的目录，以便后续没有指定output等做拼凑，然后开始解析输入参数。解析完一系列参数后：</p>\n<p><img src=\"http://i.imgur.com/uqjpzqd.png\" alt=\"\"></p>\n<p>这里面做了三件事，首先，解析tinker_config.xml文件，这个文件在tinker-build的tool_output下有，当然，可以根据自己的需要去定制条件。由于本文主要介绍资源patch，所以只看资源条件:</p>\n<p><img src=\"http://i.imgur.com/HbzJQMl.png\" alt=\"\"></p>\n<p>pattern指定要做patch的指定文件，ignoreChange指定你不想做patch的文件（即使前后发生改变也过滤不做patch），largeModSize指定做bsdiff的阈值。</p>\n<p>解析完tinker_config.xml，定义输出文件的logger；然后开始做patch。</p>\n<h2 id=\"tinkerPatch\"><a href=\"#tinkerPatch\" class=\"headerlink\" title=\"tinkerPatch\"></a>tinkerPatch</h2><p>tinkerPatch方法笔者认为可以分成三部分进行分析。第一部分是patch的核心，当然包含资源、代码和libs的patch；第二部分是生成配置文件，主要是对配置的tinkerId和一些patch信息的输出记录；第三部分则是生成patch包，具体代码：</p>\n<p><img src=\"http://i.imgur.com/h3gHyJp.png\" alt=\"\"></p>\n<p>下面重点解析第一部分。</p>\n<h3 id=\"AndroidManifest-check，水很深\"><a href=\"#AndroidManifest-check，水很深\" class=\"headerlink\" title=\"AndroidManifest check，水很深\"></a>AndroidManifest check，水很深</h3><p>跟代码进到decoder.patch，看到这一行</p>\n<pre><code>//check manifest change first\nmanifestDecoder.patch(oldFile, newFile);\n</code></pre><p>事实上，这简单的一句check manifest change，里面涉及要了解的东西不少，跟进去看：</p>\n<p><img src=\"http://i.imgur.com/MFdoKc5.png\" alt=\"\"></p>\n<p>这里获取新旧apk的mainfest信息，定义AndroidParser对象，保存解析得到的四大组件和metaData标签等信息，还有通过各种转义解析得到整一份AndroidMainfest的string返回，他们对应的核心类均是继承自XmlStreamer的ApkMetaTranslator和XmlTranslator。</p>\n<ul>\n<li>如果要具体深入了解里面的解析原理，必须得对Android的resource.arsc和AndroidManifest.xml文件的二进制格式有一定了解，当然还涉及escapeXml10等转义知识，不然基本上读着读着就懵逼。By the way，你大可不用去了解其解析，因为笔者在了解其解析Manifest的ResourceId Chunk读取的/r_values.ini文件时发现，其实这里的解析用到的是github上一个开源项目，Tinker应该是在此基础上加以修改完善。</li>\n<li>有兴趣的同学可以去了解下：<a href=\"https://github.com/clearthesky/apk-parser。当然，你也可以直接在jcenter搜索Tinker定制的apk-parser-lib。\" target=\"_blank\" rel=\"noopener\">https://github.com/clearthesky/apk-parser。当然，你也可以直接在jcenter搜索Tinker定制的apk-parser-lib。</a></li>\n</ul>\n<p>接下来在获取到的AndroidManifest解析信息后，对minSdkVersion进行判断处理，主要是对config输入的ignoreWarning进行风险规避，这个在Tinker的wiki上也有说明：</p>\n<p><img src=\"http://i.imgur.com/jxzFFey.png\" alt=\"\"></p>\n<p>这里是针对第一种情况处理，后面对ignoreWarning的判断将不再说明。<br><br>最后则是将新旧的AndroidMainfest的标签信息进行一一比对，如果ignoreWarning为false，则抛出异常。因为目前Tinker还不支持AndroidMainfest的热修复。</p>\n<h3 id=\"资源文件对比筛选\"><a href=\"#资源文件对比筛选\" class=\"headerlink\" title=\"资源文件对比筛选\"></a>资源文件对比筛选</h3><p>通过对AndroidMainfest的新旧对比之后，如果对比成功则开始进行资源文件的对比筛选：</p>\n<pre><code>Files.walkFileTree(mNewApkDir.toPath(), new ApkFilesVisitor(config, mNewApkDir.toPath(), mOldApkDir.toPath(), dexPatchDecoder, soPatchDecoder, resPatchDecoder));\n</code></pre><p>跟进ApkFilesVisitor的visitFile方法，跳过代码和libs的patch，直接到资源patch：</p>\n<p><img src=\"http://i.imgur.com/TZguPmv.png\" alt=\"\"></p>\n<p>资源patch在ResDiffDecoder类中的patch方法中实现，其主要是做了以下工作:</p>\n<ol>\n<li>解压后的新旧apk中，oldFile对应的newFile不存在，则认为新的apk对oldFile资源删除，保存在deletedSet中（正如其注释上说的，这段代码永远不会走，所以没有任何实质作用，deletedSet下面会重新添加成员）；</li>\n<li>解压后的新旧apk中，newFile对应的oldFile不存在，则认为新的apk新添了newFile资源，保存在addedSet中，并且把newFile拷贝到tinker_result目录下；</li>\n<li>如果不存在上述两种情况，而且oldFile和newFile存在，对比oldFile和newFile的md5，相同则认为该资源文件没有做任何修改，直接返回；</li>\n<li>如果该文件不在指定的ignoreChangePattern清单里，并且不是AndroidMainfest.xml文件，走到这里：</li>\n</ol>\n<p><img src=\"http://i.imgur.com/moYNpBO.png\" alt=\"\"></p>\n<p>假如该文件是resources.arsc，开始进行新旧resources.arsc的对比。如果之前有阅读过 <a href=\"https://hellokugo.github.io/2016/09/03/Resource.arsc%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/\">Resource.arsc文件格式</a> 这篇文章，这里理解应该不难。要注意的是，每个chunk的headSize对应着不同的位置大小。最后则是重定义equals方法去比较各个chunk是否一致：</p>\n<p><img src=\"http://i.imgur.com/VmVebFg.png\" alt=\"\">    </p>\n<p>5.如果在进行上述4步还没有return，说明新旧apk都存在该资源文件，并且有做修改：</p>\n<p><img src=\"http://i.imgur.com/sfvXFcX.png\" alt=\"\"></p>\n<p>这里首先判断该文件是否大于指定的largeModSize，这个在config可以指定，如果是大于该值，用bsDiff算法得到newFile，并保存在largeModifiedSet中；如果小于该largeModSize，直接保存在modifiedSet，并拷贝到tinker_result目录下。</p>\n<h3 id=\"解压修改文件\"><a href=\"#解压修改文件\" class=\"headerlink\" title=\"解压修改文件\"></a>解压修改文件</h3><p>其实上述生成步骤走完，tinker_result就是最终的patch包，而接下来要做的是配置文件的写入，大体上和客户端合patch流程是一致的。跟代码走到</p>\n<pre><code>resPatchDecoder.onAllPatchesEnd();\n</code></pre><p>具体处理在ResDiffDecoder类中的onAllPatchesEnd方法中实现，其主要是做了以下工作:</p>\n<ol>\n<li>对pattern的文件判断和返回的筛选patch文件判空进行处理；</li>\n<li>判断是否用gradle构建生成patch，这里分析命令行生成patch，所以里面逻辑跳过；</li>\n<li>重新对返回的patch保存进行筛选，具体是<ul>\n<li>再次遍历解压后的新旧apk资源文件，筛选出删除的资源，保存在deletedSet（在上述patch分类资源时deletedSet其实一直为空，只有在这里才会被赋值）；</li>\n<li>返回的四个patch set把AndroidManfest.xml剔除，因为这个文件是不可能做修改；</li>\n<li>返回的四个patch set把指定的ignoreChange清单文件剔除；</li>\n</ul>\n</li>\n<li><p>新建一个最终的资源合成包resources_out.zip，开始往该zip包添加最终资源（下面展开细说）：</p>\n<p> <img src=\"http://i.imgur.com/pqfC4ra.png\" alt=\"\"></p>\n</li>\n<li>7zip压缩，这里分析没有设置该参数，跳过；</li>\n<li>记录基准包的resources.arsc获取Crc和新包的resources.arsc获取md5到res_meta.txt，用以在做合成patch时的安全校验；</li>\n<li>记录四个patch set的信息到res_meta.txt</li>\n</ol>\n<h3 id=\"合成resources-out-zip过程\"><a href=\"#合成resources-out-zip过程\" class=\"headerlink\" title=\"合成resources_out.zip过程\"></a>合成resources_out.zip过程</h3><p>在上述第四步合成resources_out.zip过程中，涉及到将一个压缩文件内的指定文件压到另外一个压缩包内。这里巧妙地根据zip格式去做筛选压缩。具体实现代码在com.tencent.tinker.build.util的genResOutputFile方法中：</p>\n<p><img src=\"http://i.imgur.com/EKi0Fmz.png\" alt=\"\"></p>\n<p>跟进去TinkerZipFile，走到readCentralDir()方法。当时在看到这个名称的时候，仿佛有那么一点的熟悉。因为之前在搞zip的EOCD读取渠道号的时候也看到类似代码。果不其然，这里也有涉及到EOCD，但其只作为获取central directory的桥梁，大致流程是 </p>\n<pre><code>获取EOCD-&gt;解析EOCD的centralDirOffset（CDO）和EntriesNum（num）-&gt;根据CDO去查找num个entry-&gt;保存entry的name和entry的键值对\n</code></pre><p>其实这里获取的entry name，即是zip中每个文件名。关于zip格式，可以参考下其wiki介绍 <a href=\"https://en.wikipedia.org/wiki/Zip_(file_format\" target=\"_blank\" rel=\"noopener\">Zip (file format)</a>)。然后做文件筛选压到resources_out.zip（下面均简指目标zip）中，主要步骤如下：</p>\n<ol>\n<li>对于旧apk而言，只要是未被删除和修改的资源都压到目标zip，同时排除AndroidManifest.xml（目前这里面有bug，删除的资源也会被压到目标zip，是路径未被转义导致字符串不匹配，已提pr）；</li>\n<li>对旧apk中是否存在AndroidManifest.xml判空，有则直接压到目标zip，没有直接抛错；</li>\n<li>分别对修改和新增的筛选set从newZipFile（注意，这里不是指新apk，是指在patch筛选过程中对资源拷贝的tinker_result目录的tempZip）压指定资源到目标zip</li>\n<li>返回目标zip的md5值</li>\n</ol>\n<p>走到这里，patch资源信息记录已经完成了，剩下的就是对新旧tinkerId和packageConfig的记录，最后就是把tinker_result目录打成patch apk。如果有阅读客户端合资源patch的源码，会发现和生成resources_out.zip的过程大同小异。</p>\n<h1 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h1><p>总体而言，整个资源patch流程还是比较清晰明了，只是对相关的资源二进制文件进行读取，并没有想象中去修改resource.arsc实现资源patch。和之前分享的 <a href=\"https://hellokugo.github.io/2016/09/10/%E4%BC%98%E5%8C%96%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%96%B9%E6%A1%88/\">优化动态加载方案</a> 文章对资源进行动态加载的思想一样，都是沿用google官方的InstantRun全量替换资源的._ap文件（在这里就是一个patch）方案。So，RTFC永远是王道。</p>"},{"title":"简析Android组件安全","date":"2018-01-28T15:39:34.393Z","_content":"\n# 前言 #\n前段时间在学习github上DroidPlgin插件的时候接触到不少专业术语，诸如预先占坑、Activity劫持和Hook等，一开始看还真是感觉雾里看花。在查阅资料的过程中发现了国人出版的《Android软件安全与逆向分析》，在理解Activity劫持的过程中引申了Android四大组件的安全。知识点不难却感觉蛮有趣，故分享之。<!-- more -->\n\n## Activity ##\nAndroid组件是用户唯一能够看见的组件，作为软件所有功能的显示载体，其安全问题是最应该受到关注的\n### 权限攻击 ###\n正如Android开发文档中所说的，Android系统组件在制定Intent过滤器（intent-filter）后，默认是可以被外部程序访问的。这就很意味着很容易被其他程序进行串谋攻击，关于串谋攻击，在分享最后再做一个简单的解析。现在问题是，如何防止Activity被外部使用呢？\n\nAndroid所有组件声明时可以通过指定android:exported属性值为false，来设置组件不能被外部程序调用。这里的外部程序是指签名不同、用户ID不同的程序，签名相同且用户ID相同的程序在执行时共享同一个进程空间，彼此之间是没有组件访问限制的。如果希望Activity能够被特定的程序访问，就不能用android:exported属性了，可以使用android:permission属性来指定一个权限字符串，声明例子如下：\n\n\n    <Activity android:name=\".MyActivity\"\n           android:permission=\"com.test.permission.MyActivity\">\n           <intent-filter>\n               <action android:name=\"com.test.action\"></action>\n           </intent-filter>\n    </Activity>\n\n这样声明的Activity在被调用时，Android系统就会检查调用者是否具有com.test.permission.MyActivity权限，如果不具备就会触发一个SecurityException安全异常。要想启动该Activity必须在AndroidManifest.xml文件中加入以下声明：\n    \n    <uses-permission android:name=\"com.test.permission.MyActivity\">\n\n### Activity劫持 ###\n当用户安装了带有Activity劫持功能的恶意程序后，恶意程序会遍历系统中运行的程序，当检测到需要劫持的Activity（通常是网银或其他网络程序的等登陆界面）在前台运行时，恶意程序就会启动一个带FLAG\\_ACTIVITY\\_NEW\\_TASK标志的钓鱼式Activity覆盖正常的Activity，从而欺骗输入用户名或密码信息，当用户输入完信息后，程序就会将信息发送到指定的网址或邮箱，然后切换到正常的Activity中。这就是Activity劫持原理。从受影响的角度看，Activity属于用户层安全，程序员无法控制。\n\n下面做一个简单的劫持例子。实例可以对多个进程进行劫持，它在启动时启动了一个Hack服务，Hack服务创建了一个定时器，定时器每隔2秒就检测一次系统正在运行的进程，判断前台运行的进程是否匹配劫持的进程列表中，如果匹配就进行劫持：\n\n    private TimeTask mTask = new TimeTask(){\n    \n        @Override\n        public void run(){\n         \tActivityManager am = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE);\n            List<RunningAppProcessInfo> infos = am.getRunningAppProcesses();\n            //枚举进程\n            for(RunningAppProcessInfo psinfo:infos){\n                if(psinfo.importance == RunningAppProcessInfo.IMPORTANCE_FOREGROUND){ //前台进程\n                 \tif(hackList.contains(psinfo.processName)){\n \t                    Intent intent = new Intent(getBaseContent(),HackerActivity.class);\n                        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)；\n                        intent.putExtra(\"processname\",psinfo.processName);\n                        getApplication().startActivity(intent);//启动伪造的Activity\n                    }\n                 }\n            }\n        }\n\n    }\n\nActivity劫持不需要在AndroidManifest.xml中声明任何权限就可以实现，一般的防病毒软件也无法检测，手机用户更是防不胜防。不过有一种方法可以判断当前Activity是否被劫持：长按Home键不放，系统显示最近运行过的程序列表。在本例中，HackerActvity显示在最前面，很显然这个程序就有劫持Actvity的嫌疑。\n\nUnfortunately，这种检测Activity劫持的方法并不是任何时候都有效的，假如在声明Activity时，设置android:excludeFromRecents的值为true，程序在运行时就不会显示在最近运行过的程序列表中，上面的检测方法也就只能hehe了。\n\n## Broadcast Receiver ##\nBroadcast Receiver用于处理发送和接收广播，这里分为发送安全和接收安全。接收广播涉及串谋攻击，这里先不作介绍，下面主要介绍发送广播安全。先来一段熟悉的代码:\n\n\tIntent intent = new Intent();\n\tintent.setAction(\"com.test.broadcast\");\n\tintent.putExtra(\"data\",Math.random());\n\tsendBroadcast(intent);\n\n这段代码发送了一个Action为com.test.broadcast的广播。我们都知道，Android系统提供了两种广播发送方法，分别是sendBroadcast()和sendOrderedBroadcast()。sendBroadcast()用于发送无序广播，该广播能够被所有广播接受者接收，并且不能被abortBroadcast()终止，sendOrderedBroadcast()用于发送有序广播，该广播被优先级高的广播接收者有限接收，然后依次向下传递，优先级高的广播接收者可以篡改广播，或者调用abortBroadcast()终止广播。广播优先级响应的计算方法是：动态注册的广播接收者比静态广播接收者的优先级高，静态广播接收者的优先级根据设置的android:priority属性的数值来决定，数值越大，优先级越高。\n\n从上面分析可以得知，假如Hacker动态注册一个Action为com.test.broadcast的广播接收者，并且拥有最高的优先级，上述程序假如使用sendBroadcast()发送广播，Hacker的确无法通过abortBroadcast()终止，但可以优先响应该实例发送的广播；但是假如上述程序使用sendOrderedBroadcast()发送，很有可能BroadcastReceiver实例就永远无法收到自己发送的广播。\n\n当然，上述问题也是可以避免的。在发送广播时通过Intent指定具体要发送到的Android组件或类，广播就永远只能被本实例指定的类所接收，如：\n\n\tintent,setClass(MainActivity.this,test.class);\n\n## Service ##\nService组件是Android系统中的后台进程，主要的功能是在后台进行一些耗时的操作。与其他的Android组件一样，当声明Service时指定了Intent过滤器，该Service默认就可以被外部访问。可以访问的方法有：\n\n>startService():启动服务，可以被用来实现串谋攻击。\n\n>bindService():绑定服务，可以被用来实现串谋攻击。\n\n>stopService():停止服务，对程序功能进行恶意破坏。\n\n对于恶意的stopService，它破解程序的执行环境，直接影响到程序的正常运行。要想杜绝Service组件被人恶意的启动或者停止，就需要使用Android系统的权限机制来对调用者进行控制。如果Service组件不想被程序外的其他组件访问，可以直接设置它的android:exported属性为false，如果是同一作者的多个程序共享使用该服务，则可以使用自定义的权限，这在Activity的权限攻击已经介绍过，这里就不铺开来说了。\n\n## Content Provider ##\nContent Provider 用于程序之间数据交换。Android系统中，每个应用的数据库、文件、资源等信息都是私有的，其他程序无法访问，如果想要访问这些数据，就必须提供一种程序之间数据的访问机制，这就是Content Provider的由来。一个典型的Content Provider声明如下：\n\n\t<provider\n\t\tandroid:name=\"com.test.providerhehe\"\n\t\tandroid:authorities=\"cpm.test.heheprovider\"\n\t\tandroid:readPermission=\"droider.permission.FILE_READ\"\n\t\tandroid:writePermission=\"droider.permission.FILE_WRITE\"\n\t>\n\nContent Provider提供了insert()、delete()、update()、query()等操作，其中执行query()查询操作时会执行读权限android:readPermission检查，其他的操作会执行写权限android:writePermission检查，权限检查失败时会抛出SecurityException异常。对于很多开发人员来说，在声明Content Provider 时几乎从来不使用这两个权限，这导致了串谋攻击发生的可能。部分网络软件开发商使用Content Provider来实现软件登陆、用户密码修改等敏感度极高的操作，然而声明的Content Provider却没有权限控制，这使得一些恶意软件无需任何权限就可以获取用户的敏感信息。\n\n## 串谋权限攻击 ##\nAndroid程序中资源的访问包括使用Framework提供的功能与访问其他程序的组件，前者是通过系统提供的权限机制进行控制的，后者是通过自定义权限控制的。正常情况下，没有声明特定的访问权限，就无法访问这些资源。但通过其他程序中可访问的Android组件，就有可能突破这种访问控制，从而提升程序本身的权限，这种权限提升的攻击方式在这称为串谋权限攻击。\n\n![串谋权限攻击示意图](https://cloud.githubusercontent.com/assets/10484766/11139875/7c3829ba-8a0f-11e5-838c-83064d88a724.png)\n\n这里可以模拟一个场景，有一个下载管理程序实例DownloadManager，有一个TextView输入想要下载的文件URL，点击下载按钮即开始下载，下载下来的文件默认保存在SD卡上。当然，该实例拥有下载文件和保存SD卡的权利：\n\n\t<uses-permission androidLname=\"android.permission.WRITE_EXTERNAL_STORAGE/\">\n\t<uses-permission android:name=\"android.permission.INTERNET\">\n\n下载文件的功能是通过接收下载请求广播，然后在下载广播接收者中完成的，对应的广播接收者在AndroidManifest.xml中声明：\n\n\t<receiver android:name=\".DownloadReceiver\">\n\t\t<intent-filter>\n\t\t\t<action android:name=\"com.test.download\"></action>\n\t\t</intent-filter>\n\t</receiver>\n\nDownloadReceiver响应Action为\"com.test.download\"的广播，然后访问Intent指定的URL地址去下载文件，相应的广播响应代码如下：\n\n\tpublic void onReceive(Context context,Intent intent){\n\t\tif(intent.getAction().equals(\"com.test.download\")){\n\t\t\tString url = intent.getExtra().getString(\"url\");\n\t\t\tString filename = intent.getExtra().getString(\"filename\");\n\t\t\tToast.makeText(context,url,Toast.LENGTH_SHORT).show();\n\t\t\ttry{\n\t\t\t\tdownloadFile(url,filename);\n\t\t\t}catch(IOException e){\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\n从上面代码可以清楚地看到，下载的文件时通过url传递过来而保存的文件名则是通过filename传递。接下来就是我们的攻击程序HackerDownloader，它什么权限都没有，只有一段发送文件下载请求的代码：\n\n\tbtn.setOnClickListener(new OnClickListener(){\n\t\t@override\n\t\tpublic void onClick(){\n\t\t\tIntent intent = new Intent();//创建Intent对象\n\t\t\tintent.setAction(\"com.test.download\");\n\t\t\tintent.putExtra(\"url\",\"http://********\");//要下载文件url地址\n\t\t\tString fileName = \"test.txt\";\n\t\t\tintent.putExtra(\"filename\",fileName);\n\t\t\tsendBroadcast(intent);\n\t\t}\n\t});\n\n当HackerDownloader点击下载按钮以后，DownloadReceiver收到广播后就会开始下载相对应的文件并保存到指定目录下。至此，一次完美的串谋攻击就完成了。\n\n","source":"_posts/简析Android组件安全.md","raw":"title: 简析Android组件安全\ndate: 2016/6/14 17：57\n\ncategories:\n- Mobile\ntags:\n- android\n---\n\n# 前言 #\n前段时间在学习github上DroidPlgin插件的时候接触到不少专业术语，诸如预先占坑、Activity劫持和Hook等，一开始看还真是感觉雾里看花。在查阅资料的过程中发现了国人出版的《Android软件安全与逆向分析》，在理解Activity劫持的过程中引申了Android四大组件的安全。知识点不难却感觉蛮有趣，故分享之。<!-- more -->\n\n## Activity ##\nAndroid组件是用户唯一能够看见的组件，作为软件所有功能的显示载体，其安全问题是最应该受到关注的\n### 权限攻击 ###\n正如Android开发文档中所说的，Android系统组件在制定Intent过滤器（intent-filter）后，默认是可以被外部程序访问的。这就很意味着很容易被其他程序进行串谋攻击，关于串谋攻击，在分享最后再做一个简单的解析。现在问题是，如何防止Activity被外部使用呢？\n\nAndroid所有组件声明时可以通过指定android:exported属性值为false，来设置组件不能被外部程序调用。这里的外部程序是指签名不同、用户ID不同的程序，签名相同且用户ID相同的程序在执行时共享同一个进程空间，彼此之间是没有组件访问限制的。如果希望Activity能够被特定的程序访问，就不能用android:exported属性了，可以使用android:permission属性来指定一个权限字符串，声明例子如下：\n\n\n    <Activity android:name=\".MyActivity\"\n           android:permission=\"com.test.permission.MyActivity\">\n           <intent-filter>\n               <action android:name=\"com.test.action\"></action>\n           </intent-filter>\n    </Activity>\n\n这样声明的Activity在被调用时，Android系统就会检查调用者是否具有com.test.permission.MyActivity权限，如果不具备就会触发一个SecurityException安全异常。要想启动该Activity必须在AndroidManifest.xml文件中加入以下声明：\n    \n    <uses-permission android:name=\"com.test.permission.MyActivity\">\n\n### Activity劫持 ###\n当用户安装了带有Activity劫持功能的恶意程序后，恶意程序会遍历系统中运行的程序，当检测到需要劫持的Activity（通常是网银或其他网络程序的等登陆界面）在前台运行时，恶意程序就会启动一个带FLAG\\_ACTIVITY\\_NEW\\_TASK标志的钓鱼式Activity覆盖正常的Activity，从而欺骗输入用户名或密码信息，当用户输入完信息后，程序就会将信息发送到指定的网址或邮箱，然后切换到正常的Activity中。这就是Activity劫持原理。从受影响的角度看，Activity属于用户层安全，程序员无法控制。\n\n下面做一个简单的劫持例子。实例可以对多个进程进行劫持，它在启动时启动了一个Hack服务，Hack服务创建了一个定时器，定时器每隔2秒就检测一次系统正在运行的进程，判断前台运行的进程是否匹配劫持的进程列表中，如果匹配就进行劫持：\n\n    private TimeTask mTask = new TimeTask(){\n    \n        @Override\n        public void run(){\n         \tActivityManager am = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE);\n            List<RunningAppProcessInfo> infos = am.getRunningAppProcesses();\n            //枚举进程\n            for(RunningAppProcessInfo psinfo:infos){\n                if(psinfo.importance == RunningAppProcessInfo.IMPORTANCE_FOREGROUND){ //前台进程\n                 \tif(hackList.contains(psinfo.processName)){\n \t                    Intent intent = new Intent(getBaseContent(),HackerActivity.class);\n                        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)；\n                        intent.putExtra(\"processname\",psinfo.processName);\n                        getApplication().startActivity(intent);//启动伪造的Activity\n                    }\n                 }\n            }\n        }\n\n    }\n\nActivity劫持不需要在AndroidManifest.xml中声明任何权限就可以实现，一般的防病毒软件也无法检测，手机用户更是防不胜防。不过有一种方法可以判断当前Activity是否被劫持：长按Home键不放，系统显示最近运行过的程序列表。在本例中，HackerActvity显示在最前面，很显然这个程序就有劫持Actvity的嫌疑。\n\nUnfortunately，这种检测Activity劫持的方法并不是任何时候都有效的，假如在声明Activity时，设置android:excludeFromRecents的值为true，程序在运行时就不会显示在最近运行过的程序列表中，上面的检测方法也就只能hehe了。\n\n## Broadcast Receiver ##\nBroadcast Receiver用于处理发送和接收广播，这里分为发送安全和接收安全。接收广播涉及串谋攻击，这里先不作介绍，下面主要介绍发送广播安全。先来一段熟悉的代码:\n\n\tIntent intent = new Intent();\n\tintent.setAction(\"com.test.broadcast\");\n\tintent.putExtra(\"data\",Math.random());\n\tsendBroadcast(intent);\n\n这段代码发送了一个Action为com.test.broadcast的广播。我们都知道，Android系统提供了两种广播发送方法，分别是sendBroadcast()和sendOrderedBroadcast()。sendBroadcast()用于发送无序广播，该广播能够被所有广播接受者接收，并且不能被abortBroadcast()终止，sendOrderedBroadcast()用于发送有序广播，该广播被优先级高的广播接收者有限接收，然后依次向下传递，优先级高的广播接收者可以篡改广播，或者调用abortBroadcast()终止广播。广播优先级响应的计算方法是：动态注册的广播接收者比静态广播接收者的优先级高，静态广播接收者的优先级根据设置的android:priority属性的数值来决定，数值越大，优先级越高。\n\n从上面分析可以得知，假如Hacker动态注册一个Action为com.test.broadcast的广播接收者，并且拥有最高的优先级，上述程序假如使用sendBroadcast()发送广播，Hacker的确无法通过abortBroadcast()终止，但可以优先响应该实例发送的广播；但是假如上述程序使用sendOrderedBroadcast()发送，很有可能BroadcastReceiver实例就永远无法收到自己发送的广播。\n\n当然，上述问题也是可以避免的。在发送广播时通过Intent指定具体要发送到的Android组件或类，广播就永远只能被本实例指定的类所接收，如：\n\n\tintent,setClass(MainActivity.this,test.class);\n\n## Service ##\nService组件是Android系统中的后台进程，主要的功能是在后台进行一些耗时的操作。与其他的Android组件一样，当声明Service时指定了Intent过滤器，该Service默认就可以被外部访问。可以访问的方法有：\n\n>startService():启动服务，可以被用来实现串谋攻击。\n\n>bindService():绑定服务，可以被用来实现串谋攻击。\n\n>stopService():停止服务，对程序功能进行恶意破坏。\n\n对于恶意的stopService，它破解程序的执行环境，直接影响到程序的正常运行。要想杜绝Service组件被人恶意的启动或者停止，就需要使用Android系统的权限机制来对调用者进行控制。如果Service组件不想被程序外的其他组件访问，可以直接设置它的android:exported属性为false，如果是同一作者的多个程序共享使用该服务，则可以使用自定义的权限，这在Activity的权限攻击已经介绍过，这里就不铺开来说了。\n\n## Content Provider ##\nContent Provider 用于程序之间数据交换。Android系统中，每个应用的数据库、文件、资源等信息都是私有的，其他程序无法访问，如果想要访问这些数据，就必须提供一种程序之间数据的访问机制，这就是Content Provider的由来。一个典型的Content Provider声明如下：\n\n\t<provider\n\t\tandroid:name=\"com.test.providerhehe\"\n\t\tandroid:authorities=\"cpm.test.heheprovider\"\n\t\tandroid:readPermission=\"droider.permission.FILE_READ\"\n\t\tandroid:writePermission=\"droider.permission.FILE_WRITE\"\n\t>\n\nContent Provider提供了insert()、delete()、update()、query()等操作，其中执行query()查询操作时会执行读权限android:readPermission检查，其他的操作会执行写权限android:writePermission检查，权限检查失败时会抛出SecurityException异常。对于很多开发人员来说，在声明Content Provider 时几乎从来不使用这两个权限，这导致了串谋攻击发生的可能。部分网络软件开发商使用Content Provider来实现软件登陆、用户密码修改等敏感度极高的操作，然而声明的Content Provider却没有权限控制，这使得一些恶意软件无需任何权限就可以获取用户的敏感信息。\n\n## 串谋权限攻击 ##\nAndroid程序中资源的访问包括使用Framework提供的功能与访问其他程序的组件，前者是通过系统提供的权限机制进行控制的，后者是通过自定义权限控制的。正常情况下，没有声明特定的访问权限，就无法访问这些资源。但通过其他程序中可访问的Android组件，就有可能突破这种访问控制，从而提升程序本身的权限，这种权限提升的攻击方式在这称为串谋权限攻击。\n\n![串谋权限攻击示意图](https://cloud.githubusercontent.com/assets/10484766/11139875/7c3829ba-8a0f-11e5-838c-83064d88a724.png)\n\n这里可以模拟一个场景，有一个下载管理程序实例DownloadManager，有一个TextView输入想要下载的文件URL，点击下载按钮即开始下载，下载下来的文件默认保存在SD卡上。当然，该实例拥有下载文件和保存SD卡的权利：\n\n\t<uses-permission androidLname=\"android.permission.WRITE_EXTERNAL_STORAGE/\">\n\t<uses-permission android:name=\"android.permission.INTERNET\">\n\n下载文件的功能是通过接收下载请求广播，然后在下载广播接收者中完成的，对应的广播接收者在AndroidManifest.xml中声明：\n\n\t<receiver android:name=\".DownloadReceiver\">\n\t\t<intent-filter>\n\t\t\t<action android:name=\"com.test.download\"></action>\n\t\t</intent-filter>\n\t</receiver>\n\nDownloadReceiver响应Action为\"com.test.download\"的广播，然后访问Intent指定的URL地址去下载文件，相应的广播响应代码如下：\n\n\tpublic void onReceive(Context context,Intent intent){\n\t\tif(intent.getAction().equals(\"com.test.download\")){\n\t\t\tString url = intent.getExtra().getString(\"url\");\n\t\t\tString filename = intent.getExtra().getString(\"filename\");\n\t\t\tToast.makeText(context,url,Toast.LENGTH_SHORT).show();\n\t\t\ttry{\n\t\t\t\tdownloadFile(url,filename);\n\t\t\t}catch(IOException e){\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\n从上面代码可以清楚地看到，下载的文件时通过url传递过来而保存的文件名则是通过filename传递。接下来就是我们的攻击程序HackerDownloader，它什么权限都没有，只有一段发送文件下载请求的代码：\n\n\tbtn.setOnClickListener(new OnClickListener(){\n\t\t@override\n\t\tpublic void onClick(){\n\t\t\tIntent intent = new Intent();//创建Intent对象\n\t\t\tintent.setAction(\"com.test.download\");\n\t\t\tintent.putExtra(\"url\",\"http://********\");//要下载文件url地址\n\t\t\tString fileName = \"test.txt\";\n\t\t\tintent.putExtra(\"filename\",fileName);\n\t\t\tsendBroadcast(intent);\n\t\t}\n\t});\n\n当HackerDownloader点击下载按钮以后，DownloadReceiver收到广播后就会开始下载相对应的文件并保存到指定目录下。至此，一次完美的串谋攻击就完成了。\n\n","slug":"简析Android组件安全","published":1,"updated":"2018-01-28T15:39:34.393Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjcyyg7kl000rniusx27na9cz","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>前段时间在学习github上DroidPlgin插件的时候接触到不少专业术语，诸如预先占坑、Activity劫持和Hook等，一开始看还真是感觉雾里看花。在查阅资料的过程中发现了国人出版的《Android软件安全与逆向分析》，在理解Activity劫持的过程中引申了Android四大组件的安全。知识点不难却感觉蛮有趣，故分享之。<a id=\"more\"></a></p>\n<h2 id=\"Activity\"><a href=\"#Activity\" class=\"headerlink\" title=\"Activity\"></a>Activity</h2><p>Android组件是用户唯一能够看见的组件，作为软件所有功能的显示载体，其安全问题是最应该受到关注的</p>\n<h3 id=\"权限攻击\"><a href=\"#权限攻击\" class=\"headerlink\" title=\"权限攻击\"></a>权限攻击</h3><p>正如Android开发文档中所说的，Android系统组件在制定Intent过滤器（intent-filter）后，默认是可以被外部程序访问的。这就很意味着很容易被其他程序进行串谋攻击，关于串谋攻击，在分享最后再做一个简单的解析。现在问题是，如何防止Activity被外部使用呢？</p>\n<p>Android所有组件声明时可以通过指定android:exported属性值为false，来设置组件不能被外部程序调用。这里的外部程序是指签名不同、用户ID不同的程序，签名相同且用户ID相同的程序在执行时共享同一个进程空间，彼此之间是没有组件访问限制的。如果希望Activity能够被特定的程序访问，就不能用android:exported属性了，可以使用android:permission属性来指定一个权限字符串，声明例子如下：</p>\n<pre><code>&lt;Activity android:name=&quot;.MyActivity&quot;\n       android:permission=&quot;com.test.permission.MyActivity&quot;&gt;\n       &lt;intent-filter&gt;\n           &lt;action android:name=&quot;com.test.action&quot;&gt;&lt;/action&gt;\n       &lt;/intent-filter&gt;\n&lt;/Activity&gt;\n</code></pre><p>这样声明的Activity在被调用时，Android系统就会检查调用者是否具有com.test.permission.MyActivity权限，如果不具备就会触发一个SecurityException安全异常。要想启动该Activity必须在AndroidManifest.xml文件中加入以下声明：</p>\n<pre><code>&lt;uses-permission android:name=&quot;com.test.permission.MyActivity&quot;&gt;\n</code></pre><h3 id=\"Activity劫持\"><a href=\"#Activity劫持\" class=\"headerlink\" title=\"Activity劫持\"></a>Activity劫持</h3><p>当用户安装了带有Activity劫持功能的恶意程序后，恶意程序会遍历系统中运行的程序，当检测到需要劫持的Activity（通常是网银或其他网络程序的等登陆界面）在前台运行时，恶意程序就会启动一个带FLAG_ACTIVITY_NEW_TASK标志的钓鱼式Activity覆盖正常的Activity，从而欺骗输入用户名或密码信息，当用户输入完信息后，程序就会将信息发送到指定的网址或邮箱，然后切换到正常的Activity中。这就是Activity劫持原理。从受影响的角度看，Activity属于用户层安全，程序员无法控制。</p>\n<p>下面做一个简单的劫持例子。实例可以对多个进程进行劫持，它在启动时启动了一个Hack服务，Hack服务创建了一个定时器，定时器每隔2秒就检测一次系统正在运行的进程，判断前台运行的进程是否匹配劫持的进程列表中，如果匹配就进行劫持：</p>\n<pre><code>private TimeTask mTask = new TimeTask(){\n\n    @Override\n    public void run(){\n         ActivityManager am = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE);\n        List&lt;RunningAppProcessInfo&gt; infos = am.getRunningAppProcesses();\n        //枚举进程\n        for(RunningAppProcessInfo psinfo:infos){\n            if(psinfo.importance == RunningAppProcessInfo.IMPORTANCE_FOREGROUND){ //前台进程\n                 if(hackList.contains(psinfo.processName)){\n                     Intent intent = new Intent(getBaseContent(),HackerActivity.class);\n                    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)；\n                    intent.putExtra(&quot;processname&quot;,psinfo.processName);\n                    getApplication().startActivity(intent);//启动伪造的Activity\n                }\n             }\n        }\n    }\n\n}\n</code></pre><p>Activity劫持不需要在AndroidManifest.xml中声明任何权限就可以实现，一般的防病毒软件也无法检测，手机用户更是防不胜防。不过有一种方法可以判断当前Activity是否被劫持：长按Home键不放，系统显示最近运行过的程序列表。在本例中，HackerActvity显示在最前面，很显然这个程序就有劫持Actvity的嫌疑。</p>\n<p>Unfortunately，这种检测Activity劫持的方法并不是任何时候都有效的，假如在声明Activity时，设置android:excludeFromRecents的值为true，程序在运行时就不会显示在最近运行过的程序列表中，上面的检测方法也就只能hehe了。</p>\n<h2 id=\"Broadcast-Receiver\"><a href=\"#Broadcast-Receiver\" class=\"headerlink\" title=\"Broadcast Receiver\"></a>Broadcast Receiver</h2><p>Broadcast Receiver用于处理发送和接收广播，这里分为发送安全和接收安全。接收广播涉及串谋攻击，这里先不作介绍，下面主要介绍发送广播安全。先来一段熟悉的代码:</p>\n<pre><code>Intent intent = new Intent();\nintent.setAction(&quot;com.test.broadcast&quot;);\nintent.putExtra(&quot;data&quot;,Math.random());\nsendBroadcast(intent);\n</code></pre><p>这段代码发送了一个Action为com.test.broadcast的广播。我们都知道，Android系统提供了两种广播发送方法，分别是sendBroadcast()和sendOrderedBroadcast()。sendBroadcast()用于发送无序广播，该广播能够被所有广播接受者接收，并且不能被abortBroadcast()终止，sendOrderedBroadcast()用于发送有序广播，该广播被优先级高的广播接收者有限接收，然后依次向下传递，优先级高的广播接收者可以篡改广播，或者调用abortBroadcast()终止广播。广播优先级响应的计算方法是：动态注册的广播接收者比静态广播接收者的优先级高，静态广播接收者的优先级根据设置的android:priority属性的数值来决定，数值越大，优先级越高。</p>\n<p>从上面分析可以得知，假如Hacker动态注册一个Action为com.test.broadcast的广播接收者，并且拥有最高的优先级，上述程序假如使用sendBroadcast()发送广播，Hacker的确无法通过abortBroadcast()终止，但可以优先响应该实例发送的广播；但是假如上述程序使用sendOrderedBroadcast()发送，很有可能BroadcastReceiver实例就永远无法收到自己发送的广播。</p>\n<p>当然，上述问题也是可以避免的。在发送广播时通过Intent指定具体要发送到的Android组件或类，广播就永远只能被本实例指定的类所接收，如：</p>\n<pre><code>intent,setClass(MainActivity.this,test.class);\n</code></pre><h2 id=\"Service\"><a href=\"#Service\" class=\"headerlink\" title=\"Service\"></a>Service</h2><p>Service组件是Android系统中的后台进程，主要的功能是在后台进行一些耗时的操作。与其他的Android组件一样，当声明Service时指定了Intent过滤器，该Service默认就可以被外部访问。可以访问的方法有：</p>\n<blockquote>\n<p>startService():启动服务，可以被用来实现串谋攻击。</p>\n<p>bindService():绑定服务，可以被用来实现串谋攻击。</p>\n<p>stopService():停止服务，对程序功能进行恶意破坏。</p>\n</blockquote>\n<p>对于恶意的stopService，它破解程序的执行环境，直接影响到程序的正常运行。要想杜绝Service组件被人恶意的启动或者停止，就需要使用Android系统的权限机制来对调用者进行控制。如果Service组件不想被程序外的其他组件访问，可以直接设置它的android:exported属性为false，如果是同一作者的多个程序共享使用该服务，则可以使用自定义的权限，这在Activity的权限攻击已经介绍过，这里就不铺开来说了。</p>\n<h2 id=\"Content-Provider\"><a href=\"#Content-Provider\" class=\"headerlink\" title=\"Content Provider\"></a>Content Provider</h2><p>Content Provider 用于程序之间数据交换。Android系统中，每个应用的数据库、文件、资源等信息都是私有的，其他程序无法访问，如果想要访问这些数据，就必须提供一种程序之间数据的访问机制，这就是Content Provider的由来。一个典型的Content Provider声明如下：</p>\n<pre><code>&lt;provider\n    android:name=&quot;com.test.providerhehe&quot;\n    android:authorities=&quot;cpm.test.heheprovider&quot;\n    android:readPermission=&quot;droider.permission.FILE_READ&quot;\n    android:writePermission=&quot;droider.permission.FILE_WRITE&quot;\n&gt;\n</code></pre><p>Content Provider提供了insert()、delete()、update()、query()等操作，其中执行query()查询操作时会执行读权限android:readPermission检查，其他的操作会执行写权限android:writePermission检查，权限检查失败时会抛出SecurityException异常。对于很多开发人员来说，在声明Content Provider 时几乎从来不使用这两个权限，这导致了串谋攻击发生的可能。部分网络软件开发商使用Content Provider来实现软件登陆、用户密码修改等敏感度极高的操作，然而声明的Content Provider却没有权限控制，这使得一些恶意软件无需任何权限就可以获取用户的敏感信息。</p>\n<h2 id=\"串谋权限攻击\"><a href=\"#串谋权限攻击\" class=\"headerlink\" title=\"串谋权限攻击\"></a>串谋权限攻击</h2><p>Android程序中资源的访问包括使用Framework提供的功能与访问其他程序的组件，前者是通过系统提供的权限机制进行控制的，后者是通过自定义权限控制的。正常情况下，没有声明特定的访问权限，就无法访问这些资源。但通过其他程序中可访问的Android组件，就有可能突破这种访问控制，从而提升程序本身的权限，这种权限提升的攻击方式在这称为串谋权限攻击。</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/10484766/11139875/7c3829ba-8a0f-11e5-838c-83064d88a724.png\" alt=\"串谋权限攻击示意图\"></p>\n<p>这里可以模拟一个场景，有一个下载管理程序实例DownloadManager，有一个TextView输入想要下载的文件URL，点击下载按钮即开始下载，下载下来的文件默认保存在SD卡上。当然，该实例拥有下载文件和保存SD卡的权利：</p>\n<pre><code>&lt;uses-permission androidLname=&quot;android.permission.WRITE_EXTERNAL_STORAGE/&quot;&gt;\n&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;&gt;\n</code></pre><p>下载文件的功能是通过接收下载请求广播，然后在下载广播接收者中完成的，对应的广播接收者在AndroidManifest.xml中声明：</p>\n<pre><code>&lt;receiver android:name=&quot;.DownloadReceiver&quot;&gt;\n    &lt;intent-filter&gt;\n        &lt;action android:name=&quot;com.test.download&quot;&gt;&lt;/action&gt;\n    &lt;/intent-filter&gt;\n&lt;/receiver&gt;\n</code></pre><p>DownloadReceiver响应Action为”com.test.download”的广播，然后访问Intent指定的URL地址去下载文件，相应的广播响应代码如下：</p>\n<pre><code>public void onReceive(Context context,Intent intent){\n    if(intent.getAction().equals(&quot;com.test.download&quot;)){\n        String url = intent.getExtra().getString(&quot;url&quot;);\n        String filename = intent.getExtra().getString(&quot;filename&quot;);\n        Toast.makeText(context,url,Toast.LENGTH_SHORT).show();\n        try{\n            downloadFile(url,filename);\n        }catch(IOException e){\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre><p>从上面代码可以清楚地看到，下载的文件时通过url传递过来而保存的文件名则是通过filename传递。接下来就是我们的攻击程序HackerDownloader，它什么权限都没有，只有一段发送文件下载请求的代码：</p>\n<pre><code>btn.setOnClickListener(new OnClickListener(){\n    @override\n    public void onClick(){\n        Intent intent = new Intent();//创建Intent对象\n        intent.setAction(&quot;com.test.download&quot;);\n        intent.putExtra(&quot;url&quot;,&quot;http://********&quot;);//要下载文件url地址\n        String fileName = &quot;test.txt&quot;;\n        intent.putExtra(&quot;filename&quot;,fileName);\n        sendBroadcast(intent);\n    }\n});\n</code></pre><p>当HackerDownloader点击下载按钮以后，DownloadReceiver收到广播后就会开始下载相对应的文件并保存到指定目录下。至此，一次完美的串谋攻击就完成了。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>前段时间在学习github上DroidPlgin插件的时候接触到不少专业术语，诸如预先占坑、Activity劫持和Hook等，一开始看还真是感觉雾里看花。在查阅资料的过程中发现了国人出版的《Android软件安全与逆向分析》，在理解Activity劫持的过程中引申了Android四大组件的安全。知识点不难却感觉蛮有趣，故分享之。","more":"</p>\n<h2 id=\"Activity\"><a href=\"#Activity\" class=\"headerlink\" title=\"Activity\"></a>Activity</h2><p>Android组件是用户唯一能够看见的组件，作为软件所有功能的显示载体，其安全问题是最应该受到关注的</p>\n<h3 id=\"权限攻击\"><a href=\"#权限攻击\" class=\"headerlink\" title=\"权限攻击\"></a>权限攻击</h3><p>正如Android开发文档中所说的，Android系统组件在制定Intent过滤器（intent-filter）后，默认是可以被外部程序访问的。这就很意味着很容易被其他程序进行串谋攻击，关于串谋攻击，在分享最后再做一个简单的解析。现在问题是，如何防止Activity被外部使用呢？</p>\n<p>Android所有组件声明时可以通过指定android:exported属性值为false，来设置组件不能被外部程序调用。这里的外部程序是指签名不同、用户ID不同的程序，签名相同且用户ID相同的程序在执行时共享同一个进程空间，彼此之间是没有组件访问限制的。如果希望Activity能够被特定的程序访问，就不能用android:exported属性了，可以使用android:permission属性来指定一个权限字符串，声明例子如下：</p>\n<pre><code>&lt;Activity android:name=&quot;.MyActivity&quot;\n       android:permission=&quot;com.test.permission.MyActivity&quot;&gt;\n       &lt;intent-filter&gt;\n           &lt;action android:name=&quot;com.test.action&quot;&gt;&lt;/action&gt;\n       &lt;/intent-filter&gt;\n&lt;/Activity&gt;\n</code></pre><p>这样声明的Activity在被调用时，Android系统就会检查调用者是否具有com.test.permission.MyActivity权限，如果不具备就会触发一个SecurityException安全异常。要想启动该Activity必须在AndroidManifest.xml文件中加入以下声明：</p>\n<pre><code>&lt;uses-permission android:name=&quot;com.test.permission.MyActivity&quot;&gt;\n</code></pre><h3 id=\"Activity劫持\"><a href=\"#Activity劫持\" class=\"headerlink\" title=\"Activity劫持\"></a>Activity劫持</h3><p>当用户安装了带有Activity劫持功能的恶意程序后，恶意程序会遍历系统中运行的程序，当检测到需要劫持的Activity（通常是网银或其他网络程序的等登陆界面）在前台运行时，恶意程序就会启动一个带FLAG_ACTIVITY_NEW_TASK标志的钓鱼式Activity覆盖正常的Activity，从而欺骗输入用户名或密码信息，当用户输入完信息后，程序就会将信息发送到指定的网址或邮箱，然后切换到正常的Activity中。这就是Activity劫持原理。从受影响的角度看，Activity属于用户层安全，程序员无法控制。</p>\n<p>下面做一个简单的劫持例子。实例可以对多个进程进行劫持，它在启动时启动了一个Hack服务，Hack服务创建了一个定时器，定时器每隔2秒就检测一次系统正在运行的进程，判断前台运行的进程是否匹配劫持的进程列表中，如果匹配就进行劫持：</p>\n<pre><code>private TimeTask mTask = new TimeTask(){\n\n    @Override\n    public void run(){\n         ActivityManager am = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE);\n        List&lt;RunningAppProcessInfo&gt; infos = am.getRunningAppProcesses();\n        //枚举进程\n        for(RunningAppProcessInfo psinfo:infos){\n            if(psinfo.importance == RunningAppProcessInfo.IMPORTANCE_FOREGROUND){ //前台进程\n                 if(hackList.contains(psinfo.processName)){\n                     Intent intent = new Intent(getBaseContent(),HackerActivity.class);\n                    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)；\n                    intent.putExtra(&quot;processname&quot;,psinfo.processName);\n                    getApplication().startActivity(intent);//启动伪造的Activity\n                }\n             }\n        }\n    }\n\n}\n</code></pre><p>Activity劫持不需要在AndroidManifest.xml中声明任何权限就可以实现，一般的防病毒软件也无法检测，手机用户更是防不胜防。不过有一种方法可以判断当前Activity是否被劫持：长按Home键不放，系统显示最近运行过的程序列表。在本例中，HackerActvity显示在最前面，很显然这个程序就有劫持Actvity的嫌疑。</p>\n<p>Unfortunately，这种检测Activity劫持的方法并不是任何时候都有效的，假如在声明Activity时，设置android:excludeFromRecents的值为true，程序在运行时就不会显示在最近运行过的程序列表中，上面的检测方法也就只能hehe了。</p>\n<h2 id=\"Broadcast-Receiver\"><a href=\"#Broadcast-Receiver\" class=\"headerlink\" title=\"Broadcast Receiver\"></a>Broadcast Receiver</h2><p>Broadcast Receiver用于处理发送和接收广播，这里分为发送安全和接收安全。接收广播涉及串谋攻击，这里先不作介绍，下面主要介绍发送广播安全。先来一段熟悉的代码:</p>\n<pre><code>Intent intent = new Intent();\nintent.setAction(&quot;com.test.broadcast&quot;);\nintent.putExtra(&quot;data&quot;,Math.random());\nsendBroadcast(intent);\n</code></pre><p>这段代码发送了一个Action为com.test.broadcast的广播。我们都知道，Android系统提供了两种广播发送方法，分别是sendBroadcast()和sendOrderedBroadcast()。sendBroadcast()用于发送无序广播，该广播能够被所有广播接受者接收，并且不能被abortBroadcast()终止，sendOrderedBroadcast()用于发送有序广播，该广播被优先级高的广播接收者有限接收，然后依次向下传递，优先级高的广播接收者可以篡改广播，或者调用abortBroadcast()终止广播。广播优先级响应的计算方法是：动态注册的广播接收者比静态广播接收者的优先级高，静态广播接收者的优先级根据设置的android:priority属性的数值来决定，数值越大，优先级越高。</p>\n<p>从上面分析可以得知，假如Hacker动态注册一个Action为com.test.broadcast的广播接收者，并且拥有最高的优先级，上述程序假如使用sendBroadcast()发送广播，Hacker的确无法通过abortBroadcast()终止，但可以优先响应该实例发送的广播；但是假如上述程序使用sendOrderedBroadcast()发送，很有可能BroadcastReceiver实例就永远无法收到自己发送的广播。</p>\n<p>当然，上述问题也是可以避免的。在发送广播时通过Intent指定具体要发送到的Android组件或类，广播就永远只能被本实例指定的类所接收，如：</p>\n<pre><code>intent,setClass(MainActivity.this,test.class);\n</code></pre><h2 id=\"Service\"><a href=\"#Service\" class=\"headerlink\" title=\"Service\"></a>Service</h2><p>Service组件是Android系统中的后台进程，主要的功能是在后台进行一些耗时的操作。与其他的Android组件一样，当声明Service时指定了Intent过滤器，该Service默认就可以被外部访问。可以访问的方法有：</p>\n<blockquote>\n<p>startService():启动服务，可以被用来实现串谋攻击。</p>\n<p>bindService():绑定服务，可以被用来实现串谋攻击。</p>\n<p>stopService():停止服务，对程序功能进行恶意破坏。</p>\n</blockquote>\n<p>对于恶意的stopService，它破解程序的执行环境，直接影响到程序的正常运行。要想杜绝Service组件被人恶意的启动或者停止，就需要使用Android系统的权限机制来对调用者进行控制。如果Service组件不想被程序外的其他组件访问，可以直接设置它的android:exported属性为false，如果是同一作者的多个程序共享使用该服务，则可以使用自定义的权限，这在Activity的权限攻击已经介绍过，这里就不铺开来说了。</p>\n<h2 id=\"Content-Provider\"><a href=\"#Content-Provider\" class=\"headerlink\" title=\"Content Provider\"></a>Content Provider</h2><p>Content Provider 用于程序之间数据交换。Android系统中，每个应用的数据库、文件、资源等信息都是私有的，其他程序无法访问，如果想要访问这些数据，就必须提供一种程序之间数据的访问机制，这就是Content Provider的由来。一个典型的Content Provider声明如下：</p>\n<pre><code>&lt;provider\n    android:name=&quot;com.test.providerhehe&quot;\n    android:authorities=&quot;cpm.test.heheprovider&quot;\n    android:readPermission=&quot;droider.permission.FILE_READ&quot;\n    android:writePermission=&quot;droider.permission.FILE_WRITE&quot;\n&gt;\n</code></pre><p>Content Provider提供了insert()、delete()、update()、query()等操作，其中执行query()查询操作时会执行读权限android:readPermission检查，其他的操作会执行写权限android:writePermission检查，权限检查失败时会抛出SecurityException异常。对于很多开发人员来说，在声明Content Provider 时几乎从来不使用这两个权限，这导致了串谋攻击发生的可能。部分网络软件开发商使用Content Provider来实现软件登陆、用户密码修改等敏感度极高的操作，然而声明的Content Provider却没有权限控制，这使得一些恶意软件无需任何权限就可以获取用户的敏感信息。</p>\n<h2 id=\"串谋权限攻击\"><a href=\"#串谋权限攻击\" class=\"headerlink\" title=\"串谋权限攻击\"></a>串谋权限攻击</h2><p>Android程序中资源的访问包括使用Framework提供的功能与访问其他程序的组件，前者是通过系统提供的权限机制进行控制的，后者是通过自定义权限控制的。正常情况下，没有声明特定的访问权限，就无法访问这些资源。但通过其他程序中可访问的Android组件，就有可能突破这种访问控制，从而提升程序本身的权限，这种权限提升的攻击方式在这称为串谋权限攻击。</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/10484766/11139875/7c3829ba-8a0f-11e5-838c-83064d88a724.png\" alt=\"串谋权限攻击示意图\"></p>\n<p>这里可以模拟一个场景，有一个下载管理程序实例DownloadManager，有一个TextView输入想要下载的文件URL，点击下载按钮即开始下载，下载下来的文件默认保存在SD卡上。当然，该实例拥有下载文件和保存SD卡的权利：</p>\n<pre><code>&lt;uses-permission androidLname=&quot;android.permission.WRITE_EXTERNAL_STORAGE/&quot;&gt;\n&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;&gt;\n</code></pre><p>下载文件的功能是通过接收下载请求广播，然后在下载广播接收者中完成的，对应的广播接收者在AndroidManifest.xml中声明：</p>\n<pre><code>&lt;receiver android:name=&quot;.DownloadReceiver&quot;&gt;\n    &lt;intent-filter&gt;\n        &lt;action android:name=&quot;com.test.download&quot;&gt;&lt;/action&gt;\n    &lt;/intent-filter&gt;\n&lt;/receiver&gt;\n</code></pre><p>DownloadReceiver响应Action为”com.test.download”的广播，然后访问Intent指定的URL地址去下载文件，相应的广播响应代码如下：</p>\n<pre><code>public void onReceive(Context context,Intent intent){\n    if(intent.getAction().equals(&quot;com.test.download&quot;)){\n        String url = intent.getExtra().getString(&quot;url&quot;);\n        String filename = intent.getExtra().getString(&quot;filename&quot;);\n        Toast.makeText(context,url,Toast.LENGTH_SHORT).show();\n        try{\n            downloadFile(url,filename);\n        }catch(IOException e){\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre><p>从上面代码可以清楚地看到，下载的文件时通过url传递过来而保存的文件名则是通过filename传递。接下来就是我们的攻击程序HackerDownloader，它什么权限都没有，只有一段发送文件下载请求的代码：</p>\n<pre><code>btn.setOnClickListener(new OnClickListener(){\n    @override\n    public void onClick(){\n        Intent intent = new Intent();//创建Intent对象\n        intent.setAction(&quot;com.test.download&quot;);\n        intent.putExtra(&quot;url&quot;,&quot;http://********&quot;);//要下载文件url地址\n        String fileName = &quot;test.txt&quot;;\n        intent.putExtra(&quot;filename&quot;,fileName);\n        sendBroadcast(intent);\n    }\n});\n</code></pre><p>当HackerDownloader点击下载按钮以后，DownloadReceiver收到广播后就会开始下载相对应的文件并保存到指定目录下。至此，一次完美的串谋攻击就完成了。</p>"},{"title":"简析DroidPlugin之Hook","date":"2018-01-28T15:39:34.393Z","_content":"\n# 前言 #\n被誉为“安卓黑科技”的开源框架DroidPlugin，是目前较为流行的安卓动态加载技术的典范。免安装和免修改运行第三方sdk，实现多团队协助开发，是360推出这个牛逼able框架的主打亮点。那么，它是如何一步步去实现这个神奇的框架的呢？又和我们常见的动态加载技术有何区别去值得我们学习的？由于目前国内对这个框架没太多的研究，很多地方只能做到点到即止。本文主要分享其hook的过程。<!-- more -->\n\n## 了解入口架构 ##\n\n首先，看到application的attachBaseContext方法里面做了这样一步：\n\n\t# PluginApplication.java\n\n    PluginHelper.getInstance().applicationAttachBaseContext(base);\n\n这一步并没有做太多操作，只是注册了crash之后的log发送之类的信息。这里不展开细说。\n\n在onCreate方法里有：\n\n\t# PluginApplication.java\n\n    PluginHelper.getInstance().applicationOnCreate(getBaseContext());\n\n这一步是核心操作，进行了一系列的初始化，本文也是从这里开始展开。跟代码找到了initPlugin方法：\n\n\t# PluginHelper.java\n\n    private void initPlugin(Context baseContext) {\n        long b = System.currentTimeMillis();\n        try {\n            try {\n                fixMiUiLbeSecurity();\n            } catch (Throwable e) {\n                Log.e(TAG, \"fixMiUiLbeSecurity has error\", e);\n            }\n \n            try {\n                PluginProcessManager.installHook(baseContext);\n            } catch (Throwable e) {\n                Log.e(TAG, \"installHook has error\", e);\n            }\n \t\t......\n    }\n\n看到了 PluginProcessManager.installHook(baseContext); 这是安装钩子函数（hook）相关的入口。接着往下看：\n\n\t# HookFactory.java\n\n    public final void installHook(Context context, ClassLoader classLoader) throws Throwable {\n        installHook(new IClipboardBinderHook(context), classLoader);\n        //for ISearchManager\n        installHook(new ISearchManagerBinderHook(context), classLoader);\n        //for INotificationManager\n        installHook(new INotificationManagerBinderHook(context), classLoader);\n \t\t..........\n \n        installHook(new IPackageManagerHook(context), classLoader);\n        installHook(new IActivityManagerHook(context), classLoader);\n        installHook(new PluginCallbackHook(context), classLoader);\n\t\t.......\n    }\n\n很明显，这里做了一系列系统组件的hook操作，这里以\n\n\t# HookFactory.java\n\n    installHook(new IActivityManagerHook(context), classLoader);\n\n为例，实例化 IActivityManagerHook ，这个类继承谁呢？查看该类hook的体系结构：\n\n    Hook\n    --| ProxyHook\n    ----| IActivityManagerHook\n\n基类Hook.java构造方法做了两步操作，一是初始化了hostContext，二是创建hookHandle：\n\n\t# Hook.java\n\t\n    protected Hook(Context hostContext) {\n        mHostContext = hostContext;\n        mHookHandles = createHookHandle();\n    }\n\n跟着代码走到了IActivityManagerHookHandle的init()方法。咦，代码看上去貌似很长，其实就是用一个Map去存放方法名和对应操作的键值对，这里先有个概念，后面会用到。\n\nIActivityManagerHook实例化完之后，就是installHook的方法，先贴上代码：\n\n\t# HookFactory.java \n\n    public void installHook(Hook hook, ClassLoader cl) {\n        try {\n            hook.onInstall(cl);\n            synchronized (mHookList) {\n                mHookList.add(hook);\n            }\n        } catch (Throwable throwable) {\n            Log.e(TAG, \"installHook %s error\", throwable, hook);\n        }\n    }\n\n首先，这里对刚才实例化的hook调用了onInstall方法，并传入一个classLoder，这里为空；然后把hook添加到一个List集合中去。我们看一下IActivityManagerHook的onInstall方法的前半部分：\n\n\t# IActivityManagerHook.java\n\n    public void onInstall(ClassLoader classLoader) throws Throwable {\n    \tClass cls = ActivityManagerNativeCompat.Class();\n    \tObject obj = FieldUtils.readStaticField(cls, \"gDefault\");\n   \t \tif (obj == null) {\n    \t\tActivityManagerNativeCompat.getDefault();\n    \t\tobj = FieldUtils.readStaticField(cls, \"gDefault\");\n   \t\t }\n    \n    \t.............\n    }\n\n整个onInstall方法做了两件事情：</br>\n1.找到系统的IActivityManager;</br>\n2.判断该IActivityManager是否为单例，做不同的处理\n\n## 找到Hook对象 ##\n\n我们看一下在IAcitivityManager里面\"gDefault\"这个变量是干嘛的，贴源码：\n\n\t# ActivityManagerNative.java\n\n    private static final Singleton<IActivityManager> gDefault = new Singleton<IActivityManager>() {\n        protected IActivityManager create() {\n            IBinder b = ServiceManager.getService(\"activity\");\n            if (false) {\n                Log.v(\"ActivityManager\", \"default service binder = \" + b);\n            }\n            IActivityManager am = asInterface(b);\n            if (false) {\n                Log.v(\"ActivityManager\", \"default service = \" + am);\n            }\n            return am;\n        }\n    };\n\n我们知道，Android中ActivityManager是与系统所有运行着的Activity进行交互，对系统所有运行的Activity进行管理和维护，但是这些信息真正维护并不是由ActivityManager来负责。读起来有点绕，RTFSC是王道，截取其中一段获取运行服务的方法：\n\n\t# ActivityManager.java\n\n    public List<RunningServiceInfo> getRunningServices(int maxNum)\n            throws SecurityException {\n        try {\n            return ActivityManagerNative.getDefault()\n                    .getServices(maxNum, 0);\n        } catch (RemoteException e) {\n            // System dead, we will be dead too soon!\n            return null;\n        }\n    }\n\n通过阅读ActivityManager的源码发现，所有的信息都是通过ActivityManagerNative.getDefault()来操作获取。哎呦，这里面到底是干了啥？我们先来看一幅Activity Manager相关类继承层次关系图：\n\n![](http://i.imgur.com/ToILsf2.jpg)\n\nActivityManagerProxy，见名思意，是一个代理类，同时也是ActivityManagerNative的内部类；ActivityManagerNative是一个抽象类，实现它的是ActivityManagerService，这是一个系统Service组件。\n从图中可以看出，使用ActivityManagerProxy，来代理ActivityManagerNative，实质就是代理它的实现类ActivityManagerService；ActivityManagerService是系统统一的Service，运行在独立的进程中，通过系统ServiceManger来获取。\n\n\n那么，问题来了，ActivityManager运行在一个进程里面，ActivityManagerService运行在另一个进程内，这里面涉及到跨进程的对象访问，毫无疑问，采用的是Binder机制实现。\n\n我们从刚刚截取的ActivityManagerNative.java中定义gDefault的方法可以看到，首先获取“activity”的IBinder\n\n\tIBinder b = ServiceManager.getService(\"activity\");\n\n这个可以从以下源码得知，其中sCache存放的是名字和对应IBinder的键值对Map\n\n\t# ServiceManager.java\n\n    /**\n     * Returns a reference to a service with the given name.\n     * \n     * @param name the name of the service to get\n     * @return a reference to the service, or <code>null</code> if the service doesn't exist\n     */\n    public static IBinder getService(String name) {\n        try {\n            IBinder service = sCache.get(name);\n            if (service != null) {\n                return service;\n            } else {\n                return getIServiceManager().getService(name);\n            }\n        } catch (RemoteException e) {\n            Log.e(TAG, \"error in getService\", e);\n        }\n        return null;\n    }\n\n然后通过 asInterface(b) 就获取了ActivityManagerService实例的本地代理对象ActivityManagerProxy实例：\n\n\n\t# ActivityManagerNative.java\n\n    /**\n     * Cast a Binder object into an activity manager interface, generating\n     * a proxy if needed.\n     */\n    static public IActivityManager asInterface(IBinder obj) {\n        if (obj == null) {\n            return null;\n        }\n        IActivityManager in =\n            (IActivityManager)obj.queryLocalInterface(descriptor);\n        if (in != null) {\n            return in;\n        }\n\n        return new ActivityManagerProxy(obj);\n    }\n\n贴上一图，让你瞬间有豁然开朗的感觉有木有：\n\n![](http://i.imgur.com/Au935XN.jpg)\n\nok，回到我们的最原点，找到系统的IActivityManager要干嘛？当然就是我们的劫持hook了，在说hook之前，要说说动态代理机制。\n\n## 动态代理机制 ##\n\n动态代理，是一种设计模式，可以为其他对象提供一种代理以控制对这个对象的访问。举一个肤浅的栗子：\n\n\n   \tpublic Object invoke( Object proxy, Method method, Object[] args ) throws Throwable   \n      {   \n    //1.在转调具体目标对象之前，可以执行一些功能处理\n\n    //2.转调具体目标对象的方法\n    return method.invoke( proxied, args);  \n    \n    //3.在转调具体目标对象之后，可以执行一些功能处理\n\n      }\n    } \n\n所谓代理，就是首先要获得被代理者的控制权，被代理者在正常调用的时候，代理可以在被代理者的所有方法前或后添加想要的操作。从上图简单地理解，就是在2方法（被代理者）添加1和3方法。可以看一下代理结构图：\n\n![](http://i.imgur.com/s0zRfSt.gif)\n\n在动态代理机制中，有两个重要的类，分别是InvocationHandler和Proxy。我们看一下API帮助文档是怎么对两个类做描述的：\n\nInvocationHandler：\n\n    InvocationHandler is the interface implemented by the invocation handler of a proxy instance. \n    \n    Each proxy instance has an associated invocation handler. When a method is invoked on a proxy instance, the method invocation is encoded and dispatched to the invoke method of its invocation handler.\n\n每一个动态代理类必须要实现InvocationHandler这个接口，而InvocationHandler这个接口只有唯一一个invoke方法：\n    \n    Object invoke(Object proxy, Method method, Object[] args) throws Throwable\n\n    proxy:　　指代我们所代理的那个真实对象\n    method:　 指代的是我们所要调用真实对象的某个方法的Method对象\n    args:　　 指代的是调用真实对象某个方法时接受的参数\n\nProxy：\n\n    Proxy provides static methods for creating dynamic proxy classes and instances, and it is also the superclass of all dynamic proxy classes created by those methods. \n\nProxy这个类的作用是创建一个代理对象的类，它提供了很多方法，在这里我们只需要了解到newProxyInstance 即可：\n\n    public static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h) throws IllegalArgumentException\n    \n    loader:　　  一个ClassLoader对象，定义了由哪个ClassLoader对象来对生成的代理对象进行加载   \n    interfaces:  一个Interface对象的数组，表示的是我将要给我需要代理的对象提供一组什么接口，如果我提供了一组接口给它，那么这个代理对象就宣称实现了该接口(多态)，这样我就能调用这组接口中的方法了\n   \th:　　        一个InvocationHandler对象，表示的是当我这个动态代理对象在调用方法的时候，会关联到哪一个InvocationHandler对象上\n\nok，有了点概念，我们来继续举个具体点的栗子：\n\n定义一个people的接口：\n\n    public interface People{\n    \tpublic void countMoney();\n    }\n\nboss类去实现这个接口：\n\n    public class Boss implements people{\n\t\t@Override\n\t\tpublic void countMoney(){\n\t\t\tsystem.out.println(\"I have too money to burn.\");\n\t\t}\n    } \n\n定义一个代理类workers，前面说到了，每一个代理类必须实现InvocationHandler 这个接口：\n\n\tpublic class Workers implements InvocationHandler{\n\t\t//这个是我们要代理的真实对象\n\t\tprivate Object people;\n\n\t\t//构造方法，给我们要代理的真实对象赋值\n\t\tpublic workers(Object people){\n\t\t\tthis.people = people;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object invoke(Object object, Method method, Object[] args){\n\t\t\t\n\t\t\t//在代理真实对象之前加上一些操作\n\t\t\tsystem.out.println(\"I must word hard because I have no money.\");\n\n\t\t\t//调用真实对象的相关方法\n\t\t\tmethod.invoke(subject, args);\n\n\t\t\t//在代理真实对象之后加上一些操作\n\t\t\tsystem.out.println(\"Whether you have got money or not,it's wise for you to go back home for the Spring Festival.\");\n\t\t}\n\t} \n\n编写测试类：\n\n\tpublic class test{\n\t\t....\n\t\tBoss boss = new Boss;\n\t\tInvocationHandle handle = new Workers(boss);\n\t\tWorkers workers = (Workers) Proxy.newProxyInstance(handle.getClass().getClassLoader(),boss.getClass().getInterfaces(),handle);\n\t\t\n\t\tworkers.countMoney();\n\t\t\n\t}\n\n看一下输出结果：\n\n    I must word hard because I have no money.\n    I have too money to burn.\n    Whether you have got money or not,it's wise for you to go back home for the Spring Festival.\n\n结果很明显了，如果想了解其中的跳转原理，请查看源码，这里就不多作介绍了。\n\n## 开始Hook ##\n我们来看看onInstall方法的后半部分：\n\n\t# IActivityManagerHook.java\n\n\tpublic void onInstall(ClassLoader classLoader) throws Throwable {\n\t\t.....\n\n        if (IActivityManagerCompat.isIActivityManager(obj)) {\n            setOldObj(obj);\n            Class<?> objClass = mOldObj.getClass();\n            List<Class<?>> interfaces = Utils.getAllInterfaces(objClass);\n            Class[] ifs = interfaces != null && interfaces.size() > 0 ? interfaces.toArray(new Class[interfaces.size()]) : new Class[0];\n            Object proxiedActivityManager = MyProxy.newProxyInstance(objClass.getClassLoader(), ifs, this);\n            FieldUtils.writeStaticField(cls, \"gDefault\", proxiedActivityManager);\n            Log.i(TAG, \"Install ActivityManager Hook 1 old=%s,new=%s\", mOldObj, proxiedActivityManager);\n        } \n\n\t\t\t.......\n        }\n\n首先，判断上面获取找到系统的IActivityManager是否正确，然后setOldObj(obj)保存当前系统的IActivityManager对象，留意IActivityManagerHook类是继承ProxyHook，该类实现InvocationHandler接口，就是一个代理类的实体啊。ok，你应该留意到接下来的操作就是介绍如何一步步实现代理，并把代理对象写到ActivityManagerNative的gDefault变量中，这样就实现hook了：\n\n\tObject proxiedActivityManager = MyProxy.newProxyInstance(objClass.getClassLoader(), ifs, this);\n    FieldUtils.writeStaticField(cls, \"gDefault\", proxiedActivityManager);\n\nclassLoader和获取所有接口数组都是沿用mOldObj对象。\n\nhook之后就开始干坏事了，把目光转到ProxyHook类中的invoke方法：\n\n\t# ProxyHook.java\n\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\n        try {\n            if (!isEnable()) {\n                return method.invoke(mOldObj, args);\n            }\n            HookedMethodHandler hookedMethodHandler = mHookHandles.getHookedMethodHandler(method);\n            if (hookedMethodHandler != null) {\n                return hookedMethodHandler.doHookInner(mOldObj, method, args);\n            }\n            return method.invoke(mOldObj, args);\n        } catch (InvocationTargetException e) {\n            Throwable cause = e.getTargetException();\n         .......\n    }\t\n\n首先，isEnable()先判断一下这个函数是否可以hook，不可以的话直接返回mOldObj（系统）的原本方法；可以的话继续往下走：\n\n\t# ProxyHook.java\n\n\tHookedMethodHandler hookedMethodHandler = mHookHandles.getHookedMethodHandler(method);\n    if (hookedMethodHandler != null) {\n        return hookedMethodHandler.doHookInner(mOldObj, method, args);\n    }\n\treturn method.invoke(mOldObj, args);\n\n根据方法名字获取一个hookedMethodHandler，如果不为空，则执行hookedMethodHandler的doHookInner方法；如果为空，依旧返回系统的原本方法。\n\nhookedMethodHandler是什么鬼？还记得上面提到的IActivityManagerHookHandle的init()方法？是的，这里就要用到，先看一下之前的init()代码：\n\n\t# IActivityManagerHookHandle.java\n\n    protected void init() {\n        sHookedMethodHandlers.put(\"startActivity\", new startActivity(mHostContext));\n        sHookedMethodHandlers.put(\"startActivityAsUser\", new startActivityAsUser(mHostContext));\n        sHookedMethodHandlers.put(\"startActivityAsCaller\", new startActivityAsCaller(mHostContext));\n        sHookedMethodHandlers.put(\"startActivityAndWait\", new startActivityAndWait(mHostContext));\n        sHookedMethodHandlers.put(\"startActivityWithConfig\", new startActivityWithConfig(mHostContext));\n        sHookedMethodHandlers.put(\"startActivityIntentSender\", new startActivityIntentSender(mHostContext));\n        sHookedMethodHandlers.put(\"startVoiceActivity\", new startVoiceActivity(mHostContext));\n        sHookedMethodHandlers.put(\"startNextMatchingActivity\", new startNextMatchingActivity(mHostContext));\n        sHookedMethodHandlers.put(\"startActivityFromRecents\", new startActivityFromRecents(mHostContext));\n      ...........\n    }\n\n初始化把所有方法和对应的HookedMethodHandler处理类放在一起。\n\n我们假如传入一个方法名为startActivity，hookedMethodHandler存在，并进入doHookInner方法：\n\n\t# HookedMethodHandler.java\n\n    public synchronized Object doHookInner(Object receiver, Method method, Object[] args) throws Throwable {\n        long b = System.currentTimeMillis();\n        try {\n            mUseFakedResult = false;\n            mFakedResult = null;\n            boolean suc = beforeInvoke(receiver, method, args);\n            Object invokeResult = null;\n            if (!suc) {\n                invokeResult = method.invoke(receiver, args);\n            }\n            afterInvoke(receiver, method, args, invokeResult);\n            if (mUseFakedResult) {\n                return mFakedResult;\n            } else {\n                return invokeResult;\n            }\n        } \n\t.........\n    }\n\n从上面看到熟悉的动态代理，先执行beforeInvoke方法，如果结果为true，拦截了该事件；如果为false，还是会继续执行系统原本方法，最后调用afterInvoke方法。在HookedMethodHandler里面beforeInvoke方法默认返回false，afterInvoke方法并没有实现：\n\n\t# HookedMethodHandler.java\n\n    /**\n     * 在某个方法被调用之前执行，如果返回true，则不执行原始的方法，否则执行原始方法\n     */\n    protected boolean beforeInvoke(Object receiver, Method method, Object[] args) throws Throwable {\n        return false;\n    }\n\n    protected void afterInvoke(Object receiver, Method method, Object[] args, Object invokeResult) throws Throwable {\n    }\n\n如果需要实现肯定是在子类了，在IActivityManagerHookHandle的init()方法里面，以startActivity为例：\n\n    private static class startActivity extends HookedMethodHandler {\n\n        public startActivity(Context hostContext) {\n            super(hostContext);\n        }\n\t\t......\n        @Override\n        protected boolean beforeInvoke(Object receiver, Method method, Object[] args) throws Throwable {\n            if (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR2) {\n                //2.3\n        /*public int startActivity(IApplicationThread caller,\n            Intent intent, String resolvedType, Uri[] grantedUriPermissions,\n            int grantedMode, IBinder resultTo, String resultWho, int requestCode,\n            boolean onlyIfNeeded, boolean debug) throws RemoteException;*/\n\n                //api 15\n        /*public int startActivity(IApplicationThread caller,\n            Intent intent, String resolvedType, Uri[] grantedUriPermissions,\n            int grantedMode, IBinder resultTo, String resultWho, int requestCode,\n            boolean onlyIfNeeded, boolean debug, String profileFile,\n            ParcelFileDescriptor profileFd, boolean autoStopProfiler) throws RemoteException;*/\n\n                //api 16,17\n        /*  public int startActivity(IApplicationThread caller,\n            Intent intent, String resolvedType, IBinder resultTo, String resultWho,\n            int requestCode, int flags, String profileFile,\n            ParcelFileDescriptor profileFd, Bundle options) throws RemoteException;*/\n                doReplaceIntentForStartActivityAPILow(args);\n            } else {\n                //api 18,19\n         /*  public int startActivity(IApplicationThread caller, String callingPackage,\n            Intent intent, String resolvedType, IBinder resultTo, String resultWho,\n            int requestCode, int flags, String profileFile,\n            ParcelFileDescriptor profileFd, Bundle options) throws RemoteException;*/\n\n                //api 21\n        /*   public int startActivity(IApplicationThread caller, String callingPackage,\n            Intent intent, String resolvedType, IBinder resultTo, String resultWho,\n            int requestCode, int flags, ProfilerInfo profilerInfo,\n            Bundle options) throws RemoteException;*/\n                doReplaceIntentForStartActivityAPIHigh(args);\n            }\n            return super.beforeInvoke(receiver, method, args);\n        }\n    }\n\n至此，hook的过程应该已经介绍完毕，其中涉及比较高深的问题，小弟完美绕过。\n\n\n\n\n\n\n","source":"_posts/简析DroidPlugin之Hook.md","raw":"title: 简析DroidPlugin之Hook\ndate: 2016/6/14 17：55\n\ncategories:\n- Mobile\ntags:\n- android\n---\n\n# 前言 #\n被誉为“安卓黑科技”的开源框架DroidPlugin，是目前较为流行的安卓动态加载技术的典范。免安装和免修改运行第三方sdk，实现多团队协助开发，是360推出这个牛逼able框架的主打亮点。那么，它是如何一步步去实现这个神奇的框架的呢？又和我们常见的动态加载技术有何区别去值得我们学习的？由于目前国内对这个框架没太多的研究，很多地方只能做到点到即止。本文主要分享其hook的过程。<!-- more -->\n\n## 了解入口架构 ##\n\n首先，看到application的attachBaseContext方法里面做了这样一步：\n\n\t# PluginApplication.java\n\n    PluginHelper.getInstance().applicationAttachBaseContext(base);\n\n这一步并没有做太多操作，只是注册了crash之后的log发送之类的信息。这里不展开细说。\n\n在onCreate方法里有：\n\n\t# PluginApplication.java\n\n    PluginHelper.getInstance().applicationOnCreate(getBaseContext());\n\n这一步是核心操作，进行了一系列的初始化，本文也是从这里开始展开。跟代码找到了initPlugin方法：\n\n\t# PluginHelper.java\n\n    private void initPlugin(Context baseContext) {\n        long b = System.currentTimeMillis();\n        try {\n            try {\n                fixMiUiLbeSecurity();\n            } catch (Throwable e) {\n                Log.e(TAG, \"fixMiUiLbeSecurity has error\", e);\n            }\n \n            try {\n                PluginProcessManager.installHook(baseContext);\n            } catch (Throwable e) {\n                Log.e(TAG, \"installHook has error\", e);\n            }\n \t\t......\n    }\n\n看到了 PluginProcessManager.installHook(baseContext); 这是安装钩子函数（hook）相关的入口。接着往下看：\n\n\t# HookFactory.java\n\n    public final void installHook(Context context, ClassLoader classLoader) throws Throwable {\n        installHook(new IClipboardBinderHook(context), classLoader);\n        //for ISearchManager\n        installHook(new ISearchManagerBinderHook(context), classLoader);\n        //for INotificationManager\n        installHook(new INotificationManagerBinderHook(context), classLoader);\n \t\t..........\n \n        installHook(new IPackageManagerHook(context), classLoader);\n        installHook(new IActivityManagerHook(context), classLoader);\n        installHook(new PluginCallbackHook(context), classLoader);\n\t\t.......\n    }\n\n很明显，这里做了一系列系统组件的hook操作，这里以\n\n\t# HookFactory.java\n\n    installHook(new IActivityManagerHook(context), classLoader);\n\n为例，实例化 IActivityManagerHook ，这个类继承谁呢？查看该类hook的体系结构：\n\n    Hook\n    --| ProxyHook\n    ----| IActivityManagerHook\n\n基类Hook.java构造方法做了两步操作，一是初始化了hostContext，二是创建hookHandle：\n\n\t# Hook.java\n\t\n    protected Hook(Context hostContext) {\n        mHostContext = hostContext;\n        mHookHandles = createHookHandle();\n    }\n\n跟着代码走到了IActivityManagerHookHandle的init()方法。咦，代码看上去貌似很长，其实就是用一个Map去存放方法名和对应操作的键值对，这里先有个概念，后面会用到。\n\nIActivityManagerHook实例化完之后，就是installHook的方法，先贴上代码：\n\n\t# HookFactory.java \n\n    public void installHook(Hook hook, ClassLoader cl) {\n        try {\n            hook.onInstall(cl);\n            synchronized (mHookList) {\n                mHookList.add(hook);\n            }\n        } catch (Throwable throwable) {\n            Log.e(TAG, \"installHook %s error\", throwable, hook);\n        }\n    }\n\n首先，这里对刚才实例化的hook调用了onInstall方法，并传入一个classLoder，这里为空；然后把hook添加到一个List集合中去。我们看一下IActivityManagerHook的onInstall方法的前半部分：\n\n\t# IActivityManagerHook.java\n\n    public void onInstall(ClassLoader classLoader) throws Throwable {\n    \tClass cls = ActivityManagerNativeCompat.Class();\n    \tObject obj = FieldUtils.readStaticField(cls, \"gDefault\");\n   \t \tif (obj == null) {\n    \t\tActivityManagerNativeCompat.getDefault();\n    \t\tobj = FieldUtils.readStaticField(cls, \"gDefault\");\n   \t\t }\n    \n    \t.............\n    }\n\n整个onInstall方法做了两件事情：</br>\n1.找到系统的IActivityManager;</br>\n2.判断该IActivityManager是否为单例，做不同的处理\n\n## 找到Hook对象 ##\n\n我们看一下在IAcitivityManager里面\"gDefault\"这个变量是干嘛的，贴源码：\n\n\t# ActivityManagerNative.java\n\n    private static final Singleton<IActivityManager> gDefault = new Singleton<IActivityManager>() {\n        protected IActivityManager create() {\n            IBinder b = ServiceManager.getService(\"activity\");\n            if (false) {\n                Log.v(\"ActivityManager\", \"default service binder = \" + b);\n            }\n            IActivityManager am = asInterface(b);\n            if (false) {\n                Log.v(\"ActivityManager\", \"default service = \" + am);\n            }\n            return am;\n        }\n    };\n\n我们知道，Android中ActivityManager是与系统所有运行着的Activity进行交互，对系统所有运行的Activity进行管理和维护，但是这些信息真正维护并不是由ActivityManager来负责。读起来有点绕，RTFSC是王道，截取其中一段获取运行服务的方法：\n\n\t# ActivityManager.java\n\n    public List<RunningServiceInfo> getRunningServices(int maxNum)\n            throws SecurityException {\n        try {\n            return ActivityManagerNative.getDefault()\n                    .getServices(maxNum, 0);\n        } catch (RemoteException e) {\n            // System dead, we will be dead too soon!\n            return null;\n        }\n    }\n\n通过阅读ActivityManager的源码发现，所有的信息都是通过ActivityManagerNative.getDefault()来操作获取。哎呦，这里面到底是干了啥？我们先来看一幅Activity Manager相关类继承层次关系图：\n\n![](http://i.imgur.com/ToILsf2.jpg)\n\nActivityManagerProxy，见名思意，是一个代理类，同时也是ActivityManagerNative的内部类；ActivityManagerNative是一个抽象类，实现它的是ActivityManagerService，这是一个系统Service组件。\n从图中可以看出，使用ActivityManagerProxy，来代理ActivityManagerNative，实质就是代理它的实现类ActivityManagerService；ActivityManagerService是系统统一的Service，运行在独立的进程中，通过系统ServiceManger来获取。\n\n\n那么，问题来了，ActivityManager运行在一个进程里面，ActivityManagerService运行在另一个进程内，这里面涉及到跨进程的对象访问，毫无疑问，采用的是Binder机制实现。\n\n我们从刚刚截取的ActivityManagerNative.java中定义gDefault的方法可以看到，首先获取“activity”的IBinder\n\n\tIBinder b = ServiceManager.getService(\"activity\");\n\n这个可以从以下源码得知，其中sCache存放的是名字和对应IBinder的键值对Map\n\n\t# ServiceManager.java\n\n    /**\n     * Returns a reference to a service with the given name.\n     * \n     * @param name the name of the service to get\n     * @return a reference to the service, or <code>null</code> if the service doesn't exist\n     */\n    public static IBinder getService(String name) {\n        try {\n            IBinder service = sCache.get(name);\n            if (service != null) {\n                return service;\n            } else {\n                return getIServiceManager().getService(name);\n            }\n        } catch (RemoteException e) {\n            Log.e(TAG, \"error in getService\", e);\n        }\n        return null;\n    }\n\n然后通过 asInterface(b) 就获取了ActivityManagerService实例的本地代理对象ActivityManagerProxy实例：\n\n\n\t# ActivityManagerNative.java\n\n    /**\n     * Cast a Binder object into an activity manager interface, generating\n     * a proxy if needed.\n     */\n    static public IActivityManager asInterface(IBinder obj) {\n        if (obj == null) {\n            return null;\n        }\n        IActivityManager in =\n            (IActivityManager)obj.queryLocalInterface(descriptor);\n        if (in != null) {\n            return in;\n        }\n\n        return new ActivityManagerProxy(obj);\n    }\n\n贴上一图，让你瞬间有豁然开朗的感觉有木有：\n\n![](http://i.imgur.com/Au935XN.jpg)\n\nok，回到我们的最原点，找到系统的IActivityManager要干嘛？当然就是我们的劫持hook了，在说hook之前，要说说动态代理机制。\n\n## 动态代理机制 ##\n\n动态代理，是一种设计模式，可以为其他对象提供一种代理以控制对这个对象的访问。举一个肤浅的栗子：\n\n\n   \tpublic Object invoke( Object proxy, Method method, Object[] args ) throws Throwable   \n      {   \n    //1.在转调具体目标对象之前，可以执行一些功能处理\n\n    //2.转调具体目标对象的方法\n    return method.invoke( proxied, args);  \n    \n    //3.在转调具体目标对象之后，可以执行一些功能处理\n\n      }\n    } \n\n所谓代理，就是首先要获得被代理者的控制权，被代理者在正常调用的时候，代理可以在被代理者的所有方法前或后添加想要的操作。从上图简单地理解，就是在2方法（被代理者）添加1和3方法。可以看一下代理结构图：\n\n![](http://i.imgur.com/s0zRfSt.gif)\n\n在动态代理机制中，有两个重要的类，分别是InvocationHandler和Proxy。我们看一下API帮助文档是怎么对两个类做描述的：\n\nInvocationHandler：\n\n    InvocationHandler is the interface implemented by the invocation handler of a proxy instance. \n    \n    Each proxy instance has an associated invocation handler. When a method is invoked on a proxy instance, the method invocation is encoded and dispatched to the invoke method of its invocation handler.\n\n每一个动态代理类必须要实现InvocationHandler这个接口，而InvocationHandler这个接口只有唯一一个invoke方法：\n    \n    Object invoke(Object proxy, Method method, Object[] args) throws Throwable\n\n    proxy:　　指代我们所代理的那个真实对象\n    method:　 指代的是我们所要调用真实对象的某个方法的Method对象\n    args:　　 指代的是调用真实对象某个方法时接受的参数\n\nProxy：\n\n    Proxy provides static methods for creating dynamic proxy classes and instances, and it is also the superclass of all dynamic proxy classes created by those methods. \n\nProxy这个类的作用是创建一个代理对象的类，它提供了很多方法，在这里我们只需要了解到newProxyInstance 即可：\n\n    public static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h) throws IllegalArgumentException\n    \n    loader:　　  一个ClassLoader对象，定义了由哪个ClassLoader对象来对生成的代理对象进行加载   \n    interfaces:  一个Interface对象的数组，表示的是我将要给我需要代理的对象提供一组什么接口，如果我提供了一组接口给它，那么这个代理对象就宣称实现了该接口(多态)，这样我就能调用这组接口中的方法了\n   \th:　　        一个InvocationHandler对象，表示的是当我这个动态代理对象在调用方法的时候，会关联到哪一个InvocationHandler对象上\n\nok，有了点概念，我们来继续举个具体点的栗子：\n\n定义一个people的接口：\n\n    public interface People{\n    \tpublic void countMoney();\n    }\n\nboss类去实现这个接口：\n\n    public class Boss implements people{\n\t\t@Override\n\t\tpublic void countMoney(){\n\t\t\tsystem.out.println(\"I have too money to burn.\");\n\t\t}\n    } \n\n定义一个代理类workers，前面说到了，每一个代理类必须实现InvocationHandler 这个接口：\n\n\tpublic class Workers implements InvocationHandler{\n\t\t//这个是我们要代理的真实对象\n\t\tprivate Object people;\n\n\t\t//构造方法，给我们要代理的真实对象赋值\n\t\tpublic workers(Object people){\n\t\t\tthis.people = people;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object invoke(Object object, Method method, Object[] args){\n\t\t\t\n\t\t\t//在代理真实对象之前加上一些操作\n\t\t\tsystem.out.println(\"I must word hard because I have no money.\");\n\n\t\t\t//调用真实对象的相关方法\n\t\t\tmethod.invoke(subject, args);\n\n\t\t\t//在代理真实对象之后加上一些操作\n\t\t\tsystem.out.println(\"Whether you have got money or not,it's wise for you to go back home for the Spring Festival.\");\n\t\t}\n\t} \n\n编写测试类：\n\n\tpublic class test{\n\t\t....\n\t\tBoss boss = new Boss;\n\t\tInvocationHandle handle = new Workers(boss);\n\t\tWorkers workers = (Workers) Proxy.newProxyInstance(handle.getClass().getClassLoader(),boss.getClass().getInterfaces(),handle);\n\t\t\n\t\tworkers.countMoney();\n\t\t\n\t}\n\n看一下输出结果：\n\n    I must word hard because I have no money.\n    I have too money to burn.\n    Whether you have got money or not,it's wise for you to go back home for the Spring Festival.\n\n结果很明显了，如果想了解其中的跳转原理，请查看源码，这里就不多作介绍了。\n\n## 开始Hook ##\n我们来看看onInstall方法的后半部分：\n\n\t# IActivityManagerHook.java\n\n\tpublic void onInstall(ClassLoader classLoader) throws Throwable {\n\t\t.....\n\n        if (IActivityManagerCompat.isIActivityManager(obj)) {\n            setOldObj(obj);\n            Class<?> objClass = mOldObj.getClass();\n            List<Class<?>> interfaces = Utils.getAllInterfaces(objClass);\n            Class[] ifs = interfaces != null && interfaces.size() > 0 ? interfaces.toArray(new Class[interfaces.size()]) : new Class[0];\n            Object proxiedActivityManager = MyProxy.newProxyInstance(objClass.getClassLoader(), ifs, this);\n            FieldUtils.writeStaticField(cls, \"gDefault\", proxiedActivityManager);\n            Log.i(TAG, \"Install ActivityManager Hook 1 old=%s,new=%s\", mOldObj, proxiedActivityManager);\n        } \n\n\t\t\t.......\n        }\n\n首先，判断上面获取找到系统的IActivityManager是否正确，然后setOldObj(obj)保存当前系统的IActivityManager对象，留意IActivityManagerHook类是继承ProxyHook，该类实现InvocationHandler接口，就是一个代理类的实体啊。ok，你应该留意到接下来的操作就是介绍如何一步步实现代理，并把代理对象写到ActivityManagerNative的gDefault变量中，这样就实现hook了：\n\n\tObject proxiedActivityManager = MyProxy.newProxyInstance(objClass.getClassLoader(), ifs, this);\n    FieldUtils.writeStaticField(cls, \"gDefault\", proxiedActivityManager);\n\nclassLoader和获取所有接口数组都是沿用mOldObj对象。\n\nhook之后就开始干坏事了，把目光转到ProxyHook类中的invoke方法：\n\n\t# ProxyHook.java\n\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\n        try {\n            if (!isEnable()) {\n                return method.invoke(mOldObj, args);\n            }\n            HookedMethodHandler hookedMethodHandler = mHookHandles.getHookedMethodHandler(method);\n            if (hookedMethodHandler != null) {\n                return hookedMethodHandler.doHookInner(mOldObj, method, args);\n            }\n            return method.invoke(mOldObj, args);\n        } catch (InvocationTargetException e) {\n            Throwable cause = e.getTargetException();\n         .......\n    }\t\n\n首先，isEnable()先判断一下这个函数是否可以hook，不可以的话直接返回mOldObj（系统）的原本方法；可以的话继续往下走：\n\n\t# ProxyHook.java\n\n\tHookedMethodHandler hookedMethodHandler = mHookHandles.getHookedMethodHandler(method);\n    if (hookedMethodHandler != null) {\n        return hookedMethodHandler.doHookInner(mOldObj, method, args);\n    }\n\treturn method.invoke(mOldObj, args);\n\n根据方法名字获取一个hookedMethodHandler，如果不为空，则执行hookedMethodHandler的doHookInner方法；如果为空，依旧返回系统的原本方法。\n\nhookedMethodHandler是什么鬼？还记得上面提到的IActivityManagerHookHandle的init()方法？是的，这里就要用到，先看一下之前的init()代码：\n\n\t# IActivityManagerHookHandle.java\n\n    protected void init() {\n        sHookedMethodHandlers.put(\"startActivity\", new startActivity(mHostContext));\n        sHookedMethodHandlers.put(\"startActivityAsUser\", new startActivityAsUser(mHostContext));\n        sHookedMethodHandlers.put(\"startActivityAsCaller\", new startActivityAsCaller(mHostContext));\n        sHookedMethodHandlers.put(\"startActivityAndWait\", new startActivityAndWait(mHostContext));\n        sHookedMethodHandlers.put(\"startActivityWithConfig\", new startActivityWithConfig(mHostContext));\n        sHookedMethodHandlers.put(\"startActivityIntentSender\", new startActivityIntentSender(mHostContext));\n        sHookedMethodHandlers.put(\"startVoiceActivity\", new startVoiceActivity(mHostContext));\n        sHookedMethodHandlers.put(\"startNextMatchingActivity\", new startNextMatchingActivity(mHostContext));\n        sHookedMethodHandlers.put(\"startActivityFromRecents\", new startActivityFromRecents(mHostContext));\n      ...........\n    }\n\n初始化把所有方法和对应的HookedMethodHandler处理类放在一起。\n\n我们假如传入一个方法名为startActivity，hookedMethodHandler存在，并进入doHookInner方法：\n\n\t# HookedMethodHandler.java\n\n    public synchronized Object doHookInner(Object receiver, Method method, Object[] args) throws Throwable {\n        long b = System.currentTimeMillis();\n        try {\n            mUseFakedResult = false;\n            mFakedResult = null;\n            boolean suc = beforeInvoke(receiver, method, args);\n            Object invokeResult = null;\n            if (!suc) {\n                invokeResult = method.invoke(receiver, args);\n            }\n            afterInvoke(receiver, method, args, invokeResult);\n            if (mUseFakedResult) {\n                return mFakedResult;\n            } else {\n                return invokeResult;\n            }\n        } \n\t.........\n    }\n\n从上面看到熟悉的动态代理，先执行beforeInvoke方法，如果结果为true，拦截了该事件；如果为false，还是会继续执行系统原本方法，最后调用afterInvoke方法。在HookedMethodHandler里面beforeInvoke方法默认返回false，afterInvoke方法并没有实现：\n\n\t# HookedMethodHandler.java\n\n    /**\n     * 在某个方法被调用之前执行，如果返回true，则不执行原始的方法，否则执行原始方法\n     */\n    protected boolean beforeInvoke(Object receiver, Method method, Object[] args) throws Throwable {\n        return false;\n    }\n\n    protected void afterInvoke(Object receiver, Method method, Object[] args, Object invokeResult) throws Throwable {\n    }\n\n如果需要实现肯定是在子类了，在IActivityManagerHookHandle的init()方法里面，以startActivity为例：\n\n    private static class startActivity extends HookedMethodHandler {\n\n        public startActivity(Context hostContext) {\n            super(hostContext);\n        }\n\t\t......\n        @Override\n        protected boolean beforeInvoke(Object receiver, Method method, Object[] args) throws Throwable {\n            if (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR2) {\n                //2.3\n        /*public int startActivity(IApplicationThread caller,\n            Intent intent, String resolvedType, Uri[] grantedUriPermissions,\n            int grantedMode, IBinder resultTo, String resultWho, int requestCode,\n            boolean onlyIfNeeded, boolean debug) throws RemoteException;*/\n\n                //api 15\n        /*public int startActivity(IApplicationThread caller,\n            Intent intent, String resolvedType, Uri[] grantedUriPermissions,\n            int grantedMode, IBinder resultTo, String resultWho, int requestCode,\n            boolean onlyIfNeeded, boolean debug, String profileFile,\n            ParcelFileDescriptor profileFd, boolean autoStopProfiler) throws RemoteException;*/\n\n                //api 16,17\n        /*  public int startActivity(IApplicationThread caller,\n            Intent intent, String resolvedType, IBinder resultTo, String resultWho,\n            int requestCode, int flags, String profileFile,\n            ParcelFileDescriptor profileFd, Bundle options) throws RemoteException;*/\n                doReplaceIntentForStartActivityAPILow(args);\n            } else {\n                //api 18,19\n         /*  public int startActivity(IApplicationThread caller, String callingPackage,\n            Intent intent, String resolvedType, IBinder resultTo, String resultWho,\n            int requestCode, int flags, String profileFile,\n            ParcelFileDescriptor profileFd, Bundle options) throws RemoteException;*/\n\n                //api 21\n        /*   public int startActivity(IApplicationThread caller, String callingPackage,\n            Intent intent, String resolvedType, IBinder resultTo, String resultWho,\n            int requestCode, int flags, ProfilerInfo profilerInfo,\n            Bundle options) throws RemoteException;*/\n                doReplaceIntentForStartActivityAPIHigh(args);\n            }\n            return super.beforeInvoke(receiver, method, args);\n        }\n    }\n\n至此，hook的过程应该已经介绍完毕，其中涉及比较高深的问题，小弟完美绕过。\n\n\n\n\n\n\n","slug":"简析DroidPlugin之Hook","published":1,"updated":"2018-01-28T15:39:34.393Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjcyyg7l2001iniusmrjauzgn","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>被誉为“安卓黑科技”的开源框架DroidPlugin，是目前较为流行的安卓动态加载技术的典范。免安装和免修改运行第三方sdk，实现多团队协助开发，是360推出这个牛逼able框架的主打亮点。那么，它是如何一步步去实现这个神奇的框架的呢？又和我们常见的动态加载技术有何区别去值得我们学习的？由于目前国内对这个框架没太多的研究，很多地方只能做到点到即止。本文主要分享其hook的过程。<a id=\"more\"></a></p>\n<h2 id=\"了解入口架构\"><a href=\"#了解入口架构\" class=\"headerlink\" title=\"了解入口架构\"></a>了解入口架构</h2><p>首先，看到application的attachBaseContext方法里面做了这样一步：</p>\n<pre><code># PluginApplication.java\n\nPluginHelper.getInstance().applicationAttachBaseContext(base);\n</code></pre><p>这一步并没有做太多操作，只是注册了crash之后的log发送之类的信息。这里不展开细说。</p>\n<p>在onCreate方法里有：</p>\n<pre><code># PluginApplication.java\n\nPluginHelper.getInstance().applicationOnCreate(getBaseContext());\n</code></pre><p>这一步是核心操作，进行了一系列的初始化，本文也是从这里开始展开。跟代码找到了initPlugin方法：</p>\n<pre><code># PluginHelper.java\n\nprivate void initPlugin(Context baseContext) {\n    long b = System.currentTimeMillis();\n    try {\n        try {\n            fixMiUiLbeSecurity();\n        } catch (Throwable e) {\n            Log.e(TAG, &quot;fixMiUiLbeSecurity has error&quot;, e);\n        }\n\n        try {\n            PluginProcessManager.installHook(baseContext);\n        } catch (Throwable e) {\n            Log.e(TAG, &quot;installHook has error&quot;, e);\n        }\n     ......\n}\n</code></pre><p>看到了 PluginProcessManager.installHook(baseContext); 这是安装钩子函数（hook）相关的入口。接着往下看：</p>\n<pre><code># HookFactory.java\n\npublic final void installHook(Context context, ClassLoader classLoader) throws Throwable {\n    installHook(new IClipboardBinderHook(context), classLoader);\n    //for ISearchManager\n    installHook(new ISearchManagerBinderHook(context), classLoader);\n    //for INotificationManager\n    installHook(new INotificationManagerBinderHook(context), classLoader);\n     ..........\n\n    installHook(new IPackageManagerHook(context), classLoader);\n    installHook(new IActivityManagerHook(context), classLoader);\n    installHook(new PluginCallbackHook(context), classLoader);\n    .......\n}\n</code></pre><p>很明显，这里做了一系列系统组件的hook操作，这里以</p>\n<pre><code># HookFactory.java\n\ninstallHook(new IActivityManagerHook(context), classLoader);\n</code></pre><p>为例，实例化 IActivityManagerHook ，这个类继承谁呢？查看该类hook的体系结构：</p>\n<pre><code>Hook\n--| ProxyHook\n----| IActivityManagerHook\n</code></pre><p>基类Hook.java构造方法做了两步操作，一是初始化了hostContext，二是创建hookHandle：</p>\n<pre><code># Hook.java\n\nprotected Hook(Context hostContext) {\n    mHostContext = hostContext;\n    mHookHandles = createHookHandle();\n}\n</code></pre><p>跟着代码走到了IActivityManagerHookHandle的init()方法。咦，代码看上去貌似很长，其实就是用一个Map去存放方法名和对应操作的键值对，这里先有个概念，后面会用到。</p>\n<p>IActivityManagerHook实例化完之后，就是installHook的方法，先贴上代码：</p>\n<pre><code># HookFactory.java \n\npublic void installHook(Hook hook, ClassLoader cl) {\n    try {\n        hook.onInstall(cl);\n        synchronized (mHookList) {\n            mHookList.add(hook);\n        }\n    } catch (Throwable throwable) {\n        Log.e(TAG, &quot;installHook %s error&quot;, throwable, hook);\n    }\n}\n</code></pre><p>首先，这里对刚才实例化的hook调用了onInstall方法，并传入一个classLoder，这里为空；然后把hook添加到一个List集合中去。我们看一下IActivityManagerHook的onInstall方法的前半部分：</p>\n<pre><code># IActivityManagerHook.java\n\npublic void onInstall(ClassLoader classLoader) throws Throwable {\n    Class cls = ActivityManagerNativeCompat.Class();\n    Object obj = FieldUtils.readStaticField(cls, &quot;gDefault&quot;);\n        if (obj == null) {\n        ActivityManagerNativeCompat.getDefault();\n        obj = FieldUtils.readStaticField(cls, &quot;gDefault&quot;);\n        }\n\n    .............\n}\n</code></pre><p>整个onInstall方法做了两件事情：<br><br>1.找到系统的IActivityManager;<br><br>2.判断该IActivityManager是否为单例，做不同的处理</p>\n<h2 id=\"找到Hook对象\"><a href=\"#找到Hook对象\" class=\"headerlink\" title=\"找到Hook对象\"></a>找到Hook对象</h2><p>我们看一下在IAcitivityManager里面”gDefault”这个变量是干嘛的，贴源码：</p>\n<pre><code># ActivityManagerNative.java\n\nprivate static final Singleton&lt;IActivityManager&gt; gDefault = new Singleton&lt;IActivityManager&gt;() {\n    protected IActivityManager create() {\n        IBinder b = ServiceManager.getService(&quot;activity&quot;);\n        if (false) {\n            Log.v(&quot;ActivityManager&quot;, &quot;default service binder = &quot; + b);\n        }\n        IActivityManager am = asInterface(b);\n        if (false) {\n            Log.v(&quot;ActivityManager&quot;, &quot;default service = &quot; + am);\n        }\n        return am;\n    }\n};\n</code></pre><p>我们知道，Android中ActivityManager是与系统所有运行着的Activity进行交互，对系统所有运行的Activity进行管理和维护，但是这些信息真正维护并不是由ActivityManager来负责。读起来有点绕，RTFSC是王道，截取其中一段获取运行服务的方法：</p>\n<pre><code># ActivityManager.java\n\npublic List&lt;RunningServiceInfo&gt; getRunningServices(int maxNum)\n        throws SecurityException {\n    try {\n        return ActivityManagerNative.getDefault()\n                .getServices(maxNum, 0);\n    } catch (RemoteException e) {\n        // System dead, we will be dead too soon!\n        return null;\n    }\n}\n</code></pre><p>通过阅读ActivityManager的源码发现，所有的信息都是通过ActivityManagerNative.getDefault()来操作获取。哎呦，这里面到底是干了啥？我们先来看一幅Activity Manager相关类继承层次关系图：</p>\n<p><img src=\"http://i.imgur.com/ToILsf2.jpg\" alt=\"\"></p>\n<p>ActivityManagerProxy，见名思意，是一个代理类，同时也是ActivityManagerNative的内部类；ActivityManagerNative是一个抽象类，实现它的是ActivityManagerService，这是一个系统Service组件。<br>从图中可以看出，使用ActivityManagerProxy，来代理ActivityManagerNative，实质就是代理它的实现类ActivityManagerService；ActivityManagerService是系统统一的Service，运行在独立的进程中，通过系统ServiceManger来获取。</p>\n<p>那么，问题来了，ActivityManager运行在一个进程里面，ActivityManagerService运行在另一个进程内，这里面涉及到跨进程的对象访问，毫无疑问，采用的是Binder机制实现。</p>\n<p>我们从刚刚截取的ActivityManagerNative.java中定义gDefault的方法可以看到，首先获取“activity”的IBinder</p>\n<pre><code>IBinder b = ServiceManager.getService(&quot;activity&quot;);\n</code></pre><p>这个可以从以下源码得知，其中sCache存放的是名字和对应IBinder的键值对Map</p>\n<pre><code># ServiceManager.java\n\n/**\n * Returns a reference to a service with the given name.\n * \n * @param name the name of the service to get\n * @return a reference to the service, or &lt;code&gt;null&lt;/code&gt; if the service doesn&apos;t exist\n */\npublic static IBinder getService(String name) {\n    try {\n        IBinder service = sCache.get(name);\n        if (service != null) {\n            return service;\n        } else {\n            return getIServiceManager().getService(name);\n        }\n    } catch (RemoteException e) {\n        Log.e(TAG, &quot;error in getService&quot;, e);\n    }\n    return null;\n}\n</code></pre><p>然后通过 asInterface(b) 就获取了ActivityManagerService实例的本地代理对象ActivityManagerProxy实例：</p>\n<pre><code># ActivityManagerNative.java\n\n/**\n * Cast a Binder object into an activity manager interface, generating\n * a proxy if needed.\n */\nstatic public IActivityManager asInterface(IBinder obj) {\n    if (obj == null) {\n        return null;\n    }\n    IActivityManager in =\n        (IActivityManager)obj.queryLocalInterface(descriptor);\n    if (in != null) {\n        return in;\n    }\n\n    return new ActivityManagerProxy(obj);\n}\n</code></pre><p>贴上一图，让你瞬间有豁然开朗的感觉有木有：</p>\n<p><img src=\"http://i.imgur.com/Au935XN.jpg\" alt=\"\"></p>\n<p>ok，回到我们的最原点，找到系统的IActivityManager要干嘛？当然就是我们的劫持hook了，在说hook之前，要说说动态代理机制。</p>\n<h2 id=\"动态代理机制\"><a href=\"#动态代理机制\" class=\"headerlink\" title=\"动态代理机制\"></a>动态代理机制</h2><p>动态代理，是一种设计模式，可以为其他对象提供一种代理以控制对这个对象的访问。举一个肤浅的栗子：</p>\n<pre><code>   public Object invoke( Object proxy, Method method, Object[] args ) throws Throwable   \n  {   \n//1.在转调具体目标对象之前，可以执行一些功能处理\n\n//2.转调具体目标对象的方法\nreturn method.invoke( proxied, args);  \n\n//3.在转调具体目标对象之后，可以执行一些功能处理\n\n  }\n} \n</code></pre><p>所谓代理，就是首先要获得被代理者的控制权，被代理者在正常调用的时候，代理可以在被代理者的所有方法前或后添加想要的操作。从上图简单地理解，就是在2方法（被代理者）添加1和3方法。可以看一下代理结构图：</p>\n<p><img src=\"http://i.imgur.com/s0zRfSt.gif\" alt=\"\"></p>\n<p>在动态代理机制中，有两个重要的类，分别是InvocationHandler和Proxy。我们看一下API帮助文档是怎么对两个类做描述的：</p>\n<p>InvocationHandler：</p>\n<pre><code>InvocationHandler is the interface implemented by the invocation handler of a proxy instance. \n\nEach proxy instance has an associated invocation handler. When a method is invoked on a proxy instance, the method invocation is encoded and dispatched to the invoke method of its invocation handler.\n</code></pre><p>每一个动态代理类必须要实现InvocationHandler这个接口，而InvocationHandler这个接口只有唯一一个invoke方法：</p>\n<pre><code>Object invoke(Object proxy, Method method, Object[] args) throws Throwable\n\nproxy:　　指代我们所代理的那个真实对象\nmethod:　 指代的是我们所要调用真实对象的某个方法的Method对象\nargs:　　 指代的是调用真实对象某个方法时接受的参数\n</code></pre><p>Proxy：</p>\n<pre><code>Proxy provides static methods for creating dynamic proxy classes and instances, and it is also the superclass of all dynamic proxy classes created by those methods. \n</code></pre><p>Proxy这个类的作用是创建一个代理对象的类，它提供了很多方法，在这里我们只需要了解到newProxyInstance 即可：</p>\n<pre><code>public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException\n\nloader:　　  一个ClassLoader对象，定义了由哪个ClassLoader对象来对生成的代理对象进行加载   \ninterfaces:  一个Interface对象的数组，表示的是我将要给我需要代理的对象提供一组什么接口，如果我提供了一组接口给它，那么这个代理对象就宣称实现了该接口(多态)，这样我就能调用这组接口中的方法了\n   h:　　        一个InvocationHandler对象，表示的是当我这个动态代理对象在调用方法的时候，会关联到哪一个InvocationHandler对象上\n</code></pre><p>ok，有了点概念，我们来继续举个具体点的栗子：</p>\n<p>定义一个people的接口：</p>\n<pre><code>public interface People{\n    public void countMoney();\n}\n</code></pre><p>boss类去实现这个接口：</p>\n<pre><code>public class Boss implements people{\n    @Override\n    public void countMoney(){\n        system.out.println(&quot;I have too money to burn.&quot;);\n    }\n} \n</code></pre><p>定义一个代理类workers，前面说到了，每一个代理类必须实现InvocationHandler 这个接口：</p>\n<pre><code>public class Workers implements InvocationHandler{\n    //这个是我们要代理的真实对象\n    private Object people;\n\n    //构造方法，给我们要代理的真实对象赋值\n    public workers(Object people){\n        this.people = people;\n    }\n\n    @Override\n    public Object invoke(Object object, Method method, Object[] args){\n\n        //在代理真实对象之前加上一些操作\n        system.out.println(&quot;I must word hard because I have no money.&quot;);\n\n        //调用真实对象的相关方法\n        method.invoke(subject, args);\n\n        //在代理真实对象之后加上一些操作\n        system.out.println(&quot;Whether you have got money or not,it&apos;s wise for you to go back home for the Spring Festival.&quot;);\n    }\n} \n</code></pre><p>编写测试类：</p>\n<pre><code>public class test{\n    ....\n    Boss boss = new Boss;\n    InvocationHandle handle = new Workers(boss);\n    Workers workers = (Workers) Proxy.newProxyInstance(handle.getClass().getClassLoader(),boss.getClass().getInterfaces(),handle);\n\n    workers.countMoney();\n\n}\n</code></pre><p>看一下输出结果：</p>\n<pre><code>I must word hard because I have no money.\nI have too money to burn.\nWhether you have got money or not,it&apos;s wise for you to go back home for the Spring Festival.\n</code></pre><p>结果很明显了，如果想了解其中的跳转原理，请查看源码，这里就不多作介绍了。</p>\n<h2 id=\"开始Hook\"><a href=\"#开始Hook\" class=\"headerlink\" title=\"开始Hook\"></a>开始Hook</h2><p>我们来看看onInstall方法的后半部分：</p>\n<pre><code># IActivityManagerHook.java\n\npublic void onInstall(ClassLoader classLoader) throws Throwable {\n    .....\n\n    if (IActivityManagerCompat.isIActivityManager(obj)) {\n        setOldObj(obj);\n        Class&lt;?&gt; objClass = mOldObj.getClass();\n        List&lt;Class&lt;?&gt;&gt; interfaces = Utils.getAllInterfaces(objClass);\n        Class[] ifs = interfaces != null &amp;&amp; interfaces.size() &gt; 0 ? interfaces.toArray(new Class[interfaces.size()]) : new Class[0];\n        Object proxiedActivityManager = MyProxy.newProxyInstance(objClass.getClassLoader(), ifs, this);\n        FieldUtils.writeStaticField(cls, &quot;gDefault&quot;, proxiedActivityManager);\n        Log.i(TAG, &quot;Install ActivityManager Hook 1 old=%s,new=%s&quot;, mOldObj, proxiedActivityManager);\n    } \n\n        .......\n    }\n</code></pre><p>首先，判断上面获取找到系统的IActivityManager是否正确，然后setOldObj(obj)保存当前系统的IActivityManager对象，留意IActivityManagerHook类是继承ProxyHook，该类实现InvocationHandler接口，就是一个代理类的实体啊。ok，你应该留意到接下来的操作就是介绍如何一步步实现代理，并把代理对象写到ActivityManagerNative的gDefault变量中，这样就实现hook了：</p>\n<pre><code>Object proxiedActivityManager = MyProxy.newProxyInstance(objClass.getClassLoader(), ifs, this);\nFieldUtils.writeStaticField(cls, &quot;gDefault&quot;, proxiedActivityManager);\n</code></pre><p>classLoader和获取所有接口数组都是沿用mOldObj对象。</p>\n<p>hook之后就开始干坏事了，把目光转到ProxyHook类中的invoke方法：</p>\n<pre><code># ProxyHook.java\n\npublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\n    try {\n        if (!isEnable()) {\n            return method.invoke(mOldObj, args);\n        }\n        HookedMethodHandler hookedMethodHandler = mHookHandles.getHookedMethodHandler(method);\n        if (hookedMethodHandler != null) {\n            return hookedMethodHandler.doHookInner(mOldObj, method, args);\n        }\n        return method.invoke(mOldObj, args);\n    } catch (InvocationTargetException e) {\n        Throwable cause = e.getTargetException();\n     .......\n}    \n</code></pre><p>首先，isEnable()先判断一下这个函数是否可以hook，不可以的话直接返回mOldObj（系统）的原本方法；可以的话继续往下走：</p>\n<pre><code># ProxyHook.java\n\nHookedMethodHandler hookedMethodHandler = mHookHandles.getHookedMethodHandler(method);\nif (hookedMethodHandler != null) {\n    return hookedMethodHandler.doHookInner(mOldObj, method, args);\n}\nreturn method.invoke(mOldObj, args);\n</code></pre><p>根据方法名字获取一个hookedMethodHandler，如果不为空，则执行hookedMethodHandler的doHookInner方法；如果为空，依旧返回系统的原本方法。</p>\n<p>hookedMethodHandler是什么鬼？还记得上面提到的IActivityManagerHookHandle的init()方法？是的，这里就要用到，先看一下之前的init()代码：</p>\n<pre><code># IActivityManagerHookHandle.java\n\nprotected void init() {\n    sHookedMethodHandlers.put(&quot;startActivity&quot;, new startActivity(mHostContext));\n    sHookedMethodHandlers.put(&quot;startActivityAsUser&quot;, new startActivityAsUser(mHostContext));\n    sHookedMethodHandlers.put(&quot;startActivityAsCaller&quot;, new startActivityAsCaller(mHostContext));\n    sHookedMethodHandlers.put(&quot;startActivityAndWait&quot;, new startActivityAndWait(mHostContext));\n    sHookedMethodHandlers.put(&quot;startActivityWithConfig&quot;, new startActivityWithConfig(mHostContext));\n    sHookedMethodHandlers.put(&quot;startActivityIntentSender&quot;, new startActivityIntentSender(mHostContext));\n    sHookedMethodHandlers.put(&quot;startVoiceActivity&quot;, new startVoiceActivity(mHostContext));\n    sHookedMethodHandlers.put(&quot;startNextMatchingActivity&quot;, new startNextMatchingActivity(mHostContext));\n    sHookedMethodHandlers.put(&quot;startActivityFromRecents&quot;, new startActivityFromRecents(mHostContext));\n  ...........\n}\n</code></pre><p>初始化把所有方法和对应的HookedMethodHandler处理类放在一起。</p>\n<p>我们假如传入一个方法名为startActivity，hookedMethodHandler存在，并进入doHookInner方法：</p>\n<pre><code># HookedMethodHandler.java\n\npublic synchronized Object doHookInner(Object receiver, Method method, Object[] args) throws Throwable {\n    long b = System.currentTimeMillis();\n    try {\n        mUseFakedResult = false;\n        mFakedResult = null;\n        boolean suc = beforeInvoke(receiver, method, args);\n        Object invokeResult = null;\n        if (!suc) {\n            invokeResult = method.invoke(receiver, args);\n        }\n        afterInvoke(receiver, method, args, invokeResult);\n        if (mUseFakedResult) {\n            return mFakedResult;\n        } else {\n            return invokeResult;\n        }\n    } \n.........\n}\n</code></pre><p>从上面看到熟悉的动态代理，先执行beforeInvoke方法，如果结果为true，拦截了该事件；如果为false，还是会继续执行系统原本方法，最后调用afterInvoke方法。在HookedMethodHandler里面beforeInvoke方法默认返回false，afterInvoke方法并没有实现：</p>\n<pre><code># HookedMethodHandler.java\n\n/**\n * 在某个方法被调用之前执行，如果返回true，则不执行原始的方法，否则执行原始方法\n */\nprotected boolean beforeInvoke(Object receiver, Method method, Object[] args) throws Throwable {\n    return false;\n}\n\nprotected void afterInvoke(Object receiver, Method method, Object[] args, Object invokeResult) throws Throwable {\n}\n</code></pre><p>如果需要实现肯定是在子类了，在IActivityManagerHookHandle的init()方法里面，以startActivity为例：</p>\n<pre><code>private static class startActivity extends HookedMethodHandler {\n\n    public startActivity(Context hostContext) {\n        super(hostContext);\n    }\n    ......\n    @Override\n    protected boolean beforeInvoke(Object receiver, Method method, Object[] args) throws Throwable {\n        if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.JELLY_BEAN_MR2) {\n            //2.3\n    /*public int startActivity(IApplicationThread caller,\n        Intent intent, String resolvedType, Uri[] grantedUriPermissions,\n        int grantedMode, IBinder resultTo, String resultWho, int requestCode,\n        boolean onlyIfNeeded, boolean debug) throws RemoteException;*/\n\n            //api 15\n    /*public int startActivity(IApplicationThread caller,\n        Intent intent, String resolvedType, Uri[] grantedUriPermissions,\n        int grantedMode, IBinder resultTo, String resultWho, int requestCode,\n        boolean onlyIfNeeded, boolean debug, String profileFile,\n        ParcelFileDescriptor profileFd, boolean autoStopProfiler) throws RemoteException;*/\n\n            //api 16,17\n    /*  public int startActivity(IApplicationThread caller,\n        Intent intent, String resolvedType, IBinder resultTo, String resultWho,\n        int requestCode, int flags, String profileFile,\n        ParcelFileDescriptor profileFd, Bundle options) throws RemoteException;*/\n            doReplaceIntentForStartActivityAPILow(args);\n        } else {\n            //api 18,19\n     /*  public int startActivity(IApplicationThread caller, String callingPackage,\n        Intent intent, String resolvedType, IBinder resultTo, String resultWho,\n        int requestCode, int flags, String profileFile,\n        ParcelFileDescriptor profileFd, Bundle options) throws RemoteException;*/\n\n            //api 21\n    /*   public int startActivity(IApplicationThread caller, String callingPackage,\n        Intent intent, String resolvedType, IBinder resultTo, String resultWho,\n        int requestCode, int flags, ProfilerInfo profilerInfo,\n        Bundle options) throws RemoteException;*/\n            doReplaceIntentForStartActivityAPIHigh(args);\n        }\n        return super.beforeInvoke(receiver, method, args);\n    }\n}\n</code></pre><p>至此，hook的过程应该已经介绍完毕，其中涉及比较高深的问题，小弟完美绕过。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>被誉为“安卓黑科技”的开源框架DroidPlugin，是目前较为流行的安卓动态加载技术的典范。免安装和免修改运行第三方sdk，实现多团队协助开发，是360推出这个牛逼able框架的主打亮点。那么，它是如何一步步去实现这个神奇的框架的呢？又和我们常见的动态加载技术有何区别去值得我们学习的？由于目前国内对这个框架没太多的研究，很多地方只能做到点到即止。本文主要分享其hook的过程。","more":"</p>\n<h2 id=\"了解入口架构\"><a href=\"#了解入口架构\" class=\"headerlink\" title=\"了解入口架构\"></a>了解入口架构</h2><p>首先，看到application的attachBaseContext方法里面做了这样一步：</p>\n<pre><code># PluginApplication.java\n\nPluginHelper.getInstance().applicationAttachBaseContext(base);\n</code></pre><p>这一步并没有做太多操作，只是注册了crash之后的log发送之类的信息。这里不展开细说。</p>\n<p>在onCreate方法里有：</p>\n<pre><code># PluginApplication.java\n\nPluginHelper.getInstance().applicationOnCreate(getBaseContext());\n</code></pre><p>这一步是核心操作，进行了一系列的初始化，本文也是从这里开始展开。跟代码找到了initPlugin方法：</p>\n<pre><code># PluginHelper.java\n\nprivate void initPlugin(Context baseContext) {\n    long b = System.currentTimeMillis();\n    try {\n        try {\n            fixMiUiLbeSecurity();\n        } catch (Throwable e) {\n            Log.e(TAG, &quot;fixMiUiLbeSecurity has error&quot;, e);\n        }\n\n        try {\n            PluginProcessManager.installHook(baseContext);\n        } catch (Throwable e) {\n            Log.e(TAG, &quot;installHook has error&quot;, e);\n        }\n     ......\n}\n</code></pre><p>看到了 PluginProcessManager.installHook(baseContext); 这是安装钩子函数（hook）相关的入口。接着往下看：</p>\n<pre><code># HookFactory.java\n\npublic final void installHook(Context context, ClassLoader classLoader) throws Throwable {\n    installHook(new IClipboardBinderHook(context), classLoader);\n    //for ISearchManager\n    installHook(new ISearchManagerBinderHook(context), classLoader);\n    //for INotificationManager\n    installHook(new INotificationManagerBinderHook(context), classLoader);\n     ..........\n\n    installHook(new IPackageManagerHook(context), classLoader);\n    installHook(new IActivityManagerHook(context), classLoader);\n    installHook(new PluginCallbackHook(context), classLoader);\n    .......\n}\n</code></pre><p>很明显，这里做了一系列系统组件的hook操作，这里以</p>\n<pre><code># HookFactory.java\n\ninstallHook(new IActivityManagerHook(context), classLoader);\n</code></pre><p>为例，实例化 IActivityManagerHook ，这个类继承谁呢？查看该类hook的体系结构：</p>\n<pre><code>Hook\n--| ProxyHook\n----| IActivityManagerHook\n</code></pre><p>基类Hook.java构造方法做了两步操作，一是初始化了hostContext，二是创建hookHandle：</p>\n<pre><code># Hook.java\n\nprotected Hook(Context hostContext) {\n    mHostContext = hostContext;\n    mHookHandles = createHookHandle();\n}\n</code></pre><p>跟着代码走到了IActivityManagerHookHandle的init()方法。咦，代码看上去貌似很长，其实就是用一个Map去存放方法名和对应操作的键值对，这里先有个概念，后面会用到。</p>\n<p>IActivityManagerHook实例化完之后，就是installHook的方法，先贴上代码：</p>\n<pre><code># HookFactory.java \n\npublic void installHook(Hook hook, ClassLoader cl) {\n    try {\n        hook.onInstall(cl);\n        synchronized (mHookList) {\n            mHookList.add(hook);\n        }\n    } catch (Throwable throwable) {\n        Log.e(TAG, &quot;installHook %s error&quot;, throwable, hook);\n    }\n}\n</code></pre><p>首先，这里对刚才实例化的hook调用了onInstall方法，并传入一个classLoder，这里为空；然后把hook添加到一个List集合中去。我们看一下IActivityManagerHook的onInstall方法的前半部分：</p>\n<pre><code># IActivityManagerHook.java\n\npublic void onInstall(ClassLoader classLoader) throws Throwable {\n    Class cls = ActivityManagerNativeCompat.Class();\n    Object obj = FieldUtils.readStaticField(cls, &quot;gDefault&quot;);\n        if (obj == null) {\n        ActivityManagerNativeCompat.getDefault();\n        obj = FieldUtils.readStaticField(cls, &quot;gDefault&quot;);\n        }\n\n    .............\n}\n</code></pre><p>整个onInstall方法做了两件事情：<br><br>1.找到系统的IActivityManager;<br><br>2.判断该IActivityManager是否为单例，做不同的处理</p>\n<h2 id=\"找到Hook对象\"><a href=\"#找到Hook对象\" class=\"headerlink\" title=\"找到Hook对象\"></a>找到Hook对象</h2><p>我们看一下在IAcitivityManager里面”gDefault”这个变量是干嘛的，贴源码：</p>\n<pre><code># ActivityManagerNative.java\n\nprivate static final Singleton&lt;IActivityManager&gt; gDefault = new Singleton&lt;IActivityManager&gt;() {\n    protected IActivityManager create() {\n        IBinder b = ServiceManager.getService(&quot;activity&quot;);\n        if (false) {\n            Log.v(&quot;ActivityManager&quot;, &quot;default service binder = &quot; + b);\n        }\n        IActivityManager am = asInterface(b);\n        if (false) {\n            Log.v(&quot;ActivityManager&quot;, &quot;default service = &quot; + am);\n        }\n        return am;\n    }\n};\n</code></pre><p>我们知道，Android中ActivityManager是与系统所有运行着的Activity进行交互，对系统所有运行的Activity进行管理和维护，但是这些信息真正维护并不是由ActivityManager来负责。读起来有点绕，RTFSC是王道，截取其中一段获取运行服务的方法：</p>\n<pre><code># ActivityManager.java\n\npublic List&lt;RunningServiceInfo&gt; getRunningServices(int maxNum)\n        throws SecurityException {\n    try {\n        return ActivityManagerNative.getDefault()\n                .getServices(maxNum, 0);\n    } catch (RemoteException e) {\n        // System dead, we will be dead too soon!\n        return null;\n    }\n}\n</code></pre><p>通过阅读ActivityManager的源码发现，所有的信息都是通过ActivityManagerNative.getDefault()来操作获取。哎呦，这里面到底是干了啥？我们先来看一幅Activity Manager相关类继承层次关系图：</p>\n<p><img src=\"http://i.imgur.com/ToILsf2.jpg\" alt=\"\"></p>\n<p>ActivityManagerProxy，见名思意，是一个代理类，同时也是ActivityManagerNative的内部类；ActivityManagerNative是一个抽象类，实现它的是ActivityManagerService，这是一个系统Service组件。<br>从图中可以看出，使用ActivityManagerProxy，来代理ActivityManagerNative，实质就是代理它的实现类ActivityManagerService；ActivityManagerService是系统统一的Service，运行在独立的进程中，通过系统ServiceManger来获取。</p>\n<p>那么，问题来了，ActivityManager运行在一个进程里面，ActivityManagerService运行在另一个进程内，这里面涉及到跨进程的对象访问，毫无疑问，采用的是Binder机制实现。</p>\n<p>我们从刚刚截取的ActivityManagerNative.java中定义gDefault的方法可以看到，首先获取“activity”的IBinder</p>\n<pre><code>IBinder b = ServiceManager.getService(&quot;activity&quot;);\n</code></pre><p>这个可以从以下源码得知，其中sCache存放的是名字和对应IBinder的键值对Map</p>\n<pre><code># ServiceManager.java\n\n/**\n * Returns a reference to a service with the given name.\n * \n * @param name the name of the service to get\n * @return a reference to the service, or &lt;code&gt;null&lt;/code&gt; if the service doesn&apos;t exist\n */\npublic static IBinder getService(String name) {\n    try {\n        IBinder service = sCache.get(name);\n        if (service != null) {\n            return service;\n        } else {\n            return getIServiceManager().getService(name);\n        }\n    } catch (RemoteException e) {\n        Log.e(TAG, &quot;error in getService&quot;, e);\n    }\n    return null;\n}\n</code></pre><p>然后通过 asInterface(b) 就获取了ActivityManagerService实例的本地代理对象ActivityManagerProxy实例：</p>\n<pre><code># ActivityManagerNative.java\n\n/**\n * Cast a Binder object into an activity manager interface, generating\n * a proxy if needed.\n */\nstatic public IActivityManager asInterface(IBinder obj) {\n    if (obj == null) {\n        return null;\n    }\n    IActivityManager in =\n        (IActivityManager)obj.queryLocalInterface(descriptor);\n    if (in != null) {\n        return in;\n    }\n\n    return new ActivityManagerProxy(obj);\n}\n</code></pre><p>贴上一图，让你瞬间有豁然开朗的感觉有木有：</p>\n<p><img src=\"http://i.imgur.com/Au935XN.jpg\" alt=\"\"></p>\n<p>ok，回到我们的最原点，找到系统的IActivityManager要干嘛？当然就是我们的劫持hook了，在说hook之前，要说说动态代理机制。</p>\n<h2 id=\"动态代理机制\"><a href=\"#动态代理机制\" class=\"headerlink\" title=\"动态代理机制\"></a>动态代理机制</h2><p>动态代理，是一种设计模式，可以为其他对象提供一种代理以控制对这个对象的访问。举一个肤浅的栗子：</p>\n<pre><code>   public Object invoke( Object proxy, Method method, Object[] args ) throws Throwable   \n  {   \n//1.在转调具体目标对象之前，可以执行一些功能处理\n\n//2.转调具体目标对象的方法\nreturn method.invoke( proxied, args);  \n\n//3.在转调具体目标对象之后，可以执行一些功能处理\n\n  }\n} \n</code></pre><p>所谓代理，就是首先要获得被代理者的控制权，被代理者在正常调用的时候，代理可以在被代理者的所有方法前或后添加想要的操作。从上图简单地理解，就是在2方法（被代理者）添加1和3方法。可以看一下代理结构图：</p>\n<p><img src=\"http://i.imgur.com/s0zRfSt.gif\" alt=\"\"></p>\n<p>在动态代理机制中，有两个重要的类，分别是InvocationHandler和Proxy。我们看一下API帮助文档是怎么对两个类做描述的：</p>\n<p>InvocationHandler：</p>\n<pre><code>InvocationHandler is the interface implemented by the invocation handler of a proxy instance. \n\nEach proxy instance has an associated invocation handler. When a method is invoked on a proxy instance, the method invocation is encoded and dispatched to the invoke method of its invocation handler.\n</code></pre><p>每一个动态代理类必须要实现InvocationHandler这个接口，而InvocationHandler这个接口只有唯一一个invoke方法：</p>\n<pre><code>Object invoke(Object proxy, Method method, Object[] args) throws Throwable\n\nproxy:　　指代我们所代理的那个真实对象\nmethod:　 指代的是我们所要调用真实对象的某个方法的Method对象\nargs:　　 指代的是调用真实对象某个方法时接受的参数\n</code></pre><p>Proxy：</p>\n<pre><code>Proxy provides static methods for creating dynamic proxy classes and instances, and it is also the superclass of all dynamic proxy classes created by those methods. \n</code></pre><p>Proxy这个类的作用是创建一个代理对象的类，它提供了很多方法，在这里我们只需要了解到newProxyInstance 即可：</p>\n<pre><code>public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException\n\nloader:　　  一个ClassLoader对象，定义了由哪个ClassLoader对象来对生成的代理对象进行加载   \ninterfaces:  一个Interface对象的数组，表示的是我将要给我需要代理的对象提供一组什么接口，如果我提供了一组接口给它，那么这个代理对象就宣称实现了该接口(多态)，这样我就能调用这组接口中的方法了\n   h:　　        一个InvocationHandler对象，表示的是当我这个动态代理对象在调用方法的时候，会关联到哪一个InvocationHandler对象上\n</code></pre><p>ok，有了点概念，我们来继续举个具体点的栗子：</p>\n<p>定义一个people的接口：</p>\n<pre><code>public interface People{\n    public void countMoney();\n}\n</code></pre><p>boss类去实现这个接口：</p>\n<pre><code>public class Boss implements people{\n    @Override\n    public void countMoney(){\n        system.out.println(&quot;I have too money to burn.&quot;);\n    }\n} \n</code></pre><p>定义一个代理类workers，前面说到了，每一个代理类必须实现InvocationHandler 这个接口：</p>\n<pre><code>public class Workers implements InvocationHandler{\n    //这个是我们要代理的真实对象\n    private Object people;\n\n    //构造方法，给我们要代理的真实对象赋值\n    public workers(Object people){\n        this.people = people;\n    }\n\n    @Override\n    public Object invoke(Object object, Method method, Object[] args){\n\n        //在代理真实对象之前加上一些操作\n        system.out.println(&quot;I must word hard because I have no money.&quot;);\n\n        //调用真实对象的相关方法\n        method.invoke(subject, args);\n\n        //在代理真实对象之后加上一些操作\n        system.out.println(&quot;Whether you have got money or not,it&apos;s wise for you to go back home for the Spring Festival.&quot;);\n    }\n} \n</code></pre><p>编写测试类：</p>\n<pre><code>public class test{\n    ....\n    Boss boss = new Boss;\n    InvocationHandle handle = new Workers(boss);\n    Workers workers = (Workers) Proxy.newProxyInstance(handle.getClass().getClassLoader(),boss.getClass().getInterfaces(),handle);\n\n    workers.countMoney();\n\n}\n</code></pre><p>看一下输出结果：</p>\n<pre><code>I must word hard because I have no money.\nI have too money to burn.\nWhether you have got money or not,it&apos;s wise for you to go back home for the Spring Festival.\n</code></pre><p>结果很明显了，如果想了解其中的跳转原理，请查看源码，这里就不多作介绍了。</p>\n<h2 id=\"开始Hook\"><a href=\"#开始Hook\" class=\"headerlink\" title=\"开始Hook\"></a>开始Hook</h2><p>我们来看看onInstall方法的后半部分：</p>\n<pre><code># IActivityManagerHook.java\n\npublic void onInstall(ClassLoader classLoader) throws Throwable {\n    .....\n\n    if (IActivityManagerCompat.isIActivityManager(obj)) {\n        setOldObj(obj);\n        Class&lt;?&gt; objClass = mOldObj.getClass();\n        List&lt;Class&lt;?&gt;&gt; interfaces = Utils.getAllInterfaces(objClass);\n        Class[] ifs = interfaces != null &amp;&amp; interfaces.size() &gt; 0 ? interfaces.toArray(new Class[interfaces.size()]) : new Class[0];\n        Object proxiedActivityManager = MyProxy.newProxyInstance(objClass.getClassLoader(), ifs, this);\n        FieldUtils.writeStaticField(cls, &quot;gDefault&quot;, proxiedActivityManager);\n        Log.i(TAG, &quot;Install ActivityManager Hook 1 old=%s,new=%s&quot;, mOldObj, proxiedActivityManager);\n    } \n\n        .......\n    }\n</code></pre><p>首先，判断上面获取找到系统的IActivityManager是否正确，然后setOldObj(obj)保存当前系统的IActivityManager对象，留意IActivityManagerHook类是继承ProxyHook，该类实现InvocationHandler接口，就是一个代理类的实体啊。ok，你应该留意到接下来的操作就是介绍如何一步步实现代理，并把代理对象写到ActivityManagerNative的gDefault变量中，这样就实现hook了：</p>\n<pre><code>Object proxiedActivityManager = MyProxy.newProxyInstance(objClass.getClassLoader(), ifs, this);\nFieldUtils.writeStaticField(cls, &quot;gDefault&quot;, proxiedActivityManager);\n</code></pre><p>classLoader和获取所有接口数组都是沿用mOldObj对象。</p>\n<p>hook之后就开始干坏事了，把目光转到ProxyHook类中的invoke方法：</p>\n<pre><code># ProxyHook.java\n\npublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\n    try {\n        if (!isEnable()) {\n            return method.invoke(mOldObj, args);\n        }\n        HookedMethodHandler hookedMethodHandler = mHookHandles.getHookedMethodHandler(method);\n        if (hookedMethodHandler != null) {\n            return hookedMethodHandler.doHookInner(mOldObj, method, args);\n        }\n        return method.invoke(mOldObj, args);\n    } catch (InvocationTargetException e) {\n        Throwable cause = e.getTargetException();\n     .......\n}    \n</code></pre><p>首先，isEnable()先判断一下这个函数是否可以hook，不可以的话直接返回mOldObj（系统）的原本方法；可以的话继续往下走：</p>\n<pre><code># ProxyHook.java\n\nHookedMethodHandler hookedMethodHandler = mHookHandles.getHookedMethodHandler(method);\nif (hookedMethodHandler != null) {\n    return hookedMethodHandler.doHookInner(mOldObj, method, args);\n}\nreturn method.invoke(mOldObj, args);\n</code></pre><p>根据方法名字获取一个hookedMethodHandler，如果不为空，则执行hookedMethodHandler的doHookInner方法；如果为空，依旧返回系统的原本方法。</p>\n<p>hookedMethodHandler是什么鬼？还记得上面提到的IActivityManagerHookHandle的init()方法？是的，这里就要用到，先看一下之前的init()代码：</p>\n<pre><code># IActivityManagerHookHandle.java\n\nprotected void init() {\n    sHookedMethodHandlers.put(&quot;startActivity&quot;, new startActivity(mHostContext));\n    sHookedMethodHandlers.put(&quot;startActivityAsUser&quot;, new startActivityAsUser(mHostContext));\n    sHookedMethodHandlers.put(&quot;startActivityAsCaller&quot;, new startActivityAsCaller(mHostContext));\n    sHookedMethodHandlers.put(&quot;startActivityAndWait&quot;, new startActivityAndWait(mHostContext));\n    sHookedMethodHandlers.put(&quot;startActivityWithConfig&quot;, new startActivityWithConfig(mHostContext));\n    sHookedMethodHandlers.put(&quot;startActivityIntentSender&quot;, new startActivityIntentSender(mHostContext));\n    sHookedMethodHandlers.put(&quot;startVoiceActivity&quot;, new startVoiceActivity(mHostContext));\n    sHookedMethodHandlers.put(&quot;startNextMatchingActivity&quot;, new startNextMatchingActivity(mHostContext));\n    sHookedMethodHandlers.put(&quot;startActivityFromRecents&quot;, new startActivityFromRecents(mHostContext));\n  ...........\n}\n</code></pre><p>初始化把所有方法和对应的HookedMethodHandler处理类放在一起。</p>\n<p>我们假如传入一个方法名为startActivity，hookedMethodHandler存在，并进入doHookInner方法：</p>\n<pre><code># HookedMethodHandler.java\n\npublic synchronized Object doHookInner(Object receiver, Method method, Object[] args) throws Throwable {\n    long b = System.currentTimeMillis();\n    try {\n        mUseFakedResult = false;\n        mFakedResult = null;\n        boolean suc = beforeInvoke(receiver, method, args);\n        Object invokeResult = null;\n        if (!suc) {\n            invokeResult = method.invoke(receiver, args);\n        }\n        afterInvoke(receiver, method, args, invokeResult);\n        if (mUseFakedResult) {\n            return mFakedResult;\n        } else {\n            return invokeResult;\n        }\n    } \n.........\n}\n</code></pre><p>从上面看到熟悉的动态代理，先执行beforeInvoke方法，如果结果为true，拦截了该事件；如果为false，还是会继续执行系统原本方法，最后调用afterInvoke方法。在HookedMethodHandler里面beforeInvoke方法默认返回false，afterInvoke方法并没有实现：</p>\n<pre><code># HookedMethodHandler.java\n\n/**\n * 在某个方法被调用之前执行，如果返回true，则不执行原始的方法，否则执行原始方法\n */\nprotected boolean beforeInvoke(Object receiver, Method method, Object[] args) throws Throwable {\n    return false;\n}\n\nprotected void afterInvoke(Object receiver, Method method, Object[] args, Object invokeResult) throws Throwable {\n}\n</code></pre><p>如果需要实现肯定是在子类了，在IActivityManagerHookHandle的init()方法里面，以startActivity为例：</p>\n<pre><code>private static class startActivity extends HookedMethodHandler {\n\n    public startActivity(Context hostContext) {\n        super(hostContext);\n    }\n    ......\n    @Override\n    protected boolean beforeInvoke(Object receiver, Method method, Object[] args) throws Throwable {\n        if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.JELLY_BEAN_MR2) {\n            //2.3\n    /*public int startActivity(IApplicationThread caller,\n        Intent intent, String resolvedType, Uri[] grantedUriPermissions,\n        int grantedMode, IBinder resultTo, String resultWho, int requestCode,\n        boolean onlyIfNeeded, boolean debug) throws RemoteException;*/\n\n            //api 15\n    /*public int startActivity(IApplicationThread caller,\n        Intent intent, String resolvedType, Uri[] grantedUriPermissions,\n        int grantedMode, IBinder resultTo, String resultWho, int requestCode,\n        boolean onlyIfNeeded, boolean debug, String profileFile,\n        ParcelFileDescriptor profileFd, boolean autoStopProfiler) throws RemoteException;*/\n\n            //api 16,17\n    /*  public int startActivity(IApplicationThread caller,\n        Intent intent, String resolvedType, IBinder resultTo, String resultWho,\n        int requestCode, int flags, String profileFile,\n        ParcelFileDescriptor profileFd, Bundle options) throws RemoteException;*/\n            doReplaceIntentForStartActivityAPILow(args);\n        } else {\n            //api 18,19\n     /*  public int startActivity(IApplicationThread caller, String callingPackage,\n        Intent intent, String resolvedType, IBinder resultTo, String resultWho,\n        int requestCode, int flags, String profileFile,\n        ParcelFileDescriptor profileFd, Bundle options) throws RemoteException;*/\n\n            //api 21\n    /*   public int startActivity(IApplicationThread caller, String callingPackage,\n        Intent intent, String resolvedType, IBinder resultTo, String resultWho,\n        int requestCode, int flags, ProfilerInfo profilerInfo,\n        Bundle options) throws RemoteException;*/\n            doReplaceIntentForStartActivityAPIHigh(args);\n        }\n        return super.beforeInvoke(receiver, method, args);\n    }\n}\n</code></pre><p>至此，hook的过程应该已经介绍完毕，其中涉及比较高深的问题，小弟完美绕过。</p>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjcyyg7jr0007nius4i5tj02w","category_id":"cjcyyg7jj0004niusdy23act6","_id":"cjcyyg7k6000enius4xurgwo3"},{"post_id":"cjcyyg7j90002niuso4ugd0k7","category_id":"cjcyyg7jj0004niusdy23act6","_id":"cjcyyg7kb000iniusko06voc9"},{"post_id":"cjcyyg7k1000cniushjqbq9w7","category_id":"cjcyyg7jj0004niusdy23act6","_id":"cjcyyg7kf000lnius6tu0bw4a"},{"post_id":"cjcyyg7jg0003niusfyp73gk3","category_id":"cjcyyg7jj0004niusdy23act6","_id":"cjcyyg7kk000pniusge70yt8y"},{"post_id":"cjcyyg7jp0006niusrm77mq0h","category_id":"cjcyyg7jj0004niusdy23act6","_id":"cjcyyg7ko000sniustjh46mi1"},{"post_id":"cjcyyg7kh000onius2wucunog","category_id":"cjcyyg7jj0004niusdy23act6","_id":"cjcyyg7kr000wnius9y54cr2z"},{"post_id":"cjcyyg7ju0008nius2i23pwfo","category_id":"cjcyyg7kf000mnius00vwqlmh","_id":"cjcyyg7ks000yniusukyufcne"},{"post_id":"cjcyyg7k5000dnius6vpzyzbp","category_id":"cjcyyg7ko000tniusphb8gny1","_id":"cjcyyg7ks0011nius2r2v73hx"},{"post_id":"cjcyyg7k9000hnius9pkz8xmz","category_id":"cjcyyg7kr000xniusw5wudfrk","_id":"cjcyyg7kv0016niustc3469v1"},{"post_id":"cjcyyg7kd000kniusnl79yvgi","category_id":"cjcyyg7ko000tniusphb8gny1","_id":"cjcyyg7kw0019niusulrzjs5v"},{"post_id":"cjcyyg7kl000rniusx27na9cz","category_id":"cjcyyg7ko000tniusphb8gny1","_id":"cjcyyg7ky001cniusknd49ts1"},{"post_id":"cjcyyg7l2001iniusmrjauzgn","category_id":"cjcyyg7ko000tniusphb8gny1","_id":"cjcyyg7l6001knius7uzeygcb"}],"PostTag":[{"post_id":"cjcyyg7j90002niuso4ugd0k7","tag_id":"cjcyyg7jo0005niuso47mrfjz","_id":"cjcyyg7k0000bniusgwvfome5"},{"post_id":"cjcyyg7jg0003niusfyp73gk3","tag_id":"cjcyyg7jx000aniusi4bvrhph","_id":"cjcyyg7kc000jniusgzu5yynn"},{"post_id":"cjcyyg7jp0006niusrm77mq0h","tag_id":"cjcyyg7k7000gnius6q93evik","_id":"cjcyyg7kk000qniusich2uswl"},{"post_id":"cjcyyg7jr0007nius4i5tj02w","tag_id":"cjcyyg7kg000nniuspo0p4uxf","_id":"cjcyyg7kr000vnius0j5po5bm"},{"post_id":"cjcyyg7ju0008nius2i23pwfo","tag_id":"cjcyyg7kq000uniusetuh6lm0","_id":"cjcyyg7ks0010nius0pbplrbm"},{"post_id":"cjcyyg7k1000cniushjqbq9w7","tag_id":"cjcyyg7ks000zniusfa4ugbap","_id":"cjcyyg7ku0014niusiqa39kdj"},{"post_id":"cjcyyg7k5000dnius6vpzyzbp","tag_id":"cjcyyg7ku0013niusmiblttyo","_id":"cjcyyg7kw0018niusy6enttm9"},{"post_id":"cjcyyg7k9000hnius9pkz8xmz","tag_id":"cjcyyg7kv0017niusw9us6f1m","_id":"cjcyyg7kx001bniuspacf59g7"},{"post_id":"cjcyyg7kd000kniusnl79yvgi","tag_id":"cjcyyg7ku0013niusmiblttyo","_id":"cjcyyg7kz001eniusu9ep6nd2"},{"post_id":"cjcyyg7kh000onius2wucunog","tag_id":"cjcyyg7ky001dniusrrkfvyn7","_id":"cjcyyg7l0001gniusopplpv5j"},{"post_id":"cjcyyg7kl000rniusx27na9cz","tag_id":"cjcyyg7ku0013niusmiblttyo","_id":"cjcyyg7l1001hniusbr2qskfv"},{"post_id":"cjcyyg7l2001iniusmrjauzgn","tag_id":"cjcyyg7ku0013niusmiblttyo","_id":"cjcyyg7l5001jnius4g873jpa"}],"Tag":[{"name":"Android，多dex，65536","_id":"cjcyyg7jo0005niuso47mrfjz"},{"name":"Android，AndResguard","_id":"cjcyyg7jx000aniusi4bvrhph"},{"name":"Android，，多渠道，pyqt","_id":"cjcyyg7k7000gnius6q93evik"},{"name":"Android，MQTT","_id":"cjcyyg7kg000nniuspo0p4uxf"},{"name":"other","_id":"cjcyyg7kq000uniusetuh6lm0"},{"name":"Android，MQTT，ping","_id":"cjcyyg7ks000zniusfa4ugbap"},{"name":"android","_id":"cjcyyg7ku0013niusmiblttyo"},{"name":"python","_id":"cjcyyg7kv0017niusw9us6f1m"},{"name":"Android，Tinker","_id":"cjcyyg7ky001dniusrrkfvyn7"}]}}