{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":0,"renderable":1},{"_id":"themes/spfk/source/apple-touch-icon.png","path":"apple-touch-icon.png","modified":0,"renderable":1},{"_id":"themes/spfk/source/css/loading-style.css","path":"css/loading-style.css","modified":0,"renderable":1},{"_id":"themes/spfk/source/css/showshare.css","path":"css/showshare.css","modified":0,"renderable":1},{"_id":"themes/spfk/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/spfk/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/spfk/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/spfk/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/spfk/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/spfk/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/spfk/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/spfk/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/spfk/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/spfk/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/spfk/source/img/coderwall.png","path":"img/coderwall.png","modified":0,"renderable":1},{"_id":"themes/spfk/source/img/delicious.png","path":"img/delicious.png","modified":0,"renderable":1},{"_id":"themes/spfk/source/img/douban.png","path":"img/douban.png","modified":0,"renderable":1},{"_id":"themes/spfk/source/img/facebook.png","path":"img/facebook.png","modified":0,"renderable":1},{"_id":"themes/spfk/source/img/github.png","path":"img/github.png","modified":0,"renderable":1},{"_id":"themes/spfk/source/img/google.png","path":"img/google.png","modified":0,"renderable":1},{"_id":"themes/spfk/source/img/img-err.png","path":"img/img-err.png","modified":0,"renderable":1},{"_id":"themes/spfk/source/img/img-loading.png","path":"img/img-loading.png","modified":0,"renderable":1},{"_id":"themes/spfk/source/img/linkedin.png","path":"img/linkedin.png","modified":0,"renderable":1},{"_id":"themes/spfk/source/img/mail.png","path":"img/mail.png","modified":0,"renderable":1},{"_id":"themes/spfk/source/img/pinboard.png","path":"img/pinboard.png","modified":0,"renderable":1},{"_id":"themes/spfk/source/img/pinterest.png","path":"img/pinterest.png","modified":0,"renderable":1},{"_id":"themes/spfk/source/img/qq.png","path":"img/qq.png","modified":0,"renderable":1},{"_id":"themes/spfk/source/img/rss.png","path":"img/rss.png","modified":0,"renderable":1},{"_id":"themes/spfk/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":0,"renderable":1},{"_id":"themes/spfk/source/img/stackoverflow.png","path":"img/stackoverflow.png","modified":0,"renderable":1},{"_id":"themes/spfk/source/img/twitter.png","path":"img/twitter.png","modified":0,"renderable":1},{"_id":"themes/spfk/source/img/wechat.png","path":"img/wechat.png","modified":0,"renderable":1},{"_id":"themes/spfk/source/img/weibo.png","path":"img/weibo.png","modified":0,"renderable":1},{"_id":"themes/spfk/source/img/zhihu.png","path":"img/zhihu.png","modified":0,"renderable":1},{"_id":"themes/spfk/source/js/TweenMax.js","path":"js/TweenMax.js","modified":0,"renderable":1},{"_id":"themes/spfk/source/js/clipboard.min.js","path":"js/clipboard.min.js","modified":0,"renderable":1},{"_id":"themes/spfk/source/js/instagram.js","path":"js/instagram.js","modified":0,"renderable":1},{"_id":"themes/spfk/source/js/jquery.lazyload.js","path":"js/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/spfk/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/spfk/source/js/mobile.js","path":"js/mobile.js","modified":0,"renderable":1},{"_id":"themes/spfk/source/js/pace.js","path":"js/pace.js","modified":0,"renderable":1},{"_id":"themes/spfk/source/js/pc.js","path":"js/pc.js","modified":0,"renderable":1},{"_id":"themes/spfk/source/js/plugins.js","path":"js/plugins.js","modified":0,"renderable":1},{"_id":"themes/spfk/source/img/head.jpg","path":"img/head.jpg","modified":0,"renderable":1},{"_id":"themes/spfk/source/js/TweenMax.min.js","path":"js/TweenMax.min.js","modified":0,"renderable":1},{"_id":"themes/spfk/source/js/embed.js","path":"js/embed.js","modified":0,"renderable":1},{"_id":"themes/spfk/source/background/bg-11.jpg","path":"background/bg-11.jpg","modified":0,"renderable":1},{"_id":"themes/spfk/source/background/bg-17.jpg","path":"background/bg-17.jpg","modified":0,"renderable":1},{"_id":"themes/spfk/source/background/bg-20.jpg","path":"background/bg-20.jpg","modified":0,"renderable":1},{"_id":"themes/spfk/source/background/bg-3.jpg","path":"background/bg-3.jpg","modified":0,"renderable":1},{"_id":"themes/spfk/source/css/pace/pace-theme-flash.css","path":"css/pace/pace-theme-flash.css","modified":0,"renderable":1},{"_id":"themes/spfk/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/spfk/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/spfk/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/spfk/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/spfk/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/spfk/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/spfk/source/font-awesome/css/font-awesome.css","path":"font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/spfk/source/font-awesome/css/font-awesome.min.css","path":"font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/spfk/source/js/404/jquery.parallaxify-0.0.2.min.js","path":"js/404/jquery.parallaxify-0.0.2.min.js","modified":0,"renderable":1},{"_id":"themes/spfk/source/background/bg-15.jpg","path":"background/bg-15.jpg","modified":0,"renderable":1},{"_id":"themes/spfk/source/background/bg-23.jpg","path":"background/bg-23.jpg","modified":0,"renderable":1},{"_id":"themes/spfk/source/background/bg-7.jpg","path":"background/bg-7.jpg","modified":0,"renderable":1},{"_id":"themes/spfk/source/font-awesome/fonts/FontAwesome.otf","path":"font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/spfk/source/font-awesome/fonts/fontawesome-webfont.eot","path":"font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/spfk/source/font-awesome/fonts/fontawesome-webfont.woff2","path":"font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/spfk/source/font-awesome/fonts/fontawesome-webfont.woff","path":"font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/spfk/source/js/404/jquery-2.0.3.min.js","path":"js/404/jquery-2.0.3.min.js","modified":0,"renderable":1},{"_id":"themes/spfk/source/background/bg-14.jpg","path":"background/bg-14.jpg","modified":0,"renderable":1},{"_id":"themes/spfk/source/background/bg-9.jpg","path":"background/bg-9.jpg","modified":0,"renderable":1},{"_id":"themes/spfk/source/font-awesome/fonts/fontawesome-webfont.ttf","path":"font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/spfk/source/background/bg-19.jpg","path":"background/bg-19.jpg","modified":0,"renderable":1},{"_id":"themes/spfk/source/background/bg-22.jpg","path":"background/bg-22.jpg","modified":0,"renderable":1},{"_id":"themes/spfk/source/background/bg-24.jpg","path":"background/bg-24.jpg","modified":0,"renderable":1},{"_id":"themes/spfk/source/background/bg-4.jpg","path":"background/bg-4.jpg","modified":0,"renderable":1},{"_id":"themes/spfk/source/background/bg-8.jpg","path":"background/bg-8.jpg","modified":0,"renderable":1},{"_id":"themes/spfk/source/background/bg-10.jpg","path":"background/bg-10.jpg","modified":0,"renderable":1},{"_id":"themes/spfk/source/img/bg.jpg","path":"img/bg.jpg","modified":0,"renderable":1},{"_id":"themes/spfk/source/background/bg-111.jpg","path":"background/bg-111.jpg","modified":0,"renderable":1},{"_id":"themes/spfk/source/background/bg-13.jpg","path":"background/bg-13.jpg","modified":0,"renderable":1},{"_id":"themes/spfk/source/font-awesome/fonts/fontawesome-webfont.svg","path":"font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/spfk/source/background/bg-2.jpg","path":"background/bg-2.jpg","modified":0,"renderable":1},{"_id":"themes/spfk/source/background/bg-5.jpg","path":"background/bg-5.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/landscape/.npmignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1472909234930},{"_id":"themes/landscape/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1472909234932},{"_id":"themes/landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1472909234931},{"_id":"themes/landscape/_config.yml","hash":"fb8c98a0f6ff9f962637f329c22699721854cd73","modified":1472909234931},{"_id":"themes/landscape/README.md","hash":"c7e83cfe8f2c724fc9cac32bd71bb5faf9ceeddb","modified":1472909234964},{"_id":"themes/landscape/package.json","hash":"85358dc34311c6662e841584e206a4679183943f","modified":1472909234943},{"_id":"source/_posts/hello-world.md","hash":"8a02477044e2b77f1b262da2c48c01429e4a32e4","modified":1472909234930},{"_id":"themes/landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1472909234988},{"_id":"themes/landscape/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1472909234988},{"_id":"themes/landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1472909234991},{"_id":"themes/landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1472909234989},{"_id":"themes/landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1472909234988},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1472909234988},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1472909234990},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1472909234992},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1472909234989},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1472909234990},{"_id":"themes/landscape/layout/layout.ejs","hash":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1472909234999},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1472909234990},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1472909234990},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1472909234997},{"_id":"themes/landscape/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1472909234988},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"931aaaffa0910a48199388ede576184ff15793ee","modified":1472909235144},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1472909235149},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"82a30f81c0e8ba4a8af17acd6cc99e93834e4d5e","modified":1472909235145},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"c4c835615d96a950d51fa2c3b5d64d0596534fed","modified":1472909235150},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"93518893cf91287e797ebac543c560e2a63b8d0e","modified":1472909235144},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"4fe8853e864d192701c03e5cd3a5390287b90612","modified":1472909235149},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1472909235145},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"c21ca56f419d01a9f49c27b6be9f4a98402b2aa3","modified":1472909235152},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1472909235150},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1472909235151},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1472909235153},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1472909235153},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1472909235164},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1472909235154},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1472909235159},{"_id":"themes/landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1472909235160},{"_id":"themes/landscape/source/css/_variables.styl","hash":"5e37a6571caf87149af83ac1cc0cdef99f117350","modified":1472909235162},{"_id":"themes/landscape/source/css/style.styl","hash":"a70d9c44dac348d742702f6ba87e5bb3084d65db","modified":1472909235161},{"_id":"themes/landscape/source/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1472909235165},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1472909235161},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1472909235163},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1472909235162},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1472909235164},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1472909235165},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1472909235164},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1472909235299},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1472909235318},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1472909235323},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1472909235301},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1472909235302},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1472909235303},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1472909235306},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1472909235303},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1472909235305},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1472909235309},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"10685f8787a79f79c9a26c2f943253450c498e3e","modified":1472909235312},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1472909235309},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1472909235307},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1472909235310},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1472909235310},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1472909235309},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1472909235311},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1472909235312},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1472909235312},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1472909235314},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1472909235313},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1472909235321},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1472909235329},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1472909235325},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1472909235320},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1472909235327},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1472909235322},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1472909235325},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1472909235324},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1472909235323},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1472909235332},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1472909235335},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1472909235333},{"_id":"public/2016/09/03/hello-world/index.html","hash":"45c1a113376e377218899d2f859ad335d48f8bc9","modified":1472910844156},{"_id":"public/archives/index.html","hash":"b8c0d3e4f23fa2229d26aa9441b2cd2328bbec10","modified":1472995556025},{"_id":"public/archives/2016/index.html","hash":"17ff2f0def65e0c014f87c98b3e23fb2c775385c","modified":1472995556025},{"_id":"public/archives/2016/09/index.html","hash":"238130ea601f5606dc3906de8dfa215b6d6488c2","modified":1472995556025},{"_id":"public/index.html","hash":"c974d5cbbcc52e68e415cd82cab74a52bf023c61","modified":1472995556026},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1472909835885},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1472909835885},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1472909835885},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1472909835886},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1472909835886},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1472909835886},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1472909835886},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1472909835886},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1472909835886},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1472909835886},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1472909836609},{"_id":"public/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1472909836621},{"_id":"public/fancybox/jquery.fancybox.css","hash":"b6aa6692c2e5f8bd74d96827b78570f0c5683c20","modified":1472910845323},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1472909836621},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1472909836621},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1472909836621},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1472909836621},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1472909836621},{"_id":"public/css/style.css","hash":"7f7da82693557f8d599062bf927435a0d8bf7de5","modified":1472910845324},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1472909836627},{"_id":"public/fancybox/jquery.fancybox.js","hash":"a82597493d75ea989ca586e09173cff332efe41e","modified":1472910845324},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1472909836637},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1472909836639},{"_id":"themes/spfk/.gitignore","hash":"79b4a9ac435bc5833a0bc461ebacb10908b34ed3","modified":1472910724013},{"_id":"themes/spfk/README.md","hash":"8749e56d2f2fb3076038b105a6618fa3ec97a1ab","modified":1472910724018},{"_id":"themes/spfk/_config.yml","hash":"d00f93ceae97a673b3d258b93231cfecb138235f","modified":1472995515442},{"_id":"themes/spfk/package.json","hash":"0199dfb3d44cf520b67464817d13c44a7766b8d6","modified":1472910724331},{"_id":"themes/spfk/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1472910723983},{"_id":"themes/spfk/.git/config","hash":"67ae2101e59a22c6990284044eea713454e18256","modified":1472910724000},{"_id":"themes/spfk/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1472910077300},{"_id":"themes/spfk/.git/index","hash":"b15da1edc620a6701b2e7954d9d7848ed41db0cd","modified":1472913471333},{"_id":"themes/spfk/.git/packed-refs","hash":"9b623ac053eaa64941af6d95208a30e4be3b5955","modified":1472910723969},{"_id":"themes/spfk/languages/de.yml","hash":"bc80f78f61c3d7af9652e6aa6fc3e4ff39b0c8d3","modified":1472910724025},{"_id":"themes/spfk/languages/default.yml","hash":"f0a7a032b31555c9ec05a711e1ac19bb07724708","modified":1472910724028},{"_id":"themes/spfk/languages/en.yml","hash":"a093e794aef63ec9e9e9ef490cf7e4474e45e59f","modified":1472910724031},{"_id":"themes/spfk/languages/fr-FR.yml","hash":"04b9a0d80d88d01e039e8077afe88f741e9620ba","modified":1472910724034},{"_id":"themes/spfk/languages/pt-BR","hash":"9e8a1942a32af8720c9fbca8db14eb89d76c21bd","modified":1472910724037},{"_id":"themes/spfk/languages/zh-Hans.yml","hash":"d2336578e14bb880d152266981c2b17523fc8742","modified":1472910724043},{"_id":"themes/spfk/languages/ru.yml","hash":"62f84ea82a696060c481fc22d4742e6201bb9bdc","modified":1472910724040},{"_id":"themes/spfk/languages/zh-hk.yml","hash":"e702fc43556e54c396917bdf7c869d528742e28b","modified":1472910724046},{"_id":"themes/spfk/languages/zh-tw.yml","hash":"005559baa96b7bb34e1efe6b031829a95d58d5e0","modified":1472910724049},{"_id":"themes/spfk/languages/zh.yml","hash":"d2336578e14bb880d152266981c2b17523fc8742","modified":1472910724050},{"_id":"themes/spfk/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1472910724304},{"_id":"themes/spfk/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1472910724307},{"_id":"themes/spfk/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1472910724310},{"_id":"themes/spfk/layout/layout.ejs","hash":"3a4350f23a1286345f76c949466c97a7200dae8e","modified":1472910724317},{"_id":"themes/spfk/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1472910724320},{"_id":"themes/spfk/layout/plugins.swig","hash":"4c978bfbde006b6e3b82f4931541fada9381806d","modified":1472910724324},{"_id":"themes/spfk/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1472910724325},{"_id":"themes/spfk/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1472910724328},{"_id":"themes/spfk/source/apple-touch-icon.png","hash":"c36a373c7830d61d1ce092bd5a88d0e9b54212fd","modified":1472910724333},{"_id":"themes/spfk/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1472910077302},{"_id":"themes/spfk/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1472910077305},{"_id":"themes/spfk/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1472910077306},{"_id":"themes/spfk/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1472910077307},{"_id":"themes/spfk/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1472910077308},{"_id":"themes/spfk/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1472910077310},{"_id":"themes/spfk/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1472910077311},{"_id":"themes/spfk/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1472910077312},{"_id":"themes/spfk/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1472910077313},{"_id":"themes/spfk/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1472910077314},{"_id":"themes/spfk/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1472910077316},{"_id":"themes/spfk/.git/logs/HEAD","hash":"5dab39ec64e86ef43cebb79bd1fb3b84a959b094","modified":1472910723989},{"_id":"themes/spfk/layout/_partial/after-footer.ejs","hash":"686daa64647a37c61cb348eaa55118b73d866d1b","modified":1472910724063},{"_id":"themes/spfk/layout/_partial/archive-post.ejs","hash":"0ecc2ad07b4abad80f564ac1858c50bcbdff34f8","modified":1472910724078},{"_id":"themes/spfk/layout/_partial/archive.ejs","hash":"a4eacc2bc1278095a0ef99f904b0634c78f980eb","modified":1472910724087},{"_id":"themes/spfk/layout/_partial/article.ejs","hash":"33a9e21698fe3038a7dfcf0f34d73901482c49db","modified":1472910724105},{"_id":"themes/spfk/layout/_partial/background.ejs","hash":"054cbde2b775dd05f942e62d3ba5374ff8c71fea","modified":1472910724113},{"_id":"themes/spfk/layout/_partial/bodybackground.ejs","hash":"ad24b949bbe4fadf7549be3d1df76fc7444d1adc","modified":1472910724119},{"_id":"themes/spfk/layout/_partial/case.swig","hash":"ff7174ff79bfe82a70b03a07d78583b1e8d1827f","modified":1472910724122},{"_id":"themes/spfk/layout/_partial/footer.ejs","hash":"db08f6276c2b501ad16a335f5d0d06c1b4e24d35","modified":1472910724145},{"_id":"themes/spfk/layout/_partial/head.ejs","hash":"d037a5fb0f81571ae454187deaae68f1285db56d","modified":1472910724161},{"_id":"themes/spfk/layout/_partial/header.ejs","hash":"b69855e07b65117769adc515cb64b803932068c9","modified":1472910724166},{"_id":"themes/spfk/layout/_partial/hide-labels.ejs","hash":"21ffa5e590b1588b61b7de66c81a992ff87e9b36","modified":1472910724172},{"_id":"themes/spfk/layout/_partial/left-col.ejs","hash":"a891989f050ccc5e4765c5629f6442482b9daba9","modified":1472910724179},{"_id":"themes/spfk/layout/_partial/mathjax.ejs","hash":"34b2d7050db88fed9f70b8233f16f451bad501f4","modified":1472910724185},{"_id":"themes/spfk/layout/_partial/mobile-nav.ejs","hash":"d4565d52e6536465c740ad8dc5737c2e8eed9f05","modified":1472910724188},{"_id":"themes/spfk/layout/_partial/page.ejs","hash":"112353124225cada3e44644151f069655db9494b","modified":1472910724199},{"_id":"themes/spfk/layout/_partial/plugin.swig","hash":"b8539477a33580d9e493365f16e7b7d40afc5e5c","modified":1472910724202},{"_id":"themes/spfk/layout/_partial/post-nav-button.ejs","hash":"31592c7f86fa062f20ed2afb2e5656ae8151ba80","modified":1472910724207},{"_id":"themes/spfk/layout/_partial/scrolling-button.ejs","hash":"40573748d4a14530e6052836ef8a7063e6486d45","modified":1472910724261},{"_id":"themes/spfk/layout/_partial/theme.swig","hash":"96ae0d2429f712faf2964ed74fbeffc395accac2","modified":1472910724290},{"_id":"themes/spfk/layout/_partial/toc.ejs","hash":"c46a2b624281b09d4aeacf2921cd712837469a1d","modified":1472910724299},{"_id":"themes/spfk/layout/_partial/work.swig","hash":"f0191892b19a19d7bb59f97c659611208b53c81d","modified":1472910724302},{"_id":"themes/spfk/source/css/_extend.styl","hash":"8ab1ad313bd6707d248c5ca1ee9a5eab8d815e42","modified":1472910724492},{"_id":"themes/spfk/source/css/_variables.styl","hash":"11fe650f1f335795ab971965c3ec0ed36e211956","modified":1472910724572},{"_id":"themes/spfk/source/css/loading-style.css","hash":"ef12c256b59ed836994afed35bf02556248133ce","modified":1472910724575},{"_id":"themes/spfk/source/css/showshare.css","hash":"bb1fc0da63d3a4584c8c15391e089271e4e82f81","modified":1472910724582},{"_id":"themes/spfk/source/css/style.styl","hash":"5564c0ebba7da680b4958beed2e1a3174dc04fb8","modified":1472910724585},{"_id":"themes/spfk/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1472910724588},{"_id":"themes/spfk/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1472910724589},{"_id":"themes/spfk/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1472910724587},{"_id":"themes/spfk/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1472910724590},{"_id":"themes/spfk/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1472910724591},{"_id":"themes/spfk/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1472910724592},{"_id":"themes/spfk/source/fancybox/jquery.fancybox.css","hash":"96138eaddfbd305160ddcb98a5f08555ca6cb4ee","modified":1472910724625},{"_id":"themes/spfk/source/fancybox/jquery.fancybox.js","hash":"004bb0812414554ab48067792f09e978603253b6","modified":1472910724635},{"_id":"themes/spfk/source/fancybox/jquery.fancybox.pack.js","hash":"2da892a02778236b64076e5e8802ef0566e1d9e8","modified":1472910724647},{"_id":"themes/spfk/source/img/coderwall.png","hash":"fa84676c4d654e040e51fd34bfcd9f9348cd5331","modified":1472910724710},{"_id":"themes/spfk/source/img/delicious.png","hash":"9553a5f5189e4a953e04a58a49dbfa74b86b73dd","modified":1472910724711},{"_id":"themes/spfk/source/img/douban.png","hash":"e2ade003ffadd5826ee66ec23901c2d6e8607e4e","modified":1472910724712},{"_id":"themes/spfk/source/img/facebook.png","hash":"d19ad7a0903daf26817afd8753cd97e0cc714f54","modified":1472910724713},{"_id":"themes/spfk/source/img/favicon.png","hash":"5b4e9c94ff3396db5b074b69c1aa5bb909aba825","modified":1472910724714},{"_id":"themes/spfk/source/img/github.png","hash":"b84d03b32fa388dcbf149296ebd16dce6223d48d","modified":1472910724715},{"_id":"themes/spfk/source/img/google.png","hash":"61a21fec7346fa3400b747ac9a201cf3d5bc013d","modified":1472910724716},{"_id":"themes/spfk/source/img/img-err.png","hash":"23a63ea26eb3c1d5e677d9883cf36cc1a1a1228b","modified":1472910724721},{"_id":"themes/spfk/source/img/img-loading.png","hash":"a9cd5cd11866824f31e3d1c5e23badfeb3f73031","modified":1472910724722},{"_id":"themes/spfk/source/img/linkedin.png","hash":"e203138fb53c257cb214e97f4e30091b9c568d2c","modified":1472910724722},{"_id":"themes/spfk/source/img/mail.png","hash":"fca8199cc77fdbd700a45bf56d091c82f4a67fe7","modified":1472910724723},{"_id":"themes/spfk/source/img/pinboard.png","hash":"0891fbb6d092fa012bf936019923383d84c6aeb0","modified":1472910724725},{"_id":"themes/spfk/source/img/pinterest.png","hash":"9c72917f8779c083157c6ce7a5d62ed4874f0630","modified":1472910724726},{"_id":"themes/spfk/source/img/qq.png","hash":"fd741764c5528fe371f053beac99839a97900eef","modified":1472910724726},{"_id":"themes/spfk/source/img/rss.png","hash":"430fd47340e75214c081abd05cd7410cf7c71b86","modified":1472910724727},{"_id":"themes/spfk/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1472910724728},{"_id":"themes/spfk/source/img/stackoverflow.png","hash":"da5dfe9043055c95e479d49c78cd3b020de608f2","modified":1472910724729},{"_id":"themes/spfk/source/img/twitter.png","hash":"14dbb8e62d056525253bc0de13acd1723da7a934","modified":1472910724732},{"_id":"themes/spfk/source/img/wechat.png","hash":"7ca41b6e32ca4dac419225261ab4fee5a88f73a9","modified":1472910724733},{"_id":"themes/spfk/source/img/weibo.png","hash":"280dae3fd38086158b4a1b57edb94c06b1a5014b","modified":1472910724734},{"_id":"themes/spfk/source/img/zhihu.png","hash":"a6d6ef65e9ac82e613a311810391ebb90d9b1c1d","modified":1472910724735},{"_id":"themes/spfk/source/js/TweenMax.js","hash":"1f60b6ccd135d181b78254468ffda1c7b9d51556","modified":1472910724791},{"_id":"themes/spfk/source/js/clipboard.min.js","hash":"fe53ec94d317bae8f12d1a5eee23040bf02680bb","modified":1472910724833},{"_id":"themes/spfk/source/js/instagram.js","hash":"81e13cacf4947118ed1920e59b04ccf6beef6b86","modified":1472910724863},{"_id":"themes/spfk/source/js/jquery.lazyload.js","hash":"9c34c37b4dca82386648d364da913153d1db902e","modified":1472910724869},{"_id":"themes/spfk/source/js/main.js","hash":"99558632eb0cc7e387fcd7fa942b46cc1e1efc07","modified":1472910724876},{"_id":"themes/spfk/source/js/mobile.js","hash":"baed8d560883c842c2b8c3e0fadcf359f97140d0","modified":1472910724884},{"_id":"themes/spfk/source/js/pace.js","hash":"d9cfcb7e1fc4b827a64491726c9a78b9886b3793","modified":1472910724893},{"_id":"themes/spfk/source/js/pc.js","hash":"482dc45356756150f0bee80c8d9a0987965b89ea","modified":1472910724900},{"_id":"themes/spfk/source/js/plugins.js","hash":"63e93eee75d6a83717af73dcc9829983123e01c1","modified":1472910724906},{"_id":"themes/spfk/source/img/head.jpg","hash":"b8a4b39f17b687aa7624d2ad7084b34876afe0e6","modified":1465807650504},{"_id":"themes/spfk/source/js/TweenMax.min.js","hash":"2207f42520d5c548702511180e500c3e077605f8","modified":1472910724817},{"_id":"themes/spfk/source/js/embed.js","hash":"0c4047c10bffdc5289f4e61700cc7dfbb56ccb0d","modified":1472910724849},{"_id":"themes/spfk/.git/objects/pack/pack-fbb35c352fa9f1da878bd2c44fa11f627d329b67.idx","hash":"2e42b8afab3b92a2690fafa98f7154b8986c5bb3","modified":1472910723787},{"_id":"themes/spfk/.git/refs/heads/master","hash":"aa9ce0b6037ff8efbb9c8d96114de594d928f59e","modified":1472910723987},{"_id":"themes/spfk/layout/_partial/analytics/baidu-analytics.ejs","hash":"e72a08ad3f7b43e7e9f09b005523cdc2f38356ac","modified":1472910724069},{"_id":"themes/spfk/layout/_partial/analytics/google-analytics.ejs","hash":"1ccc627d7697e68fddc367c73ac09920457e5b35","modified":1472910724075},{"_id":"themes/spfk/layout/_partial/comments/disqus.ejs","hash":"2e5cad68bc59190b4158f4ab1879a222ca49a0d2","modified":1472910724128},{"_id":"themes/spfk/layout/_partial/comments/duoshuo.ejs","hash":"23d58903983a3e40099f75f3d7a5462a95dc4636","modified":1472910724133},{"_id":"themes/spfk/layout/_partial/comments/youyan.ejs","hash":"142e1bb357d738663655ddab25f75e85e20345e4","modified":1472910724137},{"_id":"themes/spfk/layout/_partial/post/TipTitle.ejs","hash":"a1b64506cd6aba3cd8ab48cf3ee0d6477123d6b1","modified":1472910724215},{"_id":"themes/spfk/layout/_partial/post/category.ejs","hash":"08c8d98bc6a73d3f72a3b0b30521ff28e1b657a7","modified":1472910724220},{"_id":"themes/spfk/layout/_partial/post/date.ejs","hash":"a9fc6bac9e1b90c1c17c0d0ffd97f9b108072fbe","modified":1472910724223},{"_id":"themes/spfk/layout/_partial/post/loading.ejs","hash":"ba96f9dd60069b3ac2a332c45b1df82c0bf68f21","modified":1472910724232},{"_id":"themes/spfk/layout/_partial/post/nav.ejs","hash":"2605463dd8738b75f7c9c97929248e72792183f0","modified":1472910724242},{"_id":"themes/spfk/layout/_partial/post/swiftype.ejs","hash":"90f03e7f0ca811f3caeeaaeb2aaf5283e3ab4bb5","modified":1472910724247},{"_id":"themes/spfk/layout/_partial/post/tag.ejs","hash":"7d2693a1162bf26e4b1ae9b789e0b2a2637ddbd5","modified":1472910724253},{"_id":"themes/spfk/layout/_partial/post/title.ejs","hash":"d4a460a35e2112d0c7414fd5e19b3a16093f1caf","modified":1472910724256},{"_id":"themes/spfk/layout/_partial/share/baidu-share.ejs","hash":"136d1ffb6176e220e034a601df9c86f005fd9b4f","modified":1472910724271},{"_id":"themes/spfk/layout/_partial/share/share.ejs","hash":"bfac451ed8d632dbba84673691cc5ea3315c1469","modified":1472910724280},{"_id":"themes/spfk/layout/_partial/share/showshare.ejs","hash":"d38ea660d51c8c58aa8ad20f225949863152326a","modified":1472910724287},{"_id":"themes/spfk/source/background/bg-1.jpg","hash":"f0617756387d74f99afe0087c7b93a32f3c7096b","modified":1472910724338},{"_id":"themes/spfk/source/background/bg-109.jpg","hash":"6171c1e921c8cc9bdcd7276cf7f0bee5295f4672","modified":1472910724350},{"_id":"themes/spfk/source/background/bg-11.jpg","hash":"d69a0447e91f62977b144737f08620d77037c76a","modified":1472910724355},{"_id":"themes/spfk/source/background/bg-17.jpg","hash":"6ab5e470059e8ccb0c8bc6786abfb5db7e9a1826","modified":1472910724395},{"_id":"themes/spfk/source/background/bg-20.jpg","hash":"9d428ac435198b2a0107102a2e9ae71e53afe364","modified":1472910724419},{"_id":"themes/spfk/source/background/bg-3.jpg","hash":"f1347eddd07bdae93ab6bebad8627eddc5baeb44","modified":1472910724448},{"_id":"themes/spfk/source/background/bg.jpg","hash":"f0617756387d74f99afe0087c7b93a32f3c7096b","modified":1472910724488},{"_id":"themes/spfk/source/css/_partial/archive.styl","hash":"dc3c5531589dc2858e20d01a0db5d116d6b7f507","modified":1472910724496},{"_id":"themes/spfk/source/css/_partial/article.styl","hash":"90667bc0a860c9932c316447dee99c335c355c16","modified":1472910724500},{"_id":"themes/spfk/source/css/_partial/baidushare.styl","hash":"4df95b4bb2d092fb4edacaace6da75b68b76ffc9","modified":1472910724504},{"_id":"themes/spfk/source/css/_partial/footer.styl","hash":"a38dd264db83942da95713b78311e4cca0d99325","modified":1472910724517},{"_id":"themes/spfk/source/css/_partial/header.styl","hash":"67e59feb18eee6026717cb440d86ab9551782628","modified":1472910724520},{"_id":"themes/spfk/source/css/_partial/highlight.styl","hash":"e512fa36380e01c533f8e32250452b3a8f6d0fbf","modified":1472910724524},{"_id":"themes/spfk/source/css/_partial/instagram.styl","hash":"a093443add2f529396d6b6bdef1675bc3acf3958","modified":1472910724528},{"_id":"themes/spfk/source/css/_partial/main.styl","hash":"d80d2acea8c84d330272d5f58a334eefb110c351","modified":1472910724531},{"_id":"themes/spfk/source/css/_partial/mains.styl","hash":"ff793a58c239a46474dc369b40ab2a71f547338e","modified":1472910724534},{"_id":"themes/spfk/source/css/_partial/mobile-slider.styl","hash":"211a4286f60751c372090fa96f384521e2ce352c","modified":1472910724537},{"_id":"themes/spfk/source/css/_partial/mobile.styl","hash":"05bec94ed9f9fafa284926a8711aa52de7c56279","modified":1472910724541},{"_id":"themes/spfk/source/css/_partial/page.styl","hash":"fd30cf933e39ee348e69cc8458455cc4f622b7e9","modified":1472910724544},{"_id":"themes/spfk/source/css/_partial/plugins.styl","hash":"98b6db59fbedee6f2a35b76624cce7b5f8ffce94","modified":1472910724546},{"_id":"themes/spfk/source/css/_partial/scroll.styl","hash":"f32deb9192568a2ea789d77a23a08d07f4e57d59","modified":1472910724552},{"_id":"themes/spfk/source/css/_partial/share.styl","hash":"3cfc59278c21b504f8f633e08767a449e03af8d0","modified":1472910724555},{"_id":"themes/spfk/source/css/_partial/tagcloud.styl","hash":"ddcfef2526e6d98f84ae88a87c1ec911649ef791","modified":1472910724558},{"_id":"themes/spfk/source/css/_partial/wheelmenu.styl","hash":"9e57421eab562ea13d0ed2b2e1415eee79fa23d0","modified":1472910724562},{"_id":"themes/spfk/source/css/_util/grid.styl","hash":"1aa883ab432d9e4139c89dcbd40ae2bd1528d029","modified":1472910724565},{"_id":"themes/spfk/source/css/_util/mixin.styl","hash":"429bad87fc156eacf226c5e35b0eafc277f2504b","modified":1472910724568},{"_id":"themes/spfk/source/css/pace/pace-theme-flash.css","hash":"65ce5d4aac09e570914a075a4fd17941c9a51c47","modified":1472910724578},{"_id":"themes/spfk/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1472910724593},{"_id":"themes/spfk/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1472910724596},{"_id":"themes/spfk/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"4c9c395d705d22af7da06870d18f434e2a2eeaf9","modified":1472910724604},{"_id":"themes/spfk/source/fancybox/helpers/jquery.fancybox-media.js","hash":"e14c32cc6823b81b2f758512f13ed8eb9ef2b454","modified":1472910724610},{"_id":"themes/spfk/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1472910724613},{"_id":"themes/spfk/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"83cdfea43632b613771691a11f56f99d85fb6dbd","modified":1472910724622},{"_id":"themes/spfk/source/font-awesome/css/font-awesome.css","hash":"6d39a08bc85169eca450978f895f85d5d3451c0a","modified":1472910724651},{"_id":"themes/spfk/source/font-awesome/css/font-awesome.min.css","hash":"624e4a106f0cf385ff4bd6a65c52cecd84f42ef9","modified":1472910724655},{"_id":"themes/spfk/source/js/404/jquery.parallaxify-0.0.2.min.js","hash":"4bbd22670cd359d05e78c186a98288fb21fbf092","modified":1472910724784},{"_id":"themes/spfk/source/background/bg-15.jpg","hash":"ce5760578eb814fe951c56200e81c6f47b6468d4","modified":1472910724384},{"_id":"themes/spfk/source/background/bg-23.jpg","hash":"050937d649be2c02ef8a66a0ffe7d320b236d1b0","modified":1472910724436},{"_id":"themes/spfk/source/background/bg-7.jpg","hash":"acbe0946a47ba16b79f062dbee14c4c9ff9a48da","modified":1472910724471},{"_id":"themes/spfk/source/font-awesome/fonts/FontAwesome.otf","hash":"42c179eef588854b5ec151bcf6a3f58aa8b79b11","modified":1472910724662},{"_id":"themes/spfk/source/font-awesome/fonts/fontawesome-webfont.eot","hash":"986eed8dca049714e43eeebcb3932741a4bec76d","modified":1472910724677},{"_id":"themes/spfk/source/font-awesome/fonts/fontawesome-webfont.woff2","hash":"638c652d623280a58144f93e7b552c66d1667a11","modified":1472910724704},{"_id":"themes/spfk/source/font-awesome/fonts/fontawesome-webfont.woff","hash":"4a313eb93b959cc4154c684b915b0a31ddb68d84","modified":1472910724699},{"_id":"themes/spfk/source/js/404/jquery-2.0.3.min.js","hash":"bbc61d6a6dd66b913c6f237f29475a889fbe3015","modified":1472910724760},{"_id":"themes/spfk/.git/logs/refs/heads/master","hash":"5dab39ec64e86ef43cebb79bd1fb3b84a959b094","modified":1472910723991},{"_id":"themes/spfk/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1472910723979},{"_id":"themes/spfk/source/background/bg-14.jpg","hash":"2fd6ede2bc9de2d26d910ea4e45d28b2350881eb","modified":1472910724378},{"_id":"themes/spfk/source/background/bg-9.jpg","hash":"df731da0fe0de9a05d99d017e747252c990f972d","modified":1472910724483},{"_id":"themes/spfk/source/css/_partial/customise/blockquote.styl","hash":"edfed5def2ad4f7fdad0eb50b26a51c3b010c2b1","modified":1472910724507},{"_id":"themes/spfk/source/css/_partial/customise/code-block.styl","hash":"4db1a992a06fd92b779f0afc9bb8bb3667bdb101","modified":1472910724511},{"_id":"themes/spfk/source/css/_partial/customise/inline-code.styl","hash":"aedbcd697c9fbaeeb93c068be3db771c41feba0d","modified":1472910724515},{"_id":"themes/spfk/source/css/_partial/post/youyan.styl","hash":"9076b0d3c231e16b8a1d7f834e62a98d843edd32","modified":1472910724549},{"_id":"themes/spfk/source/font-awesome/fonts/fontawesome-webfont.ttf","hash":"6484f1af6b485d5096b71b344e67f4164c33dd1f","modified":1472910724695},{"_id":"themes/spfk/source/background/bg-19.jpg","hash":"d77504412d28432643fc61ed9fd9f7c57096bdd9","modified":1472910724407},{"_id":"themes/spfk/source/background/bg-21.jpg","hash":"7c4c6cd5d75115093fa29bba7372fa198f04b0f1","modified":1472910724425},{"_id":"themes/spfk/source/background/bg-22.jpg","hash":"7a055391fa4188d9c22fdc1d34a10b26e2f0826d","modified":1472910724430},{"_id":"themes/spfk/source/background/bg-24.jpg","hash":"796fa5262d7714e8ce9496a2d03864429cfc5b45","modified":1472910724443},{"_id":"themes/spfk/source/background/bg-4.jpg","hash":"da47f889e02241c8b095f852fb7efd89c114599d","modified":1472910724453},{"_id":"themes/spfk/source/background/bg-6.jpg","hash":"1a4f4c8875b2c56e7992000979a7fca7856eec35","modified":1472910724466},{"_id":"themes/spfk/source/background/bg-8.jpg","hash":"dbecc189e28d00fa23e397eb512e039c2ff03c87","modified":1472910724477},{"_id":"themes/spfk/.git/logs/refs/remotes/origin/HEAD","hash":"5dab39ec64e86ef43cebb79bd1fb3b84a959b094","modified":1472910723977},{"_id":"themes/spfk/source/background/bg-10.jpg","hash":"dfb23c1c3cf8a3dcb8dc0ea10cf06501c151a2a2","modified":1472910724345},{"_id":"themes/spfk/source/background/bg-12.jpg","hash":"2e0815591309863d8130881681cde32ec4bfebf1","modified":1472910724367},{"_id":"themes/spfk/source/background/bg-18.jpg","hash":"4d61dc41a781a9c1d37c9e5e413ac0d8a9538f6a","modified":1472910724400},{"_id":"themes/spfk/source/img/bg.jpg","hash":"1bcba3c6348e2190a42bff762800bf846cf9239c","modified":1472910724709},{"_id":"themes/spfk/source/background/bg-111.jpg","hash":"e1631b47fede8da6c03582ceed648668547c4f09","modified":1472910724360},{"_id":"themes/spfk/source/background/bg-13.jpg","hash":"d7237c6014e28c90f53287f48f718d0759af104b","modified":1472910724373},{"_id":"themes/spfk/source/background/bg-16.jpg","hash":"d1a34d0c4b69262169b543922e4aeb4dae997ad8","modified":1472910724389},{"_id":"themes/spfk/source/font-awesome/fonts/fontawesome-webfont.svg","hash":"550ef5c1253c8376f2ead32b654eb58d3c106ca3","modified":1472910724690},{"_id":"themes/spfk/source/background/bg-2.jpg","hash":"40a6db13e9c461f80e2c4efee7fb63bbd594e751","modified":1472910724414},{"_id":"themes/spfk/source/background/bg-5.jpg","hash":"2d5da2a209732cce0abf2ca234c0bef0516b65ff","modified":1472910724460},{"_id":"themes/spfk/.git/objects/pack/pack-fbb35c352fa9f1da878bd2c44fa11f627d329b67.pack","hash":"280dd7556922c935307af99bb02ff9cfe3bb77ec","modified":1472910723845},{"_id":"public/apple-touch-icon.png","hash":"c36a373c7830d61d1ce092bd5a88d0e9b54212fd","modified":1472910844193},{"_id":"public/img/coderwall.png","hash":"fa84676c4d654e040e51fd34bfcd9f9348cd5331","modified":1472910844193},{"_id":"public/img/delicious.png","hash":"9553a5f5189e4a953e04a58a49dbfa74b86b73dd","modified":1472910844193},{"_id":"public/img/douban.png","hash":"e2ade003ffadd5826ee66ec23901c2d6e8607e4e","modified":1472910844193},{"_id":"public/img/facebook.png","hash":"d19ad7a0903daf26817afd8753cd97e0cc714f54","modified":1472910844193},{"_id":"public/img/favicon.png","hash":"5b4e9c94ff3396db5b074b69c1aa5bb909aba825","modified":1472910844193},{"_id":"public/img/github.png","hash":"b84d03b32fa388dcbf149296ebd16dce6223d48d","modified":1472910844193},{"_id":"public/img/img-err.png","hash":"23a63ea26eb3c1d5e677d9883cf36cc1a1a1228b","modified":1472910844193},{"_id":"public/img/google.png","hash":"61a21fec7346fa3400b747ac9a201cf3d5bc013d","modified":1472910844193},{"_id":"public/img/img-loading.png","hash":"a9cd5cd11866824f31e3d1c5e23badfeb3f73031","modified":1472910844193},{"_id":"public/img/linkedin.png","hash":"e203138fb53c257cb214e97f4e30091b9c568d2c","modified":1472910844193},{"_id":"public/img/mail.png","hash":"fca8199cc77fdbd700a45bf56d091c82f4a67fe7","modified":1472910844194},{"_id":"public/img/pinboard.png","hash":"0891fbb6d092fa012bf936019923383d84c6aeb0","modified":1472910844194},{"_id":"public/img/pinterest.png","hash":"9c72917f8779c083157c6ce7a5d62ed4874f0630","modified":1472910844194},{"_id":"public/img/qq.png","hash":"fd741764c5528fe371f053beac99839a97900eef","modified":1472910844194},{"_id":"public/img/rss.png","hash":"430fd47340e75214c081abd05cd7410cf7c71b86","modified":1472910844194},{"_id":"public/img/stackoverflow.png","hash":"da5dfe9043055c95e479d49c78cd3b020de608f2","modified":1472910844194},{"_id":"public/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1472910844195},{"_id":"public/img/twitter.png","hash":"14dbb8e62d056525253bc0de13acd1723da7a934","modified":1472910844195},{"_id":"public/img/wechat.png","hash":"7ca41b6e32ca4dac419225261ab4fee5a88f73a9","modified":1472910844195},{"_id":"public/img/weibo.png","hash":"280dae3fd38086158b4a1b57edb94c06b1a5014b","modified":1472910844195},{"_id":"public/img/zhihu.png","hash":"a6d6ef65e9ac82e613a311810391ebb90d9b1c1d","modified":1472910844195},{"_id":"public/img/head.jpg","hash":"b8a4b39f17b687aa7624d2ad7084b34876afe0e6","modified":1472913511164},{"_id":"public/font-awesome/fonts/FontAwesome.otf","hash":"42c179eef588854b5ec151bcf6a3f58aa8b79b11","modified":1472910845302},{"_id":"public/font-awesome/fonts/fontawesome-webfont.eot","hash":"986eed8dca049714e43eeebcb3932741a4bec76d","modified":1472910845303},{"_id":"public/font-awesome/fonts/fontawesome-webfont.woff2","hash":"638c652d623280a58144f93e7b552c66d1667a11","modified":1472910845303},{"_id":"public/font-awesome/fonts/fontawesome-webfont.woff","hash":"4a313eb93b959cc4154c684b915b0a31ddb68d84","modified":1472910845304},{"_id":"public/css/loading-style.css","hash":"1f67362d809e85edc9f122db7bc3711af1ed1d8b","modified":1472910845323},{"_id":"public/css/showshare.css","hash":"3efc4afd0d136fb5dec993e9cd9ce85b9d1cf589","modified":1472910845323},{"_id":"public/js/TweenMax.js","hash":"0ba64564a4fde4085fa3971dd53b7d64a41751e1","modified":1472910845323},{"_id":"public/js/clipboard.min.js","hash":"c13b4bb8fee46447284590d2afc0efca0ea3cb7b","modified":1472910845323},{"_id":"public/js/instagram.js","hash":"f19adbcc0dac33536bc6660598059048ec901882","modified":1472910845323},{"_id":"public/js/main.js","hash":"153b4796d6c22f3bfaa28a4f8a361d4685286c6f","modified":1472910845323},{"_id":"public/js/jquery.lazyload.js","hash":"c11a2e7b330d16d06feabd0a8477099adf9d6799","modified":1472910845324},{"_id":"public/js/mobile.js","hash":"d3847e5bcaf39108931724ecb02770c62b10889f","modified":1472910845324},{"_id":"public/js/pc.js","hash":"ab375af6e3bcd054b1e87e1a8dcd3d7d25c2db40","modified":1472910845324},{"_id":"public/js/plugins.js","hash":"c1cf96b2d852b5803228a34d99014b005623bc06","modified":1472910845324},{"_id":"public/css/pace/pace-theme-flash.css","hash":"508bce8b59a1fbc1f1443a7c4ab3b026e5517dab","modified":1472910845324},{"_id":"public/js/404/jquery.parallaxify-0.0.2.min.js","hash":"b97e2dfcb210b76f7bdd6e1800b26128bf4fad99","modified":1472910845324},{"_id":"public/js/pace.js","hash":"b49c10cd65d9488f7338e3c778e55ac6628650f3","modified":1472910845324},{"_id":"public/js/TweenMax.min.js","hash":"eaa4e4a08400da3f22dedda706ba56cdce5b0b7a","modified":1472910845324},{"_id":"public/js/embed.js","hash":"8d2d4a812ab639bc02fdd8749d3a39f6b9406c54","modified":1472910845324},{"_id":"public/font-awesome/css/font-awesome.css","hash":"b488600451227b445414796e9b8550e7c1bd6d29","modified":1472910845325},{"_id":"public/font-awesome/css/font-awesome.min.css","hash":"12d6861075de8e293265ff6ff03b1f3adcb44c76","modified":1472910845325},{"_id":"public/js/404/jquery-2.0.3.min.js","hash":"fbf9c77d0c4e3c34a485980c1e5316b6212160c8","modified":1472910845325},{"_id":"public/background/bg-1.jpg","hash":"f0617756387d74f99afe0087c7b93a32f3c7096b","modified":1472910845325},{"_id":"public/background/bg-109.jpg","hash":"6171c1e921c8cc9bdcd7276cf7f0bee5295f4672","modified":1472910845325},{"_id":"public/background/bg-11.jpg","hash":"d69a0447e91f62977b144737f08620d77037c76a","modified":1472910845325},{"_id":"public/background/bg-17.jpg","hash":"6ab5e470059e8ccb0c8bc6786abfb5db7e9a1826","modified":1472910845325},{"_id":"public/background/bg-20.jpg","hash":"9d428ac435198b2a0107102a2e9ae71e53afe364","modified":1472910845325},{"_id":"public/background/bg-3.jpg","hash":"f1347eddd07bdae93ab6bebad8627eddc5baeb44","modified":1472910845325},{"_id":"public/background/bg.jpg","hash":"f0617756387d74f99afe0087c7b93a32f3c7096b","modified":1472910845326},{"_id":"public/font-awesome/fonts/fontawesome-webfont.ttf","hash":"6484f1af6b485d5096b71b344e67f4164c33dd1f","modified":1472910845326},{"_id":"public/background/bg-15.jpg","hash":"ce5760578eb814fe951c56200e81c6f47b6468d4","modified":1472910845364},{"_id":"public/background/bg-23.jpg","hash":"050937d649be2c02ef8a66a0ffe7d320b236d1b0","modified":1472910845364},{"_id":"public/background/bg-7.jpg","hash":"acbe0946a47ba16b79f062dbee14c4c9ff9a48da","modified":1472910845364},{"_id":"public/background/bg-14.jpg","hash":"2fd6ede2bc9de2d26d910ea4e45d28b2350881eb","modified":1472910845390},{"_id":"public/background/bg-9.jpg","hash":"df731da0fe0de9a05d99d017e747252c990f972d","modified":1472910845390},{"_id":"public/background/bg-19.jpg","hash":"d77504412d28432643fc61ed9fd9f7c57096bdd9","modified":1472910845396},{"_id":"public/background/bg-21.jpg","hash":"7c4c6cd5d75115093fa29bba7372fa198f04b0f1","modified":1472910845396},{"_id":"public/background/bg-22.jpg","hash":"7a055391fa4188d9c22fdc1d34a10b26e2f0826d","modified":1472910845397},{"_id":"public/background/bg-24.jpg","hash":"796fa5262d7714e8ce9496a2d03864429cfc5b45","modified":1472910845397},{"_id":"public/background/bg-4.jpg","hash":"da47f889e02241c8b095f852fb7efd89c114599d","modified":1472910845397},{"_id":"public/background/bg-6.jpg","hash":"1a4f4c8875b2c56e7992000979a7fca7856eec35","modified":1472910845397},{"_id":"public/background/bg-8.jpg","hash":"dbecc189e28d00fa23e397eb512e039c2ff03c87","modified":1472910845398},{"_id":"public/font-awesome/fonts/fontawesome-webfont.svg","hash":"550ef5c1253c8376f2ead32b654eb58d3c106ca3","modified":1472910845398},{"_id":"public/background/bg-10.jpg","hash":"dfb23c1c3cf8a3dcb8dc0ea10cf06501c151a2a2","modified":1472910845450},{"_id":"public/background/bg-12.jpg","hash":"2e0815591309863d8130881681cde32ec4bfebf1","modified":1472910845450},{"_id":"public/img/bg.jpg","hash":"1bcba3c6348e2190a42bff762800bf846cf9239c","modified":1472910845450},{"_id":"public/background/bg-18.jpg","hash":"4d61dc41a781a9c1d37c9e5e413ac0d8a9538f6a","modified":1472910845450},{"_id":"public/background/bg-111.jpg","hash":"e1631b47fede8da6c03582ceed648668547c4f09","modified":1472910845479},{"_id":"public/background/bg-13.jpg","hash":"d7237c6014e28c90f53287f48f718d0759af104b","modified":1472910845479},{"_id":"public/background/bg-16.jpg","hash":"d1a34d0c4b69262169b543922e4aeb4dae997ad8","modified":1472910845479},{"_id":"public/background/bg-2.jpg","hash":"40a6db13e9c461f80e2c4efee7fb63bbd594e751","modified":1472910845506},{"_id":"public/background/bg-5.jpg","hash":"2d5da2a209732cce0abf2ca234c0bef0516b65ff","modified":1472910845510},{"_id":"source/_posts/Resource.arsc文件格式.md","hash":"dfe5282ebf553f51e501be944297dff31607309a","modified":1465898761349},{"_id":"source/_posts/简析Android组件安全.md","hash":"0f1716f733a4fc02f5d794f9a762e31956d417da","modified":1465898685716},{"_id":"source/_posts/简析DroidPlugin之Hook.md","hash":"f2b07d483bacb28963d3d94550afa4f162524e72","modified":1465898690379},{"_id":"public/2016/09/03/简析DroidPlugin之Hook/index.html","hash":"36305b7cb9c50d633c6d562965f1a8d6afb99672","modified":1472995556026},{"_id":"public/2016/09/03/简析Android组件安全/index.html","hash":"79ac918c94b2096d46180d553316b1fc43075619","modified":1472995556026},{"_id":"public/2016/09/03/Resource.arsc文件格式/index.html","hash":"715b290c05419985aa3266ff7fc7ac960c54ad20","modified":1472995556026},{"_id":"public/categories/Mobile/index.html","hash":"f64a9bda532f9c1677e847cac2751596b3f835be","modified":1472995556025},{"_id":"public/tags/android/index.html","hash":"9146af2d12841a4eb427324d156f7d056063a40c","modified":1472995556025},{"_id":"source/_posts/Hexo搭建优化部署.md","hash":"b2ad5f2025906d4f597049e6fd813c520034db49","modified":1472990127644},{"_id":"public/2016/09/03/Hexo搭建优化部署/index.html","hash":"f360775036b6fb72fb6345e55bbf6bea816e1c8f","modified":1472995556026},{"_id":"public/categories/Others/index.html","hash":"58133568e50f72794b0e8fc780f932874e326d3c","modified":1472995556025},{"_id":"public/tags/other/index.html","hash":"26a4bf965b7d1cf14b80fee9d29cd5026c15d392","modified":1472995556025},{"_id":"source/google1e7021b63d98f365.html","hash":"30026aa5dd6a80abb69c5952d913ae486f531ca9","modified":1472920274392},{"_id":"public/google1e7021b63d98f365.html","hash":"642129d38e1f96e6869fc8f4021ad89d0d96e25f","modified":1472995556025},{"_id":"public/sitemap.xml","hash":"1aa8cbfdbd3010b9e2e6108b6f31c8ef77de1b1b","modified":1472995016375},{"_id":"source/baidu_verify_XqFA5fU1QI.html","hash":"7109bc6902d2b4d8de4b1f2e844eaaa68592bcc3","modified":1472994923056},{"_id":"public/baidu_verify_XqFA5fU1QI.html","hash":"e031ccbb4d657bd23fd9c9c85c6853d34637fc9f","modified":1472995556025}],"Category":[{"name":"Mobile","_id":"cisn9io3t000264viviekyef4"},{"name":"Others","_id":"cisneb6qn00004kvifx0dkp5m"}],"Data":[],"Page":[{"_content":"google-site-verification: google1e7021b63d98f365.html","source":"google1e7021b63d98f365.html","raw":"google-site-verification: google1e7021b63d98f365.html","date":"2016-09-03T16:31:14.392Z","updated":"2016-09-03T16:31:14.392Z","path":"google1e7021b63d98f365.html","title":"","comments":1,"layout":"page","_id":"cisner6vt0000ikvimv189dpj","content":"google-site-verification: google1e7021b63d98f365.html","excerpt":"","more":"google-site-verification: google1e7021b63d98f365.html"},{"_content":"XqFA5fU1QI","source":"baidu_verify_XqFA5fU1QI.html","raw":"XqFA5fU1QI","date":"2016-09-04T13:15:23.056Z","updated":"2016-09-04T13:15:23.056Z","path":"baidu_verify_XqFA5fU1QI.html","title":"","comments":1,"layout":"page","_id":"cison787a0000bkvinvwy99u1","content":"XqFA5fU1QI","excerpt":"","more":"XqFA5fU1QI"}],"Post":[{"title":"简析Android组件安全","date":"2016-09-03T13:58:46.740Z","_content":"\n# 前言 #\n前段时间在学习github上DroidPlgin插件的时候接触到不少专业术语，诸如预先占坑、Activity劫持和Hook等，一开始看还真是感觉雾里看花。在查阅资料的过程中发现了国人出版的《Android软件安全与逆向分析》，在理解Activity劫持的过程中引申了Android四大组件的安全。知识点不难却感觉蛮有趣，故分享之。<!-- more -->\n\n## Activity ##\nAndroid组件是用户唯一能够看见的组件，作为软件所有功能的显示载体，其安全问题是最应该受到关注的\n### 权限攻击 ###\n正如Android开发文档中所说的，Android系统组件在制定Intent过滤器（intent-filter）后，默认是可以被外部程序访问的。这就很意味着很容易被其他程序进行串谋攻击，关于串谋攻击，在分享最后再做一个简单的解析。现在问题是，如何防止Activity被外部使用呢？\n\nAndroid所有组件声明时可以通过指定android:exported属性值为false，来设置组件不能被外部程序调用。这里的外部程序是指签名不同、用户ID不同的程序，签名相同且用户ID相同的程序在执行时共享同一个进程空间，彼此之间是没有组件访问限制的。如果希望Activity能够被特定的程序访问，就不能用android:exported属性了，可以使用android:permission属性来指定一个权限字符串，声明例子如下：\n\n\n    <Activity android:name=\".MyActivity\"\n           android:permission=\"com.test.permission.MyActivity\">\n           <intent-filter>\n               <action android:name=\"com.test.action\"></action>\n           </intent-filter>\n    </Activity>\n\n这样声明的Activity在被调用时，Android系统就会检查调用者是否具有com.test.permission.MyActivity权限，如果不具备就会触发一个SecurityException安全异常。要想启动该Activity必须在AndroidManifest.xml文件中加入以下声明：\n    \n    <uses-permission android:name=\"com.test.permission.MyActivity\">\n\n### Activity劫持 ###\n当用户安装了带有Activity劫持功能的恶意程序后，恶意程序会遍历系统中运行的程序，当检测到需要劫持的Activity（通常是网银或其他网络程序的等登陆界面）在前台运行时，恶意程序就会启动一个带FLAG\\_ACTIVITY\\_NEW\\_TASK标志的钓鱼式Activity覆盖正常的Activity，从而欺骗输入用户名或密码信息，当用户输入完信息后，程序就会将信息发送到指定的网址或邮箱，然后切换到正常的Activity中。这就是Activity劫持原理。从受影响的角度看，Activity属于用户层安全，程序员无法控制。\n\n下面做一个简单的劫持例子。实例可以对多个进程进行劫持，它在启动时启动了一个Hack服务，Hack服务创建了一个定时器，定时器每隔2秒就检测一次系统正在运行的进程，判断前台运行的进程是否匹配劫持的进程列表中，如果匹配就进行劫持：\n\n    private TimeTask mTask = new TimeTask(){\n    \n        @Override\n        public void run(){\n         \tActivityManager am = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE);\n            List<RunningAppProcessInfo> infos = am.getRunningAppProcesses();\n            //枚举进程\n            for(RunningAppProcessInfo psinfo:infos){\n                if(psinfo.importance == RunningAppProcessInfo.IMPORTANCE_FOREGROUND){ //前台进程\n                 \tif(hackList.contains(psinfo.processName)){\n \t                    Intent intent = new Intent(getBaseContent(),HackerActivity.class);\n                        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)；\n                        intent.putExtra(\"processname\",psinfo.processName);\n                        getApplication().startActivity(intent);//启动伪造的Activity\n                    }\n                 }\n            }\n        }\n\n    }\n\nActivity劫持不需要在AndroidManifest.xml中声明任何权限就可以实现，一般的防病毒软件也无法检测，手机用户更是防不胜防。不过有一种方法可以判断当前Activity是否被劫持：长按Home键不放，系统显示最近运行过的程序列表。在本例中，HackerActvity显示在最前面，很显然这个程序就有劫持Actvity的嫌疑。\n\nUnfortunately，这种检测Activity劫持的方法并不是任何时候都有效的，假如在声明Activity时，设置android:excludeFromRecents的值为true，程序在运行时就不会显示在最近运行过的程序列表中，上面的检测方法也就只能hehe了。\n\n## Broadcast Receiver ##\nBroadcast Receiver用于处理发送和接收广播，这里分为发送安全和接收安全。接收广播涉及串谋攻击，这里先不作介绍，下面主要介绍发送广播安全。先来一段熟悉的代码:\n\n\tIntent intent = new Intent();\n\tintent.setAction(\"com.test.broadcast\");\n\tintent.putExtra(\"data\",Math.random());\n\tsendBroadcast(intent);\n\n这段代码发送了一个Action为com.test.broadcast的广播。我们都知道，Android系统提供了两种广播发送方法，分别是sendBroadcast()和sendOrderedBroadcast()。sendBroadcast()用于发送无序广播，该广播能够被所有广播接受者接收，并且不能被abortBroadcast()终止，sendOrderedBroadcast()用于发送有序广播，该广播被优先级高的广播接收者有限接收，然后依次向下传递，优先级高的广播接收者可以篡改广播，或者调用abortBroadcast()终止广播。广播优先级响应的计算方法是：动态注册的广播接收者比静态广播接收者的优先级高，静态广播接收者的优先级根据设置的android:priority属性的数值来决定，数值越大，优先级越高。\n\n从上面分析可以得知，假如Hacker动态注册一个Action为com.test.broadcast的广播接收者，并且拥有最高的优先级，上述程序假如使用sendBroadcast()发送广播，Hacker的确无法通过abortBroadcast()终止，但可以优先响应该实例发送的广播；但是假如上述程序使用sendOrderedBroadcast()发送，很有可能BroadcastReceiver实例就永远无法收到自己发送的广播。\n\n当然，上述问题也是可以避免的。在发送广播时通过Intent指定具体要发送到的Android组件或类，广播就永远只能被本实例指定的类所接收，如：\n\n\tintent,setClass(MainActivity.this,test.class);\n\n## Service ##\nService组件是Android系统中的后台进程，主要的功能是在后台进行一些耗时的操作。与其他的Android组件一样，当声明Service时指定了Intent过滤器，该Service默认就可以被外部访问。可以访问的方法有：\n\n>startService():启动服务，可以被用来实现串谋攻击。\n\n>bindService():绑定服务，可以被用来实现串谋攻击。\n\n>stopService():停止服务，对程序功能进行恶意破坏。\n\n对于恶意的stopService，它破解程序的执行环境，直接影响到程序的正常运行。要想杜绝Service组件被人恶意的启动或者停止，就需要使用Android系统的权限机制来对调用者进行控制。如果Service组件不想被程序外的其他组件访问，可以直接设置它的android:exported属性为false，如果是同一作者的多个程序共享使用该服务，则可以使用自定义的权限，这在Activity的权限攻击已经介绍过，这里就不铺开来说了。\n\n## Content Provider ##\nContent Provider 用于程序之间数据交换。Android系统中，每个应用的数据库、文件、资源等信息都是私有的，其他程序无法访问，如果想要访问这些数据，就必须提供一种程序之间数据的访问机制，这就是Content Provider的由来。一个典型的Content Provider声明如下：\n\n\t<provider\n\t\tandroid:name=\"com.test.providerhehe\"\n\t\tandroid:authorities=\"cpm.test.heheprovider\"\n\t\tandroid:readPermission=\"droider.permission.FILE_READ\"\n\t\tandroid:writePermission=\"droider.permission.FILE_WRITE\"\n\t>\n\nContent Provider提供了insert()、delete()、update()、query()等操作，其中执行query()查询操作时会执行读权限android:readPermission检查，其他的操作会执行写权限android:writePermission检查，权限检查失败时会抛出SecurityException异常。对于很多开发人员来说，在声明Content Provider 时几乎从来不使用这两个权限，这导致了串谋攻击发生的可能。部分网络软件开发商使用Content Provider来实现软件登陆、用户密码修改等敏感度极高的操作，然而声明的Content Provider却没有权限控制，这使得一些恶意软件无需任何权限就可以获取用户的敏感信息。\n\n## 串谋权限攻击 ##\nAndroid程序中资源的访问包括使用Framework提供的功能与访问其他程序的组件，前者是通过系统提供的权限机制进行控制的，后者是通过自定义权限控制的。正常情况下，没有声明特定的访问权限，就无法访问这些资源。但通过其他程序中可访问的Android组件，就有可能突破这种访问控制，从而提升程序本身的权限，这种权限提升的攻击方式在这称为串谋权限攻击。\n\n![串谋权限攻击示意图](https://cloud.githubusercontent.com/assets/10484766/11139875/7c3829ba-8a0f-11e5-838c-83064d88a724.png)\n\n这里可以模拟一个场景，有一个下载管理程序实例DownloadManager，有一个TextView输入想要下载的文件URL，点击下载按钮即开始下载，下载下来的文件默认保存在SD卡上。当然，该实例拥有下载文件和保存SD卡的权利：\n\n\t<uses-permission androidLname=\"android.permission.WRITE_EXTERNAL_STORAGE/\">\n\t<uses-permission android:name=\"android.permission.INTERNET\">\n\n下载文件的功能是通过接收下载请求广播，然后在下载广播接收者中完成的，对应的广播接收者在AndroidManifest.xml中声明：\n\n\t<receiver android:name=\".DownloadReceiver\">\n\t\t<intent-filter>\n\t\t\t<action android:name=\"com.test.download\"></action>\n\t\t</intent-filter>\n\t</receiver>\n\nDownloadReceiver响应Action为\"com.test.download\"的广播，然后访问Intent指定的URL地址去下载文件，相应的广播响应代码如下：\n\n\tpublic void onReceive(Context context,Intent intent){\n\t\tif(intent.getAction().equals(\"com.test.download\")){\n\t\t\tString url = intent.getExtra().getString(\"url\");\n\t\t\tString filename = intent.getExtra().getString(\"filename\");\n\t\t\tToast.makeText(context,url,Toast.LENGTH_SHORT).show();\n\t\t\ttry{\n\t\t\t\tdownloadFile(url,filename);\n\t\t\t}catch(IOException e){\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\n从上面代码可以清楚地看到，下载的文件时通过url传递过来而保存的文件名则是通过filename传递。接下来就是我们的攻击程序HackerDownloader，它什么权限都没有，只有一段发送文件下载请求的代码：\n\n\tbtn.setOnClickListener(new OnClickListener(){\n\t\t@override\n\t\tpublic void onClick(){\n\t\t\tIntent intent = new Intent();//创建Intent对象\n\t\t\tintent.setAction(\"com.test.download\");\n\t\t\tintent.putExtra(\"url\",\"http://********\");//要下载文件url地址\n\t\t\tString fileName = \"test.txt\";\n\t\t\tintent.putExtra(\"filename\",fileName);\n\t\t\tsendBroadcast(intent);\n\t\t}\n\t});\n\n当HackerDownloader点击下载按钮以后，DownloadReceiver收到广播后就会开始下载相对应的文件并保存到指定目录下。至此，一次完美的串谋攻击就完成了。\n\n","source":"_posts/简析Android组件安全.md","raw":"title: 简析Android组件安全\ndate: 2016/6/14 17：57\n\ncategories:\n- Mobile\ntags:\n- android\n---\n\n# 前言 #\n前段时间在学习github上DroidPlgin插件的时候接触到不少专业术语，诸如预先占坑、Activity劫持和Hook等，一开始看还真是感觉雾里看花。在查阅资料的过程中发现了国人出版的《Android软件安全与逆向分析》，在理解Activity劫持的过程中引申了Android四大组件的安全。知识点不难却感觉蛮有趣，故分享之。<!-- more -->\n\n## Activity ##\nAndroid组件是用户唯一能够看见的组件，作为软件所有功能的显示载体，其安全问题是最应该受到关注的\n### 权限攻击 ###\n正如Android开发文档中所说的，Android系统组件在制定Intent过滤器（intent-filter）后，默认是可以被外部程序访问的。这就很意味着很容易被其他程序进行串谋攻击，关于串谋攻击，在分享最后再做一个简单的解析。现在问题是，如何防止Activity被外部使用呢？\n\nAndroid所有组件声明时可以通过指定android:exported属性值为false，来设置组件不能被外部程序调用。这里的外部程序是指签名不同、用户ID不同的程序，签名相同且用户ID相同的程序在执行时共享同一个进程空间，彼此之间是没有组件访问限制的。如果希望Activity能够被特定的程序访问，就不能用android:exported属性了，可以使用android:permission属性来指定一个权限字符串，声明例子如下：\n\n\n    <Activity android:name=\".MyActivity\"\n           android:permission=\"com.test.permission.MyActivity\">\n           <intent-filter>\n               <action android:name=\"com.test.action\"></action>\n           </intent-filter>\n    </Activity>\n\n这样声明的Activity在被调用时，Android系统就会检查调用者是否具有com.test.permission.MyActivity权限，如果不具备就会触发一个SecurityException安全异常。要想启动该Activity必须在AndroidManifest.xml文件中加入以下声明：\n    \n    <uses-permission android:name=\"com.test.permission.MyActivity\">\n\n### Activity劫持 ###\n当用户安装了带有Activity劫持功能的恶意程序后，恶意程序会遍历系统中运行的程序，当检测到需要劫持的Activity（通常是网银或其他网络程序的等登陆界面）在前台运行时，恶意程序就会启动一个带FLAG\\_ACTIVITY\\_NEW\\_TASK标志的钓鱼式Activity覆盖正常的Activity，从而欺骗输入用户名或密码信息，当用户输入完信息后，程序就会将信息发送到指定的网址或邮箱，然后切换到正常的Activity中。这就是Activity劫持原理。从受影响的角度看，Activity属于用户层安全，程序员无法控制。\n\n下面做一个简单的劫持例子。实例可以对多个进程进行劫持，它在启动时启动了一个Hack服务，Hack服务创建了一个定时器，定时器每隔2秒就检测一次系统正在运行的进程，判断前台运行的进程是否匹配劫持的进程列表中，如果匹配就进行劫持：\n\n    private TimeTask mTask = new TimeTask(){\n    \n        @Override\n        public void run(){\n         \tActivityManager am = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE);\n            List<RunningAppProcessInfo> infos = am.getRunningAppProcesses();\n            //枚举进程\n            for(RunningAppProcessInfo psinfo:infos){\n                if(psinfo.importance == RunningAppProcessInfo.IMPORTANCE_FOREGROUND){ //前台进程\n                 \tif(hackList.contains(psinfo.processName)){\n \t                    Intent intent = new Intent(getBaseContent(),HackerActivity.class);\n                        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)；\n                        intent.putExtra(\"processname\",psinfo.processName);\n                        getApplication().startActivity(intent);//启动伪造的Activity\n                    }\n                 }\n            }\n        }\n\n    }\n\nActivity劫持不需要在AndroidManifest.xml中声明任何权限就可以实现，一般的防病毒软件也无法检测，手机用户更是防不胜防。不过有一种方法可以判断当前Activity是否被劫持：长按Home键不放，系统显示最近运行过的程序列表。在本例中，HackerActvity显示在最前面，很显然这个程序就有劫持Actvity的嫌疑。\n\nUnfortunately，这种检测Activity劫持的方法并不是任何时候都有效的，假如在声明Activity时，设置android:excludeFromRecents的值为true，程序在运行时就不会显示在最近运行过的程序列表中，上面的检测方法也就只能hehe了。\n\n## Broadcast Receiver ##\nBroadcast Receiver用于处理发送和接收广播，这里分为发送安全和接收安全。接收广播涉及串谋攻击，这里先不作介绍，下面主要介绍发送广播安全。先来一段熟悉的代码:\n\n\tIntent intent = new Intent();\n\tintent.setAction(\"com.test.broadcast\");\n\tintent.putExtra(\"data\",Math.random());\n\tsendBroadcast(intent);\n\n这段代码发送了一个Action为com.test.broadcast的广播。我们都知道，Android系统提供了两种广播发送方法，分别是sendBroadcast()和sendOrderedBroadcast()。sendBroadcast()用于发送无序广播，该广播能够被所有广播接受者接收，并且不能被abortBroadcast()终止，sendOrderedBroadcast()用于发送有序广播，该广播被优先级高的广播接收者有限接收，然后依次向下传递，优先级高的广播接收者可以篡改广播，或者调用abortBroadcast()终止广播。广播优先级响应的计算方法是：动态注册的广播接收者比静态广播接收者的优先级高，静态广播接收者的优先级根据设置的android:priority属性的数值来决定，数值越大，优先级越高。\n\n从上面分析可以得知，假如Hacker动态注册一个Action为com.test.broadcast的广播接收者，并且拥有最高的优先级，上述程序假如使用sendBroadcast()发送广播，Hacker的确无法通过abortBroadcast()终止，但可以优先响应该实例发送的广播；但是假如上述程序使用sendOrderedBroadcast()发送，很有可能BroadcastReceiver实例就永远无法收到自己发送的广播。\n\n当然，上述问题也是可以避免的。在发送广播时通过Intent指定具体要发送到的Android组件或类，广播就永远只能被本实例指定的类所接收，如：\n\n\tintent,setClass(MainActivity.this,test.class);\n\n## Service ##\nService组件是Android系统中的后台进程，主要的功能是在后台进行一些耗时的操作。与其他的Android组件一样，当声明Service时指定了Intent过滤器，该Service默认就可以被外部访问。可以访问的方法有：\n\n>startService():启动服务，可以被用来实现串谋攻击。\n\n>bindService():绑定服务，可以被用来实现串谋攻击。\n\n>stopService():停止服务，对程序功能进行恶意破坏。\n\n对于恶意的stopService，它破解程序的执行环境，直接影响到程序的正常运行。要想杜绝Service组件被人恶意的启动或者停止，就需要使用Android系统的权限机制来对调用者进行控制。如果Service组件不想被程序外的其他组件访问，可以直接设置它的android:exported属性为false，如果是同一作者的多个程序共享使用该服务，则可以使用自定义的权限，这在Activity的权限攻击已经介绍过，这里就不铺开来说了。\n\n## Content Provider ##\nContent Provider 用于程序之间数据交换。Android系统中，每个应用的数据库、文件、资源等信息都是私有的，其他程序无法访问，如果想要访问这些数据，就必须提供一种程序之间数据的访问机制，这就是Content Provider的由来。一个典型的Content Provider声明如下：\n\n\t<provider\n\t\tandroid:name=\"com.test.providerhehe\"\n\t\tandroid:authorities=\"cpm.test.heheprovider\"\n\t\tandroid:readPermission=\"droider.permission.FILE_READ\"\n\t\tandroid:writePermission=\"droider.permission.FILE_WRITE\"\n\t>\n\nContent Provider提供了insert()、delete()、update()、query()等操作，其中执行query()查询操作时会执行读权限android:readPermission检查，其他的操作会执行写权限android:writePermission检查，权限检查失败时会抛出SecurityException异常。对于很多开发人员来说，在声明Content Provider 时几乎从来不使用这两个权限，这导致了串谋攻击发生的可能。部分网络软件开发商使用Content Provider来实现软件登陆、用户密码修改等敏感度极高的操作，然而声明的Content Provider却没有权限控制，这使得一些恶意软件无需任何权限就可以获取用户的敏感信息。\n\n## 串谋权限攻击 ##\nAndroid程序中资源的访问包括使用Framework提供的功能与访问其他程序的组件，前者是通过系统提供的权限机制进行控制的，后者是通过自定义权限控制的。正常情况下，没有声明特定的访问权限，就无法访问这些资源。但通过其他程序中可访问的Android组件，就有可能突破这种访问控制，从而提升程序本身的权限，这种权限提升的攻击方式在这称为串谋权限攻击。\n\n![串谋权限攻击示意图](https://cloud.githubusercontent.com/assets/10484766/11139875/7c3829ba-8a0f-11e5-838c-83064d88a724.png)\n\n这里可以模拟一个场景，有一个下载管理程序实例DownloadManager，有一个TextView输入想要下载的文件URL，点击下载按钮即开始下载，下载下来的文件默认保存在SD卡上。当然，该实例拥有下载文件和保存SD卡的权利：\n\n\t<uses-permission androidLname=\"android.permission.WRITE_EXTERNAL_STORAGE/\">\n\t<uses-permission android:name=\"android.permission.INTERNET\">\n\n下载文件的功能是通过接收下载请求广播，然后在下载广播接收者中完成的，对应的广播接收者在AndroidManifest.xml中声明：\n\n\t<receiver android:name=\".DownloadReceiver\">\n\t\t<intent-filter>\n\t\t\t<action android:name=\"com.test.download\"></action>\n\t\t</intent-filter>\n\t</receiver>\n\nDownloadReceiver响应Action为\"com.test.download\"的广播，然后访问Intent指定的URL地址去下载文件，相应的广播响应代码如下：\n\n\tpublic void onReceive(Context context,Intent intent){\n\t\tif(intent.getAction().equals(\"com.test.download\")){\n\t\t\tString url = intent.getExtra().getString(\"url\");\n\t\t\tString filename = intent.getExtra().getString(\"filename\");\n\t\t\tToast.makeText(context,url,Toast.LENGTH_SHORT).show();\n\t\t\ttry{\n\t\t\t\tdownloadFile(url,filename);\n\t\t\t}catch(IOException e){\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\n从上面代码可以清楚地看到，下载的文件时通过url传递过来而保存的文件名则是通过filename传递。接下来就是我们的攻击程序HackerDownloader，它什么权限都没有，只有一段发送文件下载请求的代码：\n\n\tbtn.setOnClickListener(new OnClickListener(){\n\t\t@override\n\t\tpublic void onClick(){\n\t\t\tIntent intent = new Intent();//创建Intent对象\n\t\t\tintent.setAction(\"com.test.download\");\n\t\t\tintent.putExtra(\"url\",\"http://********\");//要下载文件url地址\n\t\t\tString fileName = \"test.txt\";\n\t\t\tintent.putExtra(\"filename\",fileName);\n\t\t\tsendBroadcast(intent);\n\t\t}\n\t});\n\n当HackerDownloader点击下载按钮以后，DownloadReceiver收到广播后就会开始下载相对应的文件并保存到指定目录下。至此，一次完美的串谋攻击就完成了。\n\n","slug":"简析Android组件安全","published":1,"updated":"2016-06-14T10:04:45.716Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cisn9io3d000064viu2mvomi3","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>前段时间在学习github上DroidPlgin插件的时候接触到不少专业术语，诸如预先占坑、Activity劫持和Hook等，一开始看还真是感觉雾里看花。在查阅资料的过程中发现了国人出版的《Android软件安全与逆向分析》，在理解Activity劫持的过程中引申了Android四大组件的安全。知识点不难却感觉蛮有趣，故分享之。<a id=\"more\"></a></p>\n<h2 id=\"Activity\"><a href=\"#Activity\" class=\"headerlink\" title=\"Activity\"></a>Activity</h2><p>Android组件是用户唯一能够看见的组件，作为软件所有功能的显示载体，其安全问题是最应该受到关注的</p>\n<h3 id=\"权限攻击\"><a href=\"#权限攻击\" class=\"headerlink\" title=\"权限攻击\"></a>权限攻击</h3><p>正如Android开发文档中所说的，Android系统组件在制定Intent过滤器（intent-filter）后，默认是可以被外部程序访问的。这就很意味着很容易被其他程序进行串谋攻击，关于串谋攻击，在分享最后再做一个简单的解析。现在问题是，如何防止Activity被外部使用呢？</p>\n<p>Android所有组件声明时可以通过指定android:exported属性值为false，来设置组件不能被外部程序调用。这里的外部程序是指签名不同、用户ID不同的程序，签名相同且用户ID相同的程序在执行时共享同一个进程空间，彼此之间是没有组件访问限制的。如果希望Activity能够被特定的程序访问，就不能用android:exported属性了，可以使用android:permission属性来指定一个权限字符串，声明例子如下：</p>\n<pre><code>&lt;Activity android:name=&quot;.MyActivity&quot;\n       android:permission=&quot;com.test.permission.MyActivity&quot;&gt;\n       &lt;intent-filter&gt;\n           &lt;action android:name=&quot;com.test.action&quot;&gt;&lt;/action&gt;\n       &lt;/intent-filter&gt;\n&lt;/Activity&gt;\n</code></pre><p>这样声明的Activity在被调用时，Android系统就会检查调用者是否具有com.test.permission.MyActivity权限，如果不具备就会触发一个SecurityException安全异常。要想启动该Activity必须在AndroidManifest.xml文件中加入以下声明：</p>\n<pre><code>&lt;uses-permission android:name=&quot;com.test.permission.MyActivity&quot;&gt;\n</code></pre><h3 id=\"Activity劫持\"><a href=\"#Activity劫持\" class=\"headerlink\" title=\"Activity劫持\"></a>Activity劫持</h3><p>当用户安装了带有Activity劫持功能的恶意程序后，恶意程序会遍历系统中运行的程序，当检测到需要劫持的Activity（通常是网银或其他网络程序的等登陆界面）在前台运行时，恶意程序就会启动一个带FLAG_ACTIVITY_NEW_TASK标志的钓鱼式Activity覆盖正常的Activity，从而欺骗输入用户名或密码信息，当用户输入完信息后，程序就会将信息发送到指定的网址或邮箱，然后切换到正常的Activity中。这就是Activity劫持原理。从受影响的角度看，Activity属于用户层安全，程序员无法控制。</p>\n<p>下面做一个简单的劫持例子。实例可以对多个进程进行劫持，它在启动时启动了一个Hack服务，Hack服务创建了一个定时器，定时器每隔2秒就检测一次系统正在运行的进程，判断前台运行的进程是否匹配劫持的进程列表中，如果匹配就进行劫持：</p>\n<pre><code>private TimeTask mTask = new TimeTask(){\n\n    @Override\n    public void run(){\n         ActivityManager am = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE);\n        List&lt;RunningAppProcessInfo&gt; infos = am.getRunningAppProcesses();\n        //枚举进程\n        for(RunningAppProcessInfo psinfo:infos){\n            if(psinfo.importance == RunningAppProcessInfo.IMPORTANCE_FOREGROUND){ //前台进程\n                 if(hackList.contains(psinfo.processName)){\n                     Intent intent = new Intent(getBaseContent(),HackerActivity.class);\n                    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)；\n                    intent.putExtra(&quot;processname&quot;,psinfo.processName);\n                    getApplication().startActivity(intent);//启动伪造的Activity\n                }\n             }\n        }\n    }\n\n}\n</code></pre><p>Activity劫持不需要在AndroidManifest.xml中声明任何权限就可以实现，一般的防病毒软件也无法检测，手机用户更是防不胜防。不过有一种方法可以判断当前Activity是否被劫持：长按Home键不放，系统显示最近运行过的程序列表。在本例中，HackerActvity显示在最前面，很显然这个程序就有劫持Actvity的嫌疑。</p>\n<p>Unfortunately，这种检测Activity劫持的方法并不是任何时候都有效的，假如在声明Activity时，设置android:excludeFromRecents的值为true，程序在运行时就不会显示在最近运行过的程序列表中，上面的检测方法也就只能hehe了。</p>\n<h2 id=\"Broadcast-Receiver\"><a href=\"#Broadcast-Receiver\" class=\"headerlink\" title=\"Broadcast Receiver\"></a>Broadcast Receiver</h2><p>Broadcast Receiver用于处理发送和接收广播，这里分为发送安全和接收安全。接收广播涉及串谋攻击，这里先不作介绍，下面主要介绍发送广播安全。先来一段熟悉的代码:</p>\n<pre><code>Intent intent = new Intent();\nintent.setAction(&quot;com.test.broadcast&quot;);\nintent.putExtra(&quot;data&quot;,Math.random());\nsendBroadcast(intent);\n</code></pre><p>这段代码发送了一个Action为com.test.broadcast的广播。我们都知道，Android系统提供了两种广播发送方法，分别是sendBroadcast()和sendOrderedBroadcast()。sendBroadcast()用于发送无序广播，该广播能够被所有广播接受者接收，并且不能被abortBroadcast()终止，sendOrderedBroadcast()用于发送有序广播，该广播被优先级高的广播接收者有限接收，然后依次向下传递，优先级高的广播接收者可以篡改广播，或者调用abortBroadcast()终止广播。广播优先级响应的计算方法是：动态注册的广播接收者比静态广播接收者的优先级高，静态广播接收者的优先级根据设置的android:priority属性的数值来决定，数值越大，优先级越高。</p>\n<p>从上面分析可以得知，假如Hacker动态注册一个Action为com.test.broadcast的广播接收者，并且拥有最高的优先级，上述程序假如使用sendBroadcast()发送广播，Hacker的确无法通过abortBroadcast()终止，但可以优先响应该实例发送的广播；但是假如上述程序使用sendOrderedBroadcast()发送，很有可能BroadcastReceiver实例就永远无法收到自己发送的广播。</p>\n<p>当然，上述问题也是可以避免的。在发送广播时通过Intent指定具体要发送到的Android组件或类，广播就永远只能被本实例指定的类所接收，如：</p>\n<pre><code>intent,setClass(MainActivity.this,test.class);\n</code></pre><h2 id=\"Service\"><a href=\"#Service\" class=\"headerlink\" title=\"Service\"></a>Service</h2><p>Service组件是Android系统中的后台进程，主要的功能是在后台进行一些耗时的操作。与其他的Android组件一样，当声明Service时指定了Intent过滤器，该Service默认就可以被外部访问。可以访问的方法有：</p>\n<blockquote>\n<p>startService():启动服务，可以被用来实现串谋攻击。</p>\n<p>bindService():绑定服务，可以被用来实现串谋攻击。</p>\n<p>stopService():停止服务，对程序功能进行恶意破坏。</p>\n</blockquote>\n<p>对于恶意的stopService，它破解程序的执行环境，直接影响到程序的正常运行。要想杜绝Service组件被人恶意的启动或者停止，就需要使用Android系统的权限机制来对调用者进行控制。如果Service组件不想被程序外的其他组件访问，可以直接设置它的android:exported属性为false，如果是同一作者的多个程序共享使用该服务，则可以使用自定义的权限，这在Activity的权限攻击已经介绍过，这里就不铺开来说了。</p>\n<h2 id=\"Content-Provider\"><a href=\"#Content-Provider\" class=\"headerlink\" title=\"Content Provider\"></a>Content Provider</h2><p>Content Provider 用于程序之间数据交换。Android系统中，每个应用的数据库、文件、资源等信息都是私有的，其他程序无法访问，如果想要访问这些数据，就必须提供一种程序之间数据的访问机制，这就是Content Provider的由来。一个典型的Content Provider声明如下：</p>\n<pre><code>&lt;provider\n    android:name=&quot;com.test.providerhehe&quot;\n    android:authorities=&quot;cpm.test.heheprovider&quot;\n    android:readPermission=&quot;droider.permission.FILE_READ&quot;\n    android:writePermission=&quot;droider.permission.FILE_WRITE&quot;\n&gt;\n</code></pre><p>Content Provider提供了insert()、delete()、update()、query()等操作，其中执行query()查询操作时会执行读权限android:readPermission检查，其他的操作会执行写权限android:writePermission检查，权限检查失败时会抛出SecurityException异常。对于很多开发人员来说，在声明Content Provider 时几乎从来不使用这两个权限，这导致了串谋攻击发生的可能。部分网络软件开发商使用Content Provider来实现软件登陆、用户密码修改等敏感度极高的操作，然而声明的Content Provider却没有权限控制，这使得一些恶意软件无需任何权限就可以获取用户的敏感信息。</p>\n<h2 id=\"串谋权限攻击\"><a href=\"#串谋权限攻击\" class=\"headerlink\" title=\"串谋权限攻击\"></a>串谋权限攻击</h2><p>Android程序中资源的访问包括使用Framework提供的功能与访问其他程序的组件，前者是通过系统提供的权限机制进行控制的，后者是通过自定义权限控制的。正常情况下，没有声明特定的访问权限，就无法访问这些资源。但通过其他程序中可访问的Android组件，就有可能突破这种访问控制，从而提升程序本身的权限，这种权限提升的攻击方式在这称为串谋权限攻击。</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/10484766/11139875/7c3829ba-8a0f-11e5-838c-83064d88a724.png\" alt=\"串谋权限攻击示意图\"></p>\n<p>这里可以模拟一个场景，有一个下载管理程序实例DownloadManager，有一个TextView输入想要下载的文件URL，点击下载按钮即开始下载，下载下来的文件默认保存在SD卡上。当然，该实例拥有下载文件和保存SD卡的权利：</p>\n<pre><code>&lt;uses-permission androidLname=&quot;android.permission.WRITE_EXTERNAL_STORAGE/&quot;&gt;\n&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;&gt;\n</code></pre><p>下载文件的功能是通过接收下载请求广播，然后在下载广播接收者中完成的，对应的广播接收者在AndroidManifest.xml中声明：</p>\n<pre><code>&lt;receiver android:name=&quot;.DownloadReceiver&quot;&gt;\n    &lt;intent-filter&gt;\n        &lt;action android:name=&quot;com.test.download&quot;&gt;&lt;/action&gt;\n    &lt;/intent-filter&gt;\n&lt;/receiver&gt;\n</code></pre><p>DownloadReceiver响应Action为”com.test.download”的广播，然后访问Intent指定的URL地址去下载文件，相应的广播响应代码如下：</p>\n<pre><code>public void onReceive(Context context,Intent intent){\n    if(intent.getAction().equals(&quot;com.test.download&quot;)){\n        String url = intent.getExtra().getString(&quot;url&quot;);\n        String filename = intent.getExtra().getString(&quot;filename&quot;);\n        Toast.makeText(context,url,Toast.LENGTH_SHORT).show();\n        try{\n            downloadFile(url,filename);\n        }catch(IOException e){\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre><p>从上面代码可以清楚地看到，下载的文件时通过url传递过来而保存的文件名则是通过filename传递。接下来就是我们的攻击程序HackerDownloader，它什么权限都没有，只有一段发送文件下载请求的代码：</p>\n<pre><code>btn.setOnClickListener(new OnClickListener(){\n    @override\n    public void onClick(){\n        Intent intent = new Intent();//创建Intent对象\n        intent.setAction(&quot;com.test.download&quot;);\n        intent.putExtra(&quot;url&quot;,&quot;http://********&quot;);//要下载文件url地址\n        String fileName = &quot;test.txt&quot;;\n        intent.putExtra(&quot;filename&quot;,fileName);\n        sendBroadcast(intent);\n    }\n});\n</code></pre><p>当HackerDownloader点击下载按钮以后，DownloadReceiver收到广播后就会开始下载相对应的文件并保存到指定目录下。至此，一次完美的串谋攻击就完成了。</p>\n","excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>前段时间在学习github上DroidPlgin插件的时候接触到不少专业术语，诸如预先占坑、Activity劫持和Hook等，一开始看还真是感觉雾里看花。在查阅资料的过程中发现了国人出版的《Android软件安全与逆向分析》，在理解Activity劫持的过程中引申了Android四大组件的安全。知识点不难却感觉蛮有趣，故分享之。","more":"</p>\n<h2 id=\"Activity\"><a href=\"#Activity\" class=\"headerlink\" title=\"Activity\"></a>Activity</h2><p>Android组件是用户唯一能够看见的组件，作为软件所有功能的显示载体，其安全问题是最应该受到关注的</p>\n<h3 id=\"权限攻击\"><a href=\"#权限攻击\" class=\"headerlink\" title=\"权限攻击\"></a>权限攻击</h3><p>正如Android开发文档中所说的，Android系统组件在制定Intent过滤器（intent-filter）后，默认是可以被外部程序访问的。这就很意味着很容易被其他程序进行串谋攻击，关于串谋攻击，在分享最后再做一个简单的解析。现在问题是，如何防止Activity被外部使用呢？</p>\n<p>Android所有组件声明时可以通过指定android:exported属性值为false，来设置组件不能被外部程序调用。这里的外部程序是指签名不同、用户ID不同的程序，签名相同且用户ID相同的程序在执行时共享同一个进程空间，彼此之间是没有组件访问限制的。如果希望Activity能够被特定的程序访问，就不能用android:exported属性了，可以使用android:permission属性来指定一个权限字符串，声明例子如下：</p>\n<pre><code>&lt;Activity android:name=&quot;.MyActivity&quot;\n       android:permission=&quot;com.test.permission.MyActivity&quot;&gt;\n       &lt;intent-filter&gt;\n           &lt;action android:name=&quot;com.test.action&quot;&gt;&lt;/action&gt;\n       &lt;/intent-filter&gt;\n&lt;/Activity&gt;\n</code></pre><p>这样声明的Activity在被调用时，Android系统就会检查调用者是否具有com.test.permission.MyActivity权限，如果不具备就会触发一个SecurityException安全异常。要想启动该Activity必须在AndroidManifest.xml文件中加入以下声明：</p>\n<pre><code>&lt;uses-permission android:name=&quot;com.test.permission.MyActivity&quot;&gt;\n</code></pre><h3 id=\"Activity劫持\"><a href=\"#Activity劫持\" class=\"headerlink\" title=\"Activity劫持\"></a>Activity劫持</h3><p>当用户安装了带有Activity劫持功能的恶意程序后，恶意程序会遍历系统中运行的程序，当检测到需要劫持的Activity（通常是网银或其他网络程序的等登陆界面）在前台运行时，恶意程序就会启动一个带FLAG_ACTIVITY_NEW_TASK标志的钓鱼式Activity覆盖正常的Activity，从而欺骗输入用户名或密码信息，当用户输入完信息后，程序就会将信息发送到指定的网址或邮箱，然后切换到正常的Activity中。这就是Activity劫持原理。从受影响的角度看，Activity属于用户层安全，程序员无法控制。</p>\n<p>下面做一个简单的劫持例子。实例可以对多个进程进行劫持，它在启动时启动了一个Hack服务，Hack服务创建了一个定时器，定时器每隔2秒就检测一次系统正在运行的进程，判断前台运行的进程是否匹配劫持的进程列表中，如果匹配就进行劫持：</p>\n<pre><code>private TimeTask mTask = new TimeTask(){\n\n    @Override\n    public void run(){\n         ActivityManager am = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE);\n        List&lt;RunningAppProcessInfo&gt; infos = am.getRunningAppProcesses();\n        //枚举进程\n        for(RunningAppProcessInfo psinfo:infos){\n            if(psinfo.importance == RunningAppProcessInfo.IMPORTANCE_FOREGROUND){ //前台进程\n                 if(hackList.contains(psinfo.processName)){\n                     Intent intent = new Intent(getBaseContent(),HackerActivity.class);\n                    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)；\n                    intent.putExtra(&quot;processname&quot;,psinfo.processName);\n                    getApplication().startActivity(intent);//启动伪造的Activity\n                }\n             }\n        }\n    }\n\n}\n</code></pre><p>Activity劫持不需要在AndroidManifest.xml中声明任何权限就可以实现，一般的防病毒软件也无法检测，手机用户更是防不胜防。不过有一种方法可以判断当前Activity是否被劫持：长按Home键不放，系统显示最近运行过的程序列表。在本例中，HackerActvity显示在最前面，很显然这个程序就有劫持Actvity的嫌疑。</p>\n<p>Unfortunately，这种检测Activity劫持的方法并不是任何时候都有效的，假如在声明Activity时，设置android:excludeFromRecents的值为true，程序在运行时就不会显示在最近运行过的程序列表中，上面的检测方法也就只能hehe了。</p>\n<h2 id=\"Broadcast-Receiver\"><a href=\"#Broadcast-Receiver\" class=\"headerlink\" title=\"Broadcast Receiver\"></a>Broadcast Receiver</h2><p>Broadcast Receiver用于处理发送和接收广播，这里分为发送安全和接收安全。接收广播涉及串谋攻击，这里先不作介绍，下面主要介绍发送广播安全。先来一段熟悉的代码:</p>\n<pre><code>Intent intent = new Intent();\nintent.setAction(&quot;com.test.broadcast&quot;);\nintent.putExtra(&quot;data&quot;,Math.random());\nsendBroadcast(intent);\n</code></pre><p>这段代码发送了一个Action为com.test.broadcast的广播。我们都知道，Android系统提供了两种广播发送方法，分别是sendBroadcast()和sendOrderedBroadcast()。sendBroadcast()用于发送无序广播，该广播能够被所有广播接受者接收，并且不能被abortBroadcast()终止，sendOrderedBroadcast()用于发送有序广播，该广播被优先级高的广播接收者有限接收，然后依次向下传递，优先级高的广播接收者可以篡改广播，或者调用abortBroadcast()终止广播。广播优先级响应的计算方法是：动态注册的广播接收者比静态广播接收者的优先级高，静态广播接收者的优先级根据设置的android:priority属性的数值来决定，数值越大，优先级越高。</p>\n<p>从上面分析可以得知，假如Hacker动态注册一个Action为com.test.broadcast的广播接收者，并且拥有最高的优先级，上述程序假如使用sendBroadcast()发送广播，Hacker的确无法通过abortBroadcast()终止，但可以优先响应该实例发送的广播；但是假如上述程序使用sendOrderedBroadcast()发送，很有可能BroadcastReceiver实例就永远无法收到自己发送的广播。</p>\n<p>当然，上述问题也是可以避免的。在发送广播时通过Intent指定具体要发送到的Android组件或类，广播就永远只能被本实例指定的类所接收，如：</p>\n<pre><code>intent,setClass(MainActivity.this,test.class);\n</code></pre><h2 id=\"Service\"><a href=\"#Service\" class=\"headerlink\" title=\"Service\"></a>Service</h2><p>Service组件是Android系统中的后台进程，主要的功能是在后台进行一些耗时的操作。与其他的Android组件一样，当声明Service时指定了Intent过滤器，该Service默认就可以被外部访问。可以访问的方法有：</p>\n<blockquote>\n<p>startService():启动服务，可以被用来实现串谋攻击。</p>\n<p>bindService():绑定服务，可以被用来实现串谋攻击。</p>\n<p>stopService():停止服务，对程序功能进行恶意破坏。</p>\n</blockquote>\n<p>对于恶意的stopService，它破解程序的执行环境，直接影响到程序的正常运行。要想杜绝Service组件被人恶意的启动或者停止，就需要使用Android系统的权限机制来对调用者进行控制。如果Service组件不想被程序外的其他组件访问，可以直接设置它的android:exported属性为false，如果是同一作者的多个程序共享使用该服务，则可以使用自定义的权限，这在Activity的权限攻击已经介绍过，这里就不铺开来说了。</p>\n<h2 id=\"Content-Provider\"><a href=\"#Content-Provider\" class=\"headerlink\" title=\"Content Provider\"></a>Content Provider</h2><p>Content Provider 用于程序之间数据交换。Android系统中，每个应用的数据库、文件、资源等信息都是私有的，其他程序无法访问，如果想要访问这些数据，就必须提供一种程序之间数据的访问机制，这就是Content Provider的由来。一个典型的Content Provider声明如下：</p>\n<pre><code>&lt;provider\n    android:name=&quot;com.test.providerhehe&quot;\n    android:authorities=&quot;cpm.test.heheprovider&quot;\n    android:readPermission=&quot;droider.permission.FILE_READ&quot;\n    android:writePermission=&quot;droider.permission.FILE_WRITE&quot;\n&gt;\n</code></pre><p>Content Provider提供了insert()、delete()、update()、query()等操作，其中执行query()查询操作时会执行读权限android:readPermission检查，其他的操作会执行写权限android:writePermission检查，权限检查失败时会抛出SecurityException异常。对于很多开发人员来说，在声明Content Provider 时几乎从来不使用这两个权限，这导致了串谋攻击发生的可能。部分网络软件开发商使用Content Provider来实现软件登陆、用户密码修改等敏感度极高的操作，然而声明的Content Provider却没有权限控制，这使得一些恶意软件无需任何权限就可以获取用户的敏感信息。</p>\n<h2 id=\"串谋权限攻击\"><a href=\"#串谋权限攻击\" class=\"headerlink\" title=\"串谋权限攻击\"></a>串谋权限攻击</h2><p>Android程序中资源的访问包括使用Framework提供的功能与访问其他程序的组件，前者是通过系统提供的权限机制进行控制的，后者是通过自定义权限控制的。正常情况下，没有声明特定的访问权限，就无法访问这些资源。但通过其他程序中可访问的Android组件，就有可能突破这种访问控制，从而提升程序本身的权限，这种权限提升的攻击方式在这称为串谋权限攻击。</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/10484766/11139875/7c3829ba-8a0f-11e5-838c-83064d88a724.png\" alt=\"串谋权限攻击示意图\"></p>\n<p>这里可以模拟一个场景，有一个下载管理程序实例DownloadManager，有一个TextView输入想要下载的文件URL，点击下载按钮即开始下载，下载下来的文件默认保存在SD卡上。当然，该实例拥有下载文件和保存SD卡的权利：</p>\n<pre><code>&lt;uses-permission androidLname=&quot;android.permission.WRITE_EXTERNAL_STORAGE/&quot;&gt;\n&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;&gt;\n</code></pre><p>下载文件的功能是通过接收下载请求广播，然后在下载广播接收者中完成的，对应的广播接收者在AndroidManifest.xml中声明：</p>\n<pre><code>&lt;receiver android:name=&quot;.DownloadReceiver&quot;&gt;\n    &lt;intent-filter&gt;\n        &lt;action android:name=&quot;com.test.download&quot;&gt;&lt;/action&gt;\n    &lt;/intent-filter&gt;\n&lt;/receiver&gt;\n</code></pre><p>DownloadReceiver响应Action为”com.test.download”的广播，然后访问Intent指定的URL地址去下载文件，相应的广播响应代码如下：</p>\n<pre><code>public void onReceive(Context context,Intent intent){\n    if(intent.getAction().equals(&quot;com.test.download&quot;)){\n        String url = intent.getExtra().getString(&quot;url&quot;);\n        String filename = intent.getExtra().getString(&quot;filename&quot;);\n        Toast.makeText(context,url,Toast.LENGTH_SHORT).show();\n        try{\n            downloadFile(url,filename);\n        }catch(IOException e){\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre><p>从上面代码可以清楚地看到，下载的文件时通过url传递过来而保存的文件名则是通过filename传递。接下来就是我们的攻击程序HackerDownloader，它什么权限都没有，只有一段发送文件下载请求的代码：</p>\n<pre><code>btn.setOnClickListener(new OnClickListener(){\n    @override\n    public void onClick(){\n        Intent intent = new Intent();//创建Intent对象\n        intent.setAction(&quot;com.test.download&quot;);\n        intent.putExtra(&quot;url&quot;,&quot;http://********&quot;);//要下载文件url地址\n        String fileName = &quot;test.txt&quot;;\n        intent.putExtra(&quot;filename&quot;,fileName);\n        sendBroadcast(intent);\n    }\n});\n</code></pre><p>当HackerDownloader点击下载按钮以后，DownloadReceiver收到广播后就会开始下载相对应的文件并保存到指定目录下。至此，一次完美的串谋攻击就完成了。</p>"},{"title":"Resource.arsc文件格式","date":"2016-09-03T13:58:46.737Z","_content":"\n# 前言 #\n在研究资源混淆的过程中了解到微信的资源混淆工具--[AndResGuard](https://github.com/shwenzhang/AndResGuard)，这个工具的强大之处不仅仅在于混淆了冗余的资源文件名称和明显减少apk的大小（这是官方说明，小弟小试了下效果不明显，有待考证），同时不涉及生成apk的编译流程，只需要输入apk和一些命令参数即可生成所需的混淆资源后的apk。<!-- more -->\n（美团也有一套混淆资源的方法，介绍是修改AAPT处理资源文件相关的源码，牛逼哄哄的样子：[没错，我是链接](http://tech.meituan.com/mt-android-resource-obfuscation.html)）。Anyway，对于追求完美的技术人员而言，并不能满足于一个现成的工具，了解其中原理加以修改才可以灵活运用。AndResGuard主要是通过修改resources.arsc文件来打到混淆的目的，因此，本文主要是对resources.arsc的文件格式进行阐述。\n至于详细的实现方案和流程可参考[AndResGuard原理](http://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&mid=208135658&idx=1&sn=ac9bd6b4927e9e82f9fa14e396183a8f#rd)\n\n# 数据结构总体介绍 #\n\nresources.arsc文件格式是由一系列的chunk构成。总体而言，可以大致分为五个chunk，分别是TYPETABLE，TYPEPACKAGE，TYPE_STRING， TYPETYPE和TYPESPEC；而这些chunk组成的结构就是资源索引表头部+字符串资源池+N个Package数据块。贴上一张传烂的图：\n\n![](http://i.imgur.com/UVU3hWW.png)\n\n是的，看完这图我也是懵逼的。没关系，下面作一个详细点的介绍。\n\n# 头部信息 #\n\n在介绍每个chunk之前，先说明下每个chunk均包含一个ResChunk_header的头部信息，具体的数据定义如下：\n\n\tstruct ResChunk_header\n\t{\n    // 是当前这个chunk的类型\n    uint16_t type;\n\n    // 是当前这个chunk的头部大小\n    uint16_t headerSize;\n\n    // 是当前这个chunk的大小\n    uint32_t size;\n\t};\n\n从上面的结构图可以看到，每一个chunk均是以ResChunk_header作为开头，在下面的介绍中，将会跳过。\n\n# 资源索引表头部（TYPETABLE） #\n\n![](http://i.imgur.com/K76gXh0.png)\n\n可以看到，除了头部信息，还有一个package数的数据，一个apk可能包含多个资源包，这里就是指被编译的资源包个数。具体体现在有多少个TYPEPACKAGE。\n\n# 字符串资源池（TYPE_STRING） #\n\n![](http://i.imgur.com/zWKmKf3.png)\n\n紧接着资源索引表头部的就是字符串资源池，这个chunk包含了所有package里定义的字符串。这个chunk的数据结构比较重要，在后面的TYPEPACKAGE里也包含着这一种chunk的数据结构，同时也是AndResGuard其中做修改数据的位置。下面简略地看下其数据结构介绍：\n\n### ResStringPool_header ###\nheader：标准的Chunk头部信息结构</br>\nstringCount：字符串的个数</br>\nstyleCount：字符串样式的个数</br>\nflags：字符串的属性,可取值包括0x000(UTF-16),0x001(字符串经过排序)、0X100(UTF-8)和他们的组合值</br>\nstringStart：字符串内容块相对于其头部的距离</br>\nstylesStart：字符串样式块相对于其头部的距离\n\n### 两个Array和两个Content ###\n紧接着ResStringPool_header就是字符串偏移数组和字符串样式偏移数组，字符串偏移数组每个元素记录着每个字符串相对于StringContent（图中数据‘字符串’）开始的索引；同样的，字符串样式偏移数组每个元素记录着每个字符串相对于StyleContent（图中数据‘style’）开始的索引。\n\n整个字符串资源区的结构示意图：\n\n![](http://i.imgur.com/pV5kgSm.png)\n\n\n# Package数据块（TYPEPACKAGE） #\n\n在资源索引表头部中指定了package数目，所以，在这里开始，package数据块（包含TYPETYPE和TYPESPEC）是一个紧接着一个（假如有多个package）。</br>\n下面，先介绍下TYPEPACKAGE这个chunk的数据结构：\n\n![](http://i.imgur.com/p0g4EWp.png)\n\n### ResTable_package ###\nheader：Chunk的头部信息数据结构</br>\nid：包的ID,等于Package Id,一般用户包的值Package Id为0X7F,系统资源包的Package Id为0X01</br>\nname：包名</br>\ntypeString：类型字符串资源池相对头部的偏移</br>\nlastPublicType：最后一个导出的Public类型字符串在类型字符串资源池中的索引，目前这个值设置为类型字符串资源池的元素个数。在解析的过程中没发现他的用途</br>\nkeyStrings：资源项名称字符串相对头部的偏移</br>\nlastPublicKey：最后一个导出的Public资源项名称字符串在资源项名称字符串资源池中的索引，目前这个值设置为资源项名称字符串资源池的元素个数。在解析的过程中没发现他的用途\n\n### Type String Pool & Key String Pool ###\n紧接着ResTable_package的是两个与字符串资源池有相同结构的字符串资源池，区别在于这里的资源池只是包含当前package的资源。\n\nType String Pool（图中数据‘资源类型字符串池’）是一个package中用到的类型字符串，如：anim，id，layout；\n\nKey String Pool（图中数据‘资源项名称字符串池’），比如string.xml内容如下：\n\n\t<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\t<resources>\n    <string name=\"app_name\">Test</string>\n    <string name=\"hello_world\">Hello world!</string>\n    <string name=\"action_settings\">Settings</string>\n\t</resources>\n\n那么这个pool就收集了app_name，hello_world   action_settings 这3个字符串。这个pool是AndResGuard作修改的一处位置。\n\n整个Package数据块区的结构示意图：\n\n![](http://i.imgur.com/Mhj3UOF.png)\n\n可以看到，在紧接着Type String Pool和Key String Pool后是剩下的两个chunk，在这里Type Specification Trunk和Type Info Trunk分别对应 TYPESPEC和TYPETYPE，下面作详细介绍。\n\n# 类型规范数据块（TYPESPEC） & 资源类型项数据块（TYPETYPE）#\n\n先来看一段TYPESPEC的介绍：\n\n\t类型规范数据块用来描述资源项的配置差异性。通过这个差异性描述，我们就可以知道每一个资源项的配置状况。知道了一个资源项的配置状况之后，Android资源管理框架在检测到设备的配置信息发生变化之后，就可以知道是否需要重新加载该资源项。类型规范数据块是按照类型来组织的，也就是说，每一种类型都对应有一个类型规范数据块。\n\n![](http://i.imgur.com/ERotuBl.png)\n\n国际惯例，大概了解下其数据结构：\n\n\theader：Chunk的头部信息结构\n\tid：标识资源的Type ID,Type ID是指资源的类型ID。资源的类型有animator、anim、color、drawable、layout、menu、raw、string和xml等等若干种，每一种都会被赋予一个ID。\n\tres0：保留,始终为0\n\tres1：保留,始终为0\n\tentryCount：等于本类型的资源项个数,指名称相同的资源项的个数。\n\n再来一段TYPETYPE的介绍：\n\n\t类型资源项数据块用来描述资源项的具体信息, 这样我们就可以知道每一个资源项的名称、值和配置等信息。 类型资源项数据同样是按照类型和配置来组织的,也就是说,一个具有n个配置的类型一共对应有n个类型资源项数据块。\n\n![](http://i.imgur.com/VBljfg6.png)\n\nTYPETYPE的数据结构：\n\n\theader：Chunk的头部信息结构\n\tid：标识资源的Type ID\n\tres0：保留,始终为0\n\tres1：保留,始终为0\n\tentryCount：等于本类型的资源项个数,指名称相同的资源项的个数。\n\tentriesStart：等于资源项数据块相对头部的偏移值。\n\tresConfig：指向一个ResTable_config,用来描述配置信息,地区,语言,分辨率等\n\n注意下的是，这里两个chunk的id均是标识资源的id，这里是指类似drawable和anim等类型，其他字段在这里不做介绍，结合AndResGuard重点介绍的是紧跟TYPETYPE后的ResTable_entry数组，这个数组是指具体每个元素的配置解释，而这里也是AndResGuard需要做修改的其中两个地方。\n\n说实话，看到两段描述的时候有点混乱，查阅资料和说明例子后以为理解了，结合AndResGuard源码尝试去理解更换两个chunk数据，又陷入了无限的懵逼状态。归根结底，是不能理解类型和配置是如何进行映射。毛爷爷说过，实践是检验真理的唯一标准，于是乎，小弟写了个简单的helloworld的demo，主要截上资源配置：\n\n![](http://i.imgur.com/4AZ99ZF.png)\n\n这里要留意两点，一是类型drawable有三种配置，分别是drawable-hdpi，drawable-mdpi和drawable-xhdpi，这三个配置里均有ic_launcher.png；第二点是，在drawable-mdpi文件下有test.png。\n\n然后就开始解析里面的resources.arsc，主要结果截图如下：\n\n图一：\n\n![](http://i.imgur.com/qNT1t9t.png)\n\n图二：\n\n![](http://i.imgur.com/0TKtzCp.png)\n\n关注图一，主要是说明两个TYPESPEC，以parse restype spec chunk...开始解析，第一块的type_name:attr，没有元素，所以\nentryCount=0；第二块的type_name:drawable，留意下entryCount=2，有两个元素，所以对应有两个TYPETYPE，这里是以parse restype info chunk...开始解析，这个也很好理解，因为demo是有两张图片，分别是ic_launcher和test，对应的是drawable-mdpi文件下的文件描述；</br>\n\n这时候关注下图二，这个是另外两个TYPETYPE chunk的截图，自然而然想到的是另外两个drawable的文件资源描述，图中每个圈是每一个entry，entry中的index是对应package chunk中资源项名称字符串池的字符串偏移值，解析出来的字符串时str:ic_launcher，value中的data其实是在 字符串资源池（TYPE_STRING）解析出来的数据，在内部也是通过一个偏移值去获取该值；图二还有一个细节，也是困扰小弟几天的问题，就是即使在drawable-mdpi文件下没有test.png，在其数据结构的trunk中的entryCount=2，而在具体的entry中datatype=TYPR_NULL,这就很好地理解了AndResGuard中替换资源名字的方法，保持每个resId的唯一性，同时也可以针对具体的配置进行文件名替换。</br>\n\n至此，最后的两个chunk也介绍完毕。归结而言，就是每个资源类型对应一个TYPESPEC，而紧跟每一种类型的就是其类型所包含的配置，每个配置就是对应一个TYPETYPE。\n\n\n# 关注AndResGuard #\n\n大概了解了resources.arsc结构，去了解AndResGuard混淆资源的方案就应该更为清晰了，简单看下替换方案：\n\n![](http://i.imgur.com/Z6EDzF0.png)\n\n首先，我们其实修改的是资源文件名(a.png)和资源文件的路径名（r\\a\\a.png），这样对应修改的就是TYPEPACKAGE和TYPE_STRING（对应方案1和3），而最后我们介绍的TYPETYPE和TYPESPEC是分别有TYPEPACKAGE和TYPE_STRING的字符串偏移值，这样对应也需要做修改（对应方案4），当然，缩短了文件命名必然会对整个table的大小造成改变，所以要重新计算并写入新的resources.arsc（对应方案5），结合源码分析，可能会有更深的理解。</br>\n\n由于本人没有对resources.arsc做整体的透彻理解，只是在AndResGuard项目基础上去选择性关注要修改的点，如果在分析过程中有出现纰漏或者错误的地方，希望指出。\n\n参考资料：\n[http://blog.csdn.net/jiangwei0910410003/article/details/50628894](http://blog.csdn.net/jiangwei0910410003/article/details/50628894)\n[http://www.cnblogs.com/njxxdx/p/4189971.html](http://www.cnblogs.com/njxxdx/p/4189971.html)\n\n\n\n","source":"_posts/Resource.arsc文件格式.md","raw":"title: Resource.arsc文件格式\ndate: 2016/6/14 17：53\n\ncategories:\n- Mobile\ntags:\n- android\n---\n\n# 前言 #\n在研究资源混淆的过程中了解到微信的资源混淆工具--[AndResGuard](https://github.com/shwenzhang/AndResGuard)，这个工具的强大之处不仅仅在于混淆了冗余的资源文件名称和明显减少apk的大小（这是官方说明，小弟小试了下效果不明显，有待考证），同时不涉及生成apk的编译流程，只需要输入apk和一些命令参数即可生成所需的混淆资源后的apk。<!-- more -->\n（美团也有一套混淆资源的方法，介绍是修改AAPT处理资源文件相关的源码，牛逼哄哄的样子：[没错，我是链接](http://tech.meituan.com/mt-android-resource-obfuscation.html)）。Anyway，对于追求完美的技术人员而言，并不能满足于一个现成的工具，了解其中原理加以修改才可以灵活运用。AndResGuard主要是通过修改resources.arsc文件来打到混淆的目的，因此，本文主要是对resources.arsc的文件格式进行阐述。\n至于详细的实现方案和流程可参考[AndResGuard原理](http://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&mid=208135658&idx=1&sn=ac9bd6b4927e9e82f9fa14e396183a8f#rd)\n\n# 数据结构总体介绍 #\n\nresources.arsc文件格式是由一系列的chunk构成。总体而言，可以大致分为五个chunk，分别是TYPETABLE，TYPEPACKAGE，TYPE_STRING， TYPETYPE和TYPESPEC；而这些chunk组成的结构就是资源索引表头部+字符串资源池+N个Package数据块。贴上一张传烂的图：\n\n![](http://i.imgur.com/UVU3hWW.png)\n\n是的，看完这图我也是懵逼的。没关系，下面作一个详细点的介绍。\n\n# 头部信息 #\n\n在介绍每个chunk之前，先说明下每个chunk均包含一个ResChunk_header的头部信息，具体的数据定义如下：\n\n\tstruct ResChunk_header\n\t{\n    // 是当前这个chunk的类型\n    uint16_t type;\n\n    // 是当前这个chunk的头部大小\n    uint16_t headerSize;\n\n    // 是当前这个chunk的大小\n    uint32_t size;\n\t};\n\n从上面的结构图可以看到，每一个chunk均是以ResChunk_header作为开头，在下面的介绍中，将会跳过。\n\n# 资源索引表头部（TYPETABLE） #\n\n![](http://i.imgur.com/K76gXh0.png)\n\n可以看到，除了头部信息，还有一个package数的数据，一个apk可能包含多个资源包，这里就是指被编译的资源包个数。具体体现在有多少个TYPEPACKAGE。\n\n# 字符串资源池（TYPE_STRING） #\n\n![](http://i.imgur.com/zWKmKf3.png)\n\n紧接着资源索引表头部的就是字符串资源池，这个chunk包含了所有package里定义的字符串。这个chunk的数据结构比较重要，在后面的TYPEPACKAGE里也包含着这一种chunk的数据结构，同时也是AndResGuard其中做修改数据的位置。下面简略地看下其数据结构介绍：\n\n### ResStringPool_header ###\nheader：标准的Chunk头部信息结构</br>\nstringCount：字符串的个数</br>\nstyleCount：字符串样式的个数</br>\nflags：字符串的属性,可取值包括0x000(UTF-16),0x001(字符串经过排序)、0X100(UTF-8)和他们的组合值</br>\nstringStart：字符串内容块相对于其头部的距离</br>\nstylesStart：字符串样式块相对于其头部的距离\n\n### 两个Array和两个Content ###\n紧接着ResStringPool_header就是字符串偏移数组和字符串样式偏移数组，字符串偏移数组每个元素记录着每个字符串相对于StringContent（图中数据‘字符串’）开始的索引；同样的，字符串样式偏移数组每个元素记录着每个字符串相对于StyleContent（图中数据‘style’）开始的索引。\n\n整个字符串资源区的结构示意图：\n\n![](http://i.imgur.com/pV5kgSm.png)\n\n\n# Package数据块（TYPEPACKAGE） #\n\n在资源索引表头部中指定了package数目，所以，在这里开始，package数据块（包含TYPETYPE和TYPESPEC）是一个紧接着一个（假如有多个package）。</br>\n下面，先介绍下TYPEPACKAGE这个chunk的数据结构：\n\n![](http://i.imgur.com/p0g4EWp.png)\n\n### ResTable_package ###\nheader：Chunk的头部信息数据结构</br>\nid：包的ID,等于Package Id,一般用户包的值Package Id为0X7F,系统资源包的Package Id为0X01</br>\nname：包名</br>\ntypeString：类型字符串资源池相对头部的偏移</br>\nlastPublicType：最后一个导出的Public类型字符串在类型字符串资源池中的索引，目前这个值设置为类型字符串资源池的元素个数。在解析的过程中没发现他的用途</br>\nkeyStrings：资源项名称字符串相对头部的偏移</br>\nlastPublicKey：最后一个导出的Public资源项名称字符串在资源项名称字符串资源池中的索引，目前这个值设置为资源项名称字符串资源池的元素个数。在解析的过程中没发现他的用途\n\n### Type String Pool & Key String Pool ###\n紧接着ResTable_package的是两个与字符串资源池有相同结构的字符串资源池，区别在于这里的资源池只是包含当前package的资源。\n\nType String Pool（图中数据‘资源类型字符串池’）是一个package中用到的类型字符串，如：anim，id，layout；\n\nKey String Pool（图中数据‘资源项名称字符串池’），比如string.xml内容如下：\n\n\t<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\t<resources>\n    <string name=\"app_name\">Test</string>\n    <string name=\"hello_world\">Hello world!</string>\n    <string name=\"action_settings\">Settings</string>\n\t</resources>\n\n那么这个pool就收集了app_name，hello_world   action_settings 这3个字符串。这个pool是AndResGuard作修改的一处位置。\n\n整个Package数据块区的结构示意图：\n\n![](http://i.imgur.com/Mhj3UOF.png)\n\n可以看到，在紧接着Type String Pool和Key String Pool后是剩下的两个chunk，在这里Type Specification Trunk和Type Info Trunk分别对应 TYPESPEC和TYPETYPE，下面作详细介绍。\n\n# 类型规范数据块（TYPESPEC） & 资源类型项数据块（TYPETYPE）#\n\n先来看一段TYPESPEC的介绍：\n\n\t类型规范数据块用来描述资源项的配置差异性。通过这个差异性描述，我们就可以知道每一个资源项的配置状况。知道了一个资源项的配置状况之后，Android资源管理框架在检测到设备的配置信息发生变化之后，就可以知道是否需要重新加载该资源项。类型规范数据块是按照类型来组织的，也就是说，每一种类型都对应有一个类型规范数据块。\n\n![](http://i.imgur.com/ERotuBl.png)\n\n国际惯例，大概了解下其数据结构：\n\n\theader：Chunk的头部信息结构\n\tid：标识资源的Type ID,Type ID是指资源的类型ID。资源的类型有animator、anim、color、drawable、layout、menu、raw、string和xml等等若干种，每一种都会被赋予一个ID。\n\tres0：保留,始终为0\n\tres1：保留,始终为0\n\tentryCount：等于本类型的资源项个数,指名称相同的资源项的个数。\n\n再来一段TYPETYPE的介绍：\n\n\t类型资源项数据块用来描述资源项的具体信息, 这样我们就可以知道每一个资源项的名称、值和配置等信息。 类型资源项数据同样是按照类型和配置来组织的,也就是说,一个具有n个配置的类型一共对应有n个类型资源项数据块。\n\n![](http://i.imgur.com/VBljfg6.png)\n\nTYPETYPE的数据结构：\n\n\theader：Chunk的头部信息结构\n\tid：标识资源的Type ID\n\tres0：保留,始终为0\n\tres1：保留,始终为0\n\tentryCount：等于本类型的资源项个数,指名称相同的资源项的个数。\n\tentriesStart：等于资源项数据块相对头部的偏移值。\n\tresConfig：指向一个ResTable_config,用来描述配置信息,地区,语言,分辨率等\n\n注意下的是，这里两个chunk的id均是标识资源的id，这里是指类似drawable和anim等类型，其他字段在这里不做介绍，结合AndResGuard重点介绍的是紧跟TYPETYPE后的ResTable_entry数组，这个数组是指具体每个元素的配置解释，而这里也是AndResGuard需要做修改的其中两个地方。\n\n说实话，看到两段描述的时候有点混乱，查阅资料和说明例子后以为理解了，结合AndResGuard源码尝试去理解更换两个chunk数据，又陷入了无限的懵逼状态。归根结底，是不能理解类型和配置是如何进行映射。毛爷爷说过，实践是检验真理的唯一标准，于是乎，小弟写了个简单的helloworld的demo，主要截上资源配置：\n\n![](http://i.imgur.com/4AZ99ZF.png)\n\n这里要留意两点，一是类型drawable有三种配置，分别是drawable-hdpi，drawable-mdpi和drawable-xhdpi，这三个配置里均有ic_launcher.png；第二点是，在drawable-mdpi文件下有test.png。\n\n然后就开始解析里面的resources.arsc，主要结果截图如下：\n\n图一：\n\n![](http://i.imgur.com/qNT1t9t.png)\n\n图二：\n\n![](http://i.imgur.com/0TKtzCp.png)\n\n关注图一，主要是说明两个TYPESPEC，以parse restype spec chunk...开始解析，第一块的type_name:attr，没有元素，所以\nentryCount=0；第二块的type_name:drawable，留意下entryCount=2，有两个元素，所以对应有两个TYPETYPE，这里是以parse restype info chunk...开始解析，这个也很好理解，因为demo是有两张图片，分别是ic_launcher和test，对应的是drawable-mdpi文件下的文件描述；</br>\n\n这时候关注下图二，这个是另外两个TYPETYPE chunk的截图，自然而然想到的是另外两个drawable的文件资源描述，图中每个圈是每一个entry，entry中的index是对应package chunk中资源项名称字符串池的字符串偏移值，解析出来的字符串时str:ic_launcher，value中的data其实是在 字符串资源池（TYPE_STRING）解析出来的数据，在内部也是通过一个偏移值去获取该值；图二还有一个细节，也是困扰小弟几天的问题，就是即使在drawable-mdpi文件下没有test.png，在其数据结构的trunk中的entryCount=2，而在具体的entry中datatype=TYPR_NULL,这就很好地理解了AndResGuard中替换资源名字的方法，保持每个resId的唯一性，同时也可以针对具体的配置进行文件名替换。</br>\n\n至此，最后的两个chunk也介绍完毕。归结而言，就是每个资源类型对应一个TYPESPEC，而紧跟每一种类型的就是其类型所包含的配置，每个配置就是对应一个TYPETYPE。\n\n\n# 关注AndResGuard #\n\n大概了解了resources.arsc结构，去了解AndResGuard混淆资源的方案就应该更为清晰了，简单看下替换方案：\n\n![](http://i.imgur.com/Z6EDzF0.png)\n\n首先，我们其实修改的是资源文件名(a.png)和资源文件的路径名（r\\a\\a.png），这样对应修改的就是TYPEPACKAGE和TYPE_STRING（对应方案1和3），而最后我们介绍的TYPETYPE和TYPESPEC是分别有TYPEPACKAGE和TYPE_STRING的字符串偏移值，这样对应也需要做修改（对应方案4），当然，缩短了文件命名必然会对整个table的大小造成改变，所以要重新计算并写入新的resources.arsc（对应方案5），结合源码分析，可能会有更深的理解。</br>\n\n由于本人没有对resources.arsc做整体的透彻理解，只是在AndResGuard项目基础上去选择性关注要修改的点，如果在分析过程中有出现纰漏或者错误的地方，希望指出。\n\n参考资料：\n[http://blog.csdn.net/jiangwei0910410003/article/details/50628894](http://blog.csdn.net/jiangwei0910410003/article/details/50628894)\n[http://www.cnblogs.com/njxxdx/p/4189971.html](http://www.cnblogs.com/njxxdx/p/4189971.html)\n\n\n\n","slug":"Resource.arsc文件格式","published":1,"updated":"2016-06-14T10:06:01.349Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cisn9io3p000164vi4me0qlih","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>在研究资源混淆的过程中了解到微信的资源混淆工具–<a href=\"https://github.com/shwenzhang/AndResGuard\" target=\"_blank\" rel=\"external\">AndResGuard</a>，这个工具的强大之处不仅仅在于混淆了冗余的资源文件名称和明显减少apk的大小（这是官方说明，小弟小试了下效果不明显，有待考证），同时不涉及生成apk的编译流程，只需要输入apk和一些命令参数即可生成所需的混淆资源后的apk。<a id=\"more\"></a><br>（美团也有一套混淆资源的方法，介绍是修改AAPT处理资源文件相关的源码，牛逼哄哄的样子：<a href=\"http://tech.meituan.com/mt-android-resource-obfuscation.html\" target=\"_blank\" rel=\"external\">没错，我是链接</a>）。Anyway，对于追求完美的技术人员而言，并不能满足于一个现成的工具，了解其中原理加以修改才可以灵活运用。AndResGuard主要是通过修改resources.arsc文件来打到混淆的目的，因此，本文主要是对resources.arsc的文件格式进行阐述。<br>至于详细的实现方案和流程可参考<a href=\"http://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=208135658&amp;idx=1&amp;sn=ac9bd6b4927e9e82f9fa14e396183a8f#rd\" target=\"_blank\" rel=\"external\">AndResGuard原理</a></p>\n<h1 id=\"数据结构总体介绍\"><a href=\"#数据结构总体介绍\" class=\"headerlink\" title=\"数据结构总体介绍\"></a>数据结构总体介绍</h1><p>resources.arsc文件格式是由一系列的chunk构成。总体而言，可以大致分为五个chunk，分别是TYPETABLE，TYPEPACKAGE，TYPE_STRING， TYPETYPE和TYPESPEC；而这些chunk组成的结构就是资源索引表头部+字符串资源池+N个Package数据块。贴上一张传烂的图：</p>\n<p><img src=\"http://i.imgur.com/UVU3hWW.png\" alt=\"\"></p>\n<p>是的，看完这图我也是懵逼的。没关系，下面作一个详细点的介绍。</p>\n<h1 id=\"头部信息\"><a href=\"#头部信息\" class=\"headerlink\" title=\"头部信息\"></a>头部信息</h1><p>在介绍每个chunk之前，先说明下每个chunk均包含一个ResChunk_header的头部信息，具体的数据定义如下：</p>\n<pre><code>struct ResChunk_header\n{\n// 是当前这个chunk的类型\nuint16_t type;\n\n// 是当前这个chunk的头部大小\nuint16_t headerSize;\n\n// 是当前这个chunk的大小\nuint32_t size;\n};\n</code></pre><p>从上面的结构图可以看到，每一个chunk均是以ResChunk_header作为开头，在下面的介绍中，将会跳过。</p>\n<h1 id=\"资源索引表头部（TYPETABLE）\"><a href=\"#资源索引表头部（TYPETABLE）\" class=\"headerlink\" title=\"资源索引表头部（TYPETABLE）\"></a>资源索引表头部（TYPETABLE）</h1><p><img src=\"http://i.imgur.com/K76gXh0.png\" alt=\"\"></p>\n<p>可以看到，除了头部信息，还有一个package数的数据，一个apk可能包含多个资源包，这里就是指被编译的资源包个数。具体体现在有多少个TYPEPACKAGE。</p>\n<h1 id=\"字符串资源池（TYPE-STRING）\"><a href=\"#字符串资源池（TYPE-STRING）\" class=\"headerlink\" title=\"字符串资源池（TYPE_STRING）\"></a>字符串资源池（TYPE_STRING）</h1><p><img src=\"http://i.imgur.com/zWKmKf3.png\" alt=\"\"></p>\n<p>紧接着资源索引表头部的就是字符串资源池，这个chunk包含了所有package里定义的字符串。这个chunk的数据结构比较重要，在后面的TYPEPACKAGE里也包含着这一种chunk的数据结构，同时也是AndResGuard其中做修改数据的位置。下面简略地看下其数据结构介绍：</p>\n<h3 id=\"ResStringPool-header\"><a href=\"#ResStringPool-header\" class=\"headerlink\" title=\"ResStringPool_header\"></a>ResStringPool_header</h3><p>header：标准的Chunk头部信息结构<br><br>stringCount：字符串的个数<br><br>styleCount：字符串样式的个数<br><br>flags：字符串的属性,可取值包括0x000(UTF-16),0x001(字符串经过排序)、0X100(UTF-8)和他们的组合值<br><br>stringStart：字符串内容块相对于其头部的距离<br><br>stylesStart：字符串样式块相对于其头部的距离</p>\n<h3 id=\"两个Array和两个Content\"><a href=\"#两个Array和两个Content\" class=\"headerlink\" title=\"两个Array和两个Content\"></a>两个Array和两个Content</h3><p>紧接着ResStringPool_header就是字符串偏移数组和字符串样式偏移数组，字符串偏移数组每个元素记录着每个字符串相对于StringContent（图中数据‘字符串’）开始的索引；同样的，字符串样式偏移数组每个元素记录着每个字符串相对于StyleContent（图中数据‘style’）开始的索引。</p>\n<p>整个字符串资源区的结构示意图：</p>\n<p><img src=\"http://i.imgur.com/pV5kgSm.png\" alt=\"\"></p>\n<h1 id=\"Package数据块（TYPEPACKAGE）\"><a href=\"#Package数据块（TYPEPACKAGE）\" class=\"headerlink\" title=\"Package数据块（TYPEPACKAGE）\"></a>Package数据块（TYPEPACKAGE）</h1><p>在资源索引表头部中指定了package数目，所以，在这里开始，package数据块（包含TYPETYPE和TYPESPEC）是一个紧接着一个（假如有多个package）。<br><br>下面，先介绍下TYPEPACKAGE这个chunk的数据结构：</p>\n<p><img src=\"http://i.imgur.com/p0g4EWp.png\" alt=\"\"></p>\n<h3 id=\"ResTable-package\"><a href=\"#ResTable-package\" class=\"headerlink\" title=\"ResTable_package\"></a>ResTable_package</h3><p>header：Chunk的头部信息数据结构<br><br>id：包的ID,等于Package Id,一般用户包的值Package Id为0X7F,系统资源包的Package Id为0X01<br><br>name：包名<br><br>typeString：类型字符串资源池相对头部的偏移<br><br>lastPublicType：最后一个导出的Public类型字符串在类型字符串资源池中的索引，目前这个值设置为类型字符串资源池的元素个数。在解析的过程中没发现他的用途<br><br>keyStrings：资源项名称字符串相对头部的偏移<br><br>lastPublicKey：最后一个导出的Public资源项名称字符串在资源项名称字符串资源池中的索引，目前这个值设置为资源项名称字符串资源池的元素个数。在解析的过程中没发现他的用途</p>\n<h3 id=\"Type-String-Pool-amp-Key-String-Pool\"><a href=\"#Type-String-Pool-amp-Key-String-Pool\" class=\"headerlink\" title=\"Type String Pool &amp; Key String Pool\"></a>Type String Pool &amp; Key String Pool</h3><p>紧接着ResTable_package的是两个与字符串资源池有相同结构的字符串资源池，区别在于这里的资源池只是包含当前package的资源。</p>\n<p>Type String Pool（图中数据‘资源类型字符串池’）是一个package中用到的类型字符串，如：anim，id，layout；</p>\n<p>Key String Pool（图中数据‘资源项名称字符串池’），比如string.xml内容如下：</p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;resources&gt;\n&lt;string name=&quot;app_name&quot;&gt;Test&lt;/string&gt;\n&lt;string name=&quot;hello_world&quot;&gt;Hello world!&lt;/string&gt;\n&lt;string name=&quot;action_settings&quot;&gt;Settings&lt;/string&gt;\n&lt;/resources&gt;\n</code></pre><p>那么这个pool就收集了app_name，hello_world   action_settings 这3个字符串。这个pool是AndResGuard作修改的一处位置。</p>\n<p>整个Package数据块区的结构示意图：</p>\n<p><img src=\"http://i.imgur.com/Mhj3UOF.png\" alt=\"\"></p>\n<p>可以看到，在紧接着Type String Pool和Key String Pool后是剩下的两个chunk，在这里Type Specification Trunk和Type Info Trunk分别对应 TYPESPEC和TYPETYPE，下面作详细介绍。</p>\n<h1 id=\"类型规范数据块（TYPESPEC）-amp-资源类型项数据块（TYPETYPE）\"><a href=\"#类型规范数据块（TYPESPEC）-amp-资源类型项数据块（TYPETYPE）\" class=\"headerlink\" title=\"类型规范数据块（TYPESPEC） &amp; 资源类型项数据块（TYPETYPE）\"></a>类型规范数据块（TYPESPEC） &amp; 资源类型项数据块（TYPETYPE）</h1><p>先来看一段TYPESPEC的介绍：</p>\n<pre><code>类型规范数据块用来描述资源项的配置差异性。通过这个差异性描述，我们就可以知道每一个资源项的配置状况。知道了一个资源项的配置状况之后，Android资源管理框架在检测到设备的配置信息发生变化之后，就可以知道是否需要重新加载该资源项。类型规范数据块是按照类型来组织的，也就是说，每一种类型都对应有一个类型规范数据块。\n</code></pre><p><img src=\"http://i.imgur.com/ERotuBl.png\" alt=\"\"></p>\n<p>国际惯例，大概了解下其数据结构：</p>\n<pre><code>header：Chunk的头部信息结构\nid：标识资源的Type ID,Type ID是指资源的类型ID。资源的类型有animator、anim、color、drawable、layout、menu、raw、string和xml等等若干种，每一种都会被赋予一个ID。\nres0：保留,始终为0\nres1：保留,始终为0\nentryCount：等于本类型的资源项个数,指名称相同的资源项的个数。\n</code></pre><p>再来一段TYPETYPE的介绍：</p>\n<pre><code>类型资源项数据块用来描述资源项的具体信息, 这样我们就可以知道每一个资源项的名称、值和配置等信息。 类型资源项数据同样是按照类型和配置来组织的,也就是说,一个具有n个配置的类型一共对应有n个类型资源项数据块。\n</code></pre><p><img src=\"http://i.imgur.com/VBljfg6.png\" alt=\"\"></p>\n<p>TYPETYPE的数据结构：</p>\n<pre><code>header：Chunk的头部信息结构\nid：标识资源的Type ID\nres0：保留,始终为0\nres1：保留,始终为0\nentryCount：等于本类型的资源项个数,指名称相同的资源项的个数。\nentriesStart：等于资源项数据块相对头部的偏移值。\nresConfig：指向一个ResTable_config,用来描述配置信息,地区,语言,分辨率等\n</code></pre><p>注意下的是，这里两个chunk的id均是标识资源的id，这里是指类似drawable和anim等类型，其他字段在这里不做介绍，结合AndResGuard重点介绍的是紧跟TYPETYPE后的ResTable_entry数组，这个数组是指具体每个元素的配置解释，而这里也是AndResGuard需要做修改的其中两个地方。</p>\n<p>说实话，看到两段描述的时候有点混乱，查阅资料和说明例子后以为理解了，结合AndResGuard源码尝试去理解更换两个chunk数据，又陷入了无限的懵逼状态。归根结底，是不能理解类型和配置是如何进行映射。毛爷爷说过，实践是检验真理的唯一标准，于是乎，小弟写了个简单的helloworld的demo，主要截上资源配置：</p>\n<p><img src=\"http://i.imgur.com/4AZ99ZF.png\" alt=\"\"></p>\n<p>这里要留意两点，一是类型drawable有三种配置，分别是drawable-hdpi，drawable-mdpi和drawable-xhdpi，这三个配置里均有ic_launcher.png；第二点是，在drawable-mdpi文件下有test.png。</p>\n<p>然后就开始解析里面的resources.arsc，主要结果截图如下：</p>\n<p>图一：</p>\n<p><img src=\"http://i.imgur.com/qNT1t9t.png\" alt=\"\"></p>\n<p>图二：</p>\n<p><img src=\"http://i.imgur.com/0TKtzCp.png\" alt=\"\"></p>\n<p>关注图一，主要是说明两个TYPESPEC，以parse restype spec chunk…开始解析，第一块的type_name:attr，没有元素，所以<br>entryCount=0；第二块的type_name:drawable，留意下entryCount=2，有两个元素，所以对应有两个TYPETYPE，这里是以parse restype info chunk…开始解析，这个也很好理解，因为demo是有两张图片，分别是ic_launcher和test，对应的是drawable-mdpi文件下的文件描述；<br></p>\n<p>这时候关注下图二，这个是另外两个TYPETYPE chunk的截图，自然而然想到的是另外两个drawable的文件资源描述，图中每个圈是每一个entry，entry中的index是对应package chunk中资源项名称字符串池的字符串偏移值，解析出来的字符串时str:ic_launcher，value中的data其实是在 字符串资源池（TYPE_STRING）解析出来的数据，在内部也是通过一个偏移值去获取该值；图二还有一个细节，也是困扰小弟几天的问题，就是即使在drawable-mdpi文件下没有test.png，在其数据结构的trunk中的entryCount=2，而在具体的entry中datatype=TYPR_NULL,这就很好地理解了AndResGuard中替换资源名字的方法，保持每个resId的唯一性，同时也可以针对具体的配置进行文件名替换。<br></p>\n<p>至此，最后的两个chunk也介绍完毕。归结而言，就是每个资源类型对应一个TYPESPEC，而紧跟每一种类型的就是其类型所包含的配置，每个配置就是对应一个TYPETYPE。</p>\n<h1 id=\"关注AndResGuard\"><a href=\"#关注AndResGuard\" class=\"headerlink\" title=\"关注AndResGuard\"></a>关注AndResGuard</h1><p>大概了解了resources.arsc结构，去了解AndResGuard混淆资源的方案就应该更为清晰了，简单看下替换方案：</p>\n<p><img src=\"http://i.imgur.com/Z6EDzF0.png\" alt=\"\"></p>\n<p>首先，我们其实修改的是资源文件名(a.png)和资源文件的路径名（r\\a\\a.png），这样对应修改的就是TYPEPACKAGE和TYPE_STRING（对应方案1和3），而最后我们介绍的TYPETYPE和TYPESPEC是分别有TYPEPACKAGE和TYPE_STRING的字符串偏移值，这样对应也需要做修改（对应方案4），当然，缩短了文件命名必然会对整个table的大小造成改变，所以要重新计算并写入新的resources.arsc（对应方案5），结合源码分析，可能会有更深的理解。<br></p>\n<p>由于本人没有对resources.arsc做整体的透彻理解，只是在AndResGuard项目基础上去选择性关注要修改的点，如果在分析过程中有出现纰漏或者错误的地方，希望指出。</p>\n<p>参考资料：<br><a href=\"http://blog.csdn.net/jiangwei0910410003/article/details/50628894\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/jiangwei0910410003/article/details/50628894</a><br><a href=\"http://www.cnblogs.com/njxxdx/p/4189971.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/njxxdx/p/4189971.html</a></p>\n","excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>在研究资源混淆的过程中了解到微信的资源混淆工具–<a href=\"https://github.com/shwenzhang/AndResGuard\">AndResGuard</a>，这个工具的强大之处不仅仅在于混淆了冗余的资源文件名称和明显减少apk的大小（这是官方说明，小弟小试了下效果不明显，有待考证），同时不涉及生成apk的编译流程，只需要输入apk和一些命令参数即可生成所需的混淆资源后的apk。","more":"<br>（美团也有一套混淆资源的方法，介绍是修改AAPT处理资源文件相关的源码，牛逼哄哄的样子：<a href=\"http://tech.meituan.com/mt-android-resource-obfuscation.html\">没错，我是链接</a>）。Anyway，对于追求完美的技术人员而言，并不能满足于一个现成的工具，了解其中原理加以修改才可以灵活运用。AndResGuard主要是通过修改resources.arsc文件来打到混淆的目的，因此，本文主要是对resources.arsc的文件格式进行阐述。<br>至于详细的实现方案和流程可参考<a href=\"http://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=208135658&amp;idx=1&amp;sn=ac9bd6b4927e9e82f9fa14e396183a8f#rd\">AndResGuard原理</a></p>\n<h1 id=\"数据结构总体介绍\"><a href=\"#数据结构总体介绍\" class=\"headerlink\" title=\"数据结构总体介绍\"></a>数据结构总体介绍</h1><p>resources.arsc文件格式是由一系列的chunk构成。总体而言，可以大致分为五个chunk，分别是TYPETABLE，TYPEPACKAGE，TYPE_STRING， TYPETYPE和TYPESPEC；而这些chunk组成的结构就是资源索引表头部+字符串资源池+N个Package数据块。贴上一张传烂的图：</p>\n<p><img src=\"http://i.imgur.com/UVU3hWW.png\" alt=\"\"></p>\n<p>是的，看完这图我也是懵逼的。没关系，下面作一个详细点的介绍。</p>\n<h1 id=\"头部信息\"><a href=\"#头部信息\" class=\"headerlink\" title=\"头部信息\"></a>头部信息</h1><p>在介绍每个chunk之前，先说明下每个chunk均包含一个ResChunk_header的头部信息，具体的数据定义如下：</p>\n<pre><code>struct ResChunk_header\n{\n// 是当前这个chunk的类型\nuint16_t type;\n\n// 是当前这个chunk的头部大小\nuint16_t headerSize;\n\n// 是当前这个chunk的大小\nuint32_t size;\n};\n</code></pre><p>从上面的结构图可以看到，每一个chunk均是以ResChunk_header作为开头，在下面的介绍中，将会跳过。</p>\n<h1 id=\"资源索引表头部（TYPETABLE）\"><a href=\"#资源索引表头部（TYPETABLE）\" class=\"headerlink\" title=\"资源索引表头部（TYPETABLE）\"></a>资源索引表头部（TYPETABLE）</h1><p><img src=\"http://i.imgur.com/K76gXh0.png\" alt=\"\"></p>\n<p>可以看到，除了头部信息，还有一个package数的数据，一个apk可能包含多个资源包，这里就是指被编译的资源包个数。具体体现在有多少个TYPEPACKAGE。</p>\n<h1 id=\"字符串资源池（TYPE-STRING）\"><a href=\"#字符串资源池（TYPE-STRING）\" class=\"headerlink\" title=\"字符串资源池（TYPE_STRING）\"></a>字符串资源池（TYPE_STRING）</h1><p><img src=\"http://i.imgur.com/zWKmKf3.png\" alt=\"\"></p>\n<p>紧接着资源索引表头部的就是字符串资源池，这个chunk包含了所有package里定义的字符串。这个chunk的数据结构比较重要，在后面的TYPEPACKAGE里也包含着这一种chunk的数据结构，同时也是AndResGuard其中做修改数据的位置。下面简略地看下其数据结构介绍：</p>\n<h3 id=\"ResStringPool-header\"><a href=\"#ResStringPool-header\" class=\"headerlink\" title=\"ResStringPool_header\"></a>ResStringPool_header</h3><p>header：标准的Chunk头部信息结构</br><br>stringCount：字符串的个数</br><br>styleCount：字符串样式的个数</br><br>flags：字符串的属性,可取值包括0x000(UTF-16),0x001(字符串经过排序)、0X100(UTF-8)和他们的组合值</br><br>stringStart：字符串内容块相对于其头部的距离</br><br>stylesStart：字符串样式块相对于其头部的距离</p>\n<h3 id=\"两个Array和两个Content\"><a href=\"#两个Array和两个Content\" class=\"headerlink\" title=\"两个Array和两个Content\"></a>两个Array和两个Content</h3><p>紧接着ResStringPool_header就是字符串偏移数组和字符串样式偏移数组，字符串偏移数组每个元素记录着每个字符串相对于StringContent（图中数据‘字符串’）开始的索引；同样的，字符串样式偏移数组每个元素记录着每个字符串相对于StyleContent（图中数据‘style’）开始的索引。</p>\n<p>整个字符串资源区的结构示意图：</p>\n<p><img src=\"http://i.imgur.com/pV5kgSm.png\" alt=\"\"></p>\n<h1 id=\"Package数据块（TYPEPACKAGE）\"><a href=\"#Package数据块（TYPEPACKAGE）\" class=\"headerlink\" title=\"Package数据块（TYPEPACKAGE）\"></a>Package数据块（TYPEPACKAGE）</h1><p>在资源索引表头部中指定了package数目，所以，在这里开始，package数据块（包含TYPETYPE和TYPESPEC）是一个紧接着一个（假如有多个package）。</br><br>下面，先介绍下TYPEPACKAGE这个chunk的数据结构：</p>\n<p><img src=\"http://i.imgur.com/p0g4EWp.png\" alt=\"\"></p>\n<h3 id=\"ResTable-package\"><a href=\"#ResTable-package\" class=\"headerlink\" title=\"ResTable_package\"></a>ResTable_package</h3><p>header：Chunk的头部信息数据结构</br><br>id：包的ID,等于Package Id,一般用户包的值Package Id为0X7F,系统资源包的Package Id为0X01</br><br>name：包名</br><br>typeString：类型字符串资源池相对头部的偏移</br><br>lastPublicType：最后一个导出的Public类型字符串在类型字符串资源池中的索引，目前这个值设置为类型字符串资源池的元素个数。在解析的过程中没发现他的用途</br><br>keyStrings：资源项名称字符串相对头部的偏移</br><br>lastPublicKey：最后一个导出的Public资源项名称字符串在资源项名称字符串资源池中的索引，目前这个值设置为资源项名称字符串资源池的元素个数。在解析的过程中没发现他的用途</p>\n<h3 id=\"Type-String-Pool-amp-Key-String-Pool\"><a href=\"#Type-String-Pool-amp-Key-String-Pool\" class=\"headerlink\" title=\"Type String Pool &amp; Key String Pool\"></a>Type String Pool &amp; Key String Pool</h3><p>紧接着ResTable_package的是两个与字符串资源池有相同结构的字符串资源池，区别在于这里的资源池只是包含当前package的资源。</p>\n<p>Type String Pool（图中数据‘资源类型字符串池’）是一个package中用到的类型字符串，如：anim，id，layout；</p>\n<p>Key String Pool（图中数据‘资源项名称字符串池’），比如string.xml内容如下：</p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;resources&gt;\n&lt;string name=&quot;app_name&quot;&gt;Test&lt;/string&gt;\n&lt;string name=&quot;hello_world&quot;&gt;Hello world!&lt;/string&gt;\n&lt;string name=&quot;action_settings&quot;&gt;Settings&lt;/string&gt;\n&lt;/resources&gt;\n</code></pre><p>那么这个pool就收集了app_name，hello_world   action_settings 这3个字符串。这个pool是AndResGuard作修改的一处位置。</p>\n<p>整个Package数据块区的结构示意图：</p>\n<p><img src=\"http://i.imgur.com/Mhj3UOF.png\" alt=\"\"></p>\n<p>可以看到，在紧接着Type String Pool和Key String Pool后是剩下的两个chunk，在这里Type Specification Trunk和Type Info Trunk分别对应 TYPESPEC和TYPETYPE，下面作详细介绍。</p>\n<h1 id=\"类型规范数据块（TYPESPEC）-amp-资源类型项数据块（TYPETYPE）\"><a href=\"#类型规范数据块（TYPESPEC）-amp-资源类型项数据块（TYPETYPE）\" class=\"headerlink\" title=\"类型规范数据块（TYPESPEC） &amp; 资源类型项数据块（TYPETYPE）\"></a>类型规范数据块（TYPESPEC） &amp; 资源类型项数据块（TYPETYPE）</h1><p>先来看一段TYPESPEC的介绍：</p>\n<pre><code>类型规范数据块用来描述资源项的配置差异性。通过这个差异性描述，我们就可以知道每一个资源项的配置状况。知道了一个资源项的配置状况之后，Android资源管理框架在检测到设备的配置信息发生变化之后，就可以知道是否需要重新加载该资源项。类型规范数据块是按照类型来组织的，也就是说，每一种类型都对应有一个类型规范数据块。\n</code></pre><p><img src=\"http://i.imgur.com/ERotuBl.png\" alt=\"\"></p>\n<p>国际惯例，大概了解下其数据结构：</p>\n<pre><code>header：Chunk的头部信息结构\nid：标识资源的Type ID,Type ID是指资源的类型ID。资源的类型有animator、anim、color、drawable、layout、menu、raw、string和xml等等若干种，每一种都会被赋予一个ID。\nres0：保留,始终为0\nres1：保留,始终为0\nentryCount：等于本类型的资源项个数,指名称相同的资源项的个数。\n</code></pre><p>再来一段TYPETYPE的介绍：</p>\n<pre><code>类型资源项数据块用来描述资源项的具体信息, 这样我们就可以知道每一个资源项的名称、值和配置等信息。 类型资源项数据同样是按照类型和配置来组织的,也就是说,一个具有n个配置的类型一共对应有n个类型资源项数据块。\n</code></pre><p><img src=\"http://i.imgur.com/VBljfg6.png\" alt=\"\"></p>\n<p>TYPETYPE的数据结构：</p>\n<pre><code>header：Chunk的头部信息结构\nid：标识资源的Type ID\nres0：保留,始终为0\nres1：保留,始终为0\nentryCount：等于本类型的资源项个数,指名称相同的资源项的个数。\nentriesStart：等于资源项数据块相对头部的偏移值。\nresConfig：指向一个ResTable_config,用来描述配置信息,地区,语言,分辨率等\n</code></pre><p>注意下的是，这里两个chunk的id均是标识资源的id，这里是指类似drawable和anim等类型，其他字段在这里不做介绍，结合AndResGuard重点介绍的是紧跟TYPETYPE后的ResTable_entry数组，这个数组是指具体每个元素的配置解释，而这里也是AndResGuard需要做修改的其中两个地方。</p>\n<p>说实话，看到两段描述的时候有点混乱，查阅资料和说明例子后以为理解了，结合AndResGuard源码尝试去理解更换两个chunk数据，又陷入了无限的懵逼状态。归根结底，是不能理解类型和配置是如何进行映射。毛爷爷说过，实践是检验真理的唯一标准，于是乎，小弟写了个简单的helloworld的demo，主要截上资源配置：</p>\n<p><img src=\"http://i.imgur.com/4AZ99ZF.png\" alt=\"\"></p>\n<p>这里要留意两点，一是类型drawable有三种配置，分别是drawable-hdpi，drawable-mdpi和drawable-xhdpi，这三个配置里均有ic_launcher.png；第二点是，在drawable-mdpi文件下有test.png。</p>\n<p>然后就开始解析里面的resources.arsc，主要结果截图如下：</p>\n<p>图一：</p>\n<p><img src=\"http://i.imgur.com/qNT1t9t.png\" alt=\"\"></p>\n<p>图二：</p>\n<p><img src=\"http://i.imgur.com/0TKtzCp.png\" alt=\"\"></p>\n<p>关注图一，主要是说明两个TYPESPEC，以parse restype spec chunk…开始解析，第一块的type_name:attr，没有元素，所以<br>entryCount=0；第二块的type_name:drawable，留意下entryCount=2，有两个元素，所以对应有两个TYPETYPE，这里是以parse restype info chunk…开始解析，这个也很好理解，因为demo是有两张图片，分别是ic_launcher和test，对应的是drawable-mdpi文件下的文件描述；</br></p>\n<p>这时候关注下图二，这个是另外两个TYPETYPE chunk的截图，自然而然想到的是另外两个drawable的文件资源描述，图中每个圈是每一个entry，entry中的index是对应package chunk中资源项名称字符串池的字符串偏移值，解析出来的字符串时str:ic_launcher，value中的data其实是在 字符串资源池（TYPE_STRING）解析出来的数据，在内部也是通过一个偏移值去获取该值；图二还有一个细节，也是困扰小弟几天的问题，就是即使在drawable-mdpi文件下没有test.png，在其数据结构的trunk中的entryCount=2，而在具体的entry中datatype=TYPR_NULL,这就很好地理解了AndResGuard中替换资源名字的方法，保持每个resId的唯一性，同时也可以针对具体的配置进行文件名替换。</br></p>\n<p>至此，最后的两个chunk也介绍完毕。归结而言，就是每个资源类型对应一个TYPESPEC，而紧跟每一种类型的就是其类型所包含的配置，每个配置就是对应一个TYPETYPE。</p>\n<h1 id=\"关注AndResGuard\"><a href=\"#关注AndResGuard\" class=\"headerlink\" title=\"关注AndResGuard\"></a>关注AndResGuard</h1><p>大概了解了resources.arsc结构，去了解AndResGuard混淆资源的方案就应该更为清晰了，简单看下替换方案：</p>\n<p><img src=\"http://i.imgur.com/Z6EDzF0.png\" alt=\"\"></p>\n<p>首先，我们其实修改的是资源文件名(a.png)和资源文件的路径名（r\\a\\a.png），这样对应修改的就是TYPEPACKAGE和TYPE_STRING（对应方案1和3），而最后我们介绍的TYPETYPE和TYPESPEC是分别有TYPEPACKAGE和TYPE_STRING的字符串偏移值，这样对应也需要做修改（对应方案4），当然，缩短了文件命名必然会对整个table的大小造成改变，所以要重新计算并写入新的resources.arsc（对应方案5），结合源码分析，可能会有更深的理解。</br></p>\n<p>由于本人没有对resources.arsc做整体的透彻理解，只是在AndResGuard项目基础上去选择性关注要修改的点，如果在分析过程中有出现纰漏或者错误的地方，希望指出。</p>\n<p>参考资料：<br><a href=\"http://blog.csdn.net/jiangwei0910410003/article/details/50628894\">http://blog.csdn.net/jiangwei0910410003/article/details/50628894</a><br><a href=\"http://www.cnblogs.com/njxxdx/p/4189971.html\">http://www.cnblogs.com/njxxdx/p/4189971.html</a></p>"},{"title":"简析DroidPlugin之Hook","date":"2016-09-03T13:58:46.743Z","_content":"\n# 前言 #\n被誉为“安卓黑科技”的开源框架DroidPlugin，是目前较为流行的安卓动态加载技术的典范。免安装和免修改运行第三方sdk，实现多团队协助开发，是360推出这个牛逼able框架的主打亮点。那么，它是如何一步步去实现这个神奇的框架的呢？又和我们常见的动态加载技术有何区别去值得我们学习的？由于目前国内对这个框架没太多的研究，很多地方只能做到点到即止。本文主要分享其hook的过程。<!-- more -->\n\n## 了解入口架构 ##\n\n首先，看到application的attachBaseContext方法里面做了这样一步：\n\n\t# PluginApplication.java\n\n    PluginHelper.getInstance().applicationAttachBaseContext(base);\n\n这一步并没有做太多操作，只是注册了crash之后的log发送之类的信息。这里不展开细说。\n\n在onCreate方法里有：\n\n\t# PluginApplication.java\n\n    PluginHelper.getInstance().applicationOnCreate(getBaseContext());\n\n这一步是核心操作，进行了一系列的初始化，本文也是从这里开始展开。跟代码找到了initPlugin方法：\n\n\t# PluginHelper.java\n\n    private void initPlugin(Context baseContext) {\n        long b = System.currentTimeMillis();\n        try {\n            try {\n                fixMiUiLbeSecurity();\n            } catch (Throwable e) {\n                Log.e(TAG, \"fixMiUiLbeSecurity has error\", e);\n            }\n \n            try {\n                PluginProcessManager.installHook(baseContext);\n            } catch (Throwable e) {\n                Log.e(TAG, \"installHook has error\", e);\n            }\n \t\t......\n    }\n\n看到了 PluginProcessManager.installHook(baseContext); 这是安装钩子函数（hook）相关的入口。接着往下看：\n\n\t# HookFactory.java\n\n    public final void installHook(Context context, ClassLoader classLoader) throws Throwable {\n        installHook(new IClipboardBinderHook(context), classLoader);\n        //for ISearchManager\n        installHook(new ISearchManagerBinderHook(context), classLoader);\n        //for INotificationManager\n        installHook(new INotificationManagerBinderHook(context), classLoader);\n \t\t..........\n \n        installHook(new IPackageManagerHook(context), classLoader);\n        installHook(new IActivityManagerHook(context), classLoader);\n        installHook(new PluginCallbackHook(context), classLoader);\n\t\t.......\n    }\n\n很明显，这里做了一系列系统组件的hook操作，这里以\n\n\t# HookFactory.java\n\n    installHook(new IActivityManagerHook(context), classLoader);\n\n为例，实例化 IActivityManagerHook ，这个类继承谁呢？查看该类hook的体系结构：\n\n    Hook\n    --| ProxyHook\n    ----| IActivityManagerHook\n\n基类Hook.java构造方法做了两步操作，一是初始化了hostContext，二是创建hookHandle：\n\n\t# Hook.java\n\t\n    protected Hook(Context hostContext) {\n        mHostContext = hostContext;\n        mHookHandles = createHookHandle();\n    }\n\n跟着代码走到了IActivityManagerHookHandle的init()方法。咦，代码看上去貌似很长，其实就是用一个Map去存放方法名和对应操作的键值对，这里先有个概念，后面会用到。\n\nIActivityManagerHook实例化完之后，就是installHook的方法，先贴上代码：\n\n\t# HookFactory.java \n\n    public void installHook(Hook hook, ClassLoader cl) {\n        try {\n            hook.onInstall(cl);\n            synchronized (mHookList) {\n                mHookList.add(hook);\n            }\n        } catch (Throwable throwable) {\n            Log.e(TAG, \"installHook %s error\", throwable, hook);\n        }\n    }\n\n首先，这里对刚才实例化的hook调用了onInstall方法，并传入一个classLoder，这里为空；然后把hook添加到一个List集合中去。我们看一下IActivityManagerHook的onInstall方法的前半部分：\n\n\t# IActivityManagerHook.java\n\n    public void onInstall(ClassLoader classLoader) throws Throwable {\n    \tClass cls = ActivityManagerNativeCompat.Class();\n    \tObject obj = FieldUtils.readStaticField(cls, \"gDefault\");\n   \t \tif (obj == null) {\n    \t\tActivityManagerNativeCompat.getDefault();\n    \t\tobj = FieldUtils.readStaticField(cls, \"gDefault\");\n   \t\t }\n    \n    \t.............\n    }\n\n整个onInstall方法做了两件事情：</br>\n1.找到系统的IActivityManager;</br>\n2.判断该IActivityManager是否为单例，做不同的处理\n\n## 找到Hook对象 ##\n\n我们看一下在IAcitivityManager里面\"gDefault\"这个变量是干嘛的，贴源码：\n\n\t# ActivityManagerNative.java\n\n    private static final Singleton<IActivityManager> gDefault = new Singleton<IActivityManager>() {\n        protected IActivityManager create() {\n            IBinder b = ServiceManager.getService(\"activity\");\n            if (false) {\n                Log.v(\"ActivityManager\", \"default service binder = \" + b);\n            }\n            IActivityManager am = asInterface(b);\n            if (false) {\n                Log.v(\"ActivityManager\", \"default service = \" + am);\n            }\n            return am;\n        }\n    };\n\n我们知道，Android中ActivityManager是与系统所有运行着的Activity进行交互，对系统所有运行的Activity进行管理和维护，但是这些信息真正维护并不是由ActivityManager来负责。读起来有点绕，RTFSC是王道，截取其中一段获取运行服务的方法：\n\n\t# ActivityManager.java\n\n    public List<RunningServiceInfo> getRunningServices(int maxNum)\n            throws SecurityException {\n        try {\n            return ActivityManagerNative.getDefault()\n                    .getServices(maxNum, 0);\n        } catch (RemoteException e) {\n            // System dead, we will be dead too soon!\n            return null;\n        }\n    }\n\n通过阅读ActivityManager的源码发现，所有的信息都是通过ActivityManagerNative.getDefault()来操作获取。哎呦，这里面到底是干了啥？我们先来看一幅Activity Manager相关类继承层次关系图：\n\n![](http://i.imgur.com/ToILsf2.jpg)\n\nActivityManagerProxy，见名思意，是一个代理类，同时也是ActivityManagerNative的内部类；ActivityManagerNative是一个抽象类，实现它的是ActivityManagerService，这是一个系统Service组件。\n从图中可以看出，使用ActivityManagerProxy，来代理ActivityManagerNative，实质就是代理它的实现类ActivityManagerService；ActivityManagerService是系统统一的Service，运行在独立的进程中，通过系统ServiceManger来获取。\n\n\n那么，问题来了，ActivityManager运行在一个进程里面，ActivityManagerService运行在另一个进程内，这里面涉及到跨进程的对象访问，毫无疑问，采用的是Binder机制实现。\n\n我们从刚刚截取的ActivityManagerNative.java中定义gDefault的方法可以看到，首先获取“activity”的IBinder\n\n\tIBinder b = ServiceManager.getService(\"activity\");\n\n这个可以从以下源码得知，其中sCache存放的是名字和对应IBinder的键值对Map\n\n\t# ServiceManager.java\n\n    /**\n     * Returns a reference to a service with the given name.\n     * \n     * @param name the name of the service to get\n     * @return a reference to the service, or <code>null</code> if the service doesn't exist\n     */\n    public static IBinder getService(String name) {\n        try {\n            IBinder service = sCache.get(name);\n            if (service != null) {\n                return service;\n            } else {\n                return getIServiceManager().getService(name);\n            }\n        } catch (RemoteException e) {\n            Log.e(TAG, \"error in getService\", e);\n        }\n        return null;\n    }\n\n然后通过 asInterface(b) 就获取了ActivityManagerService实例的本地代理对象ActivityManagerProxy实例：\n\n\n\t# ActivityManagerNative.java\n\n    /**\n     * Cast a Binder object into an activity manager interface, generating\n     * a proxy if needed.\n     */\n    static public IActivityManager asInterface(IBinder obj) {\n        if (obj == null) {\n            return null;\n        }\n        IActivityManager in =\n            (IActivityManager)obj.queryLocalInterface(descriptor);\n        if (in != null) {\n            return in;\n        }\n\n        return new ActivityManagerProxy(obj);\n    }\n\n贴上一图，让你瞬间有豁然开朗的感觉有木有：\n\n![](http://i.imgur.com/Au935XN.jpg)\n\nok，回到我们的最原点，找到系统的IActivityManager要干嘛？当然就是我们的劫持hook了，在说hook之前，要说说动态代理机制。\n\n## 动态代理机制 ##\n\n动态代理，是一种设计模式，可以为其他对象提供一种代理以控制对这个对象的访问。举一个肤浅的栗子：\n\n\n   \tpublic Object invoke( Object proxy, Method method, Object[] args ) throws Throwable   \n      {   \n    //1.在转调具体目标对象之前，可以执行一些功能处理\n\n    //2.转调具体目标对象的方法\n    return method.invoke( proxied, args);  \n    \n    //3.在转调具体目标对象之后，可以执行一些功能处理\n\n      }\n    } \n\n所谓代理，就是首先要获得被代理者的控制权，被代理者在正常调用的时候，代理可以在被代理者的所有方法前或后添加想要的操作。从上图简单地理解，就是在2方法（被代理者）添加1和3方法。可以看一下代理结构图：\n\n![](http://i.imgur.com/s0zRfSt.gif)\n\n在动态代理机制中，有两个重要的类，分别是InvocationHandler和Proxy。我们看一下API帮助文档是怎么对两个类做描述的：\n\nInvocationHandler：\n\n    InvocationHandler is the interface implemented by the invocation handler of a proxy instance. \n    \n    Each proxy instance has an associated invocation handler. When a method is invoked on a proxy instance, the method invocation is encoded and dispatched to the invoke method of its invocation handler.\n\n每一个动态代理类必须要实现InvocationHandler这个接口，而InvocationHandler这个接口只有唯一一个invoke方法：\n    \n    Object invoke(Object proxy, Method method, Object[] args) throws Throwable\n\n    proxy:　　指代我们所代理的那个真实对象\n    method:　 指代的是我们所要调用真实对象的某个方法的Method对象\n    args:　　 指代的是调用真实对象某个方法时接受的参数\n\nProxy：\n\n    Proxy provides static methods for creating dynamic proxy classes and instances, and it is also the superclass of all dynamic proxy classes created by those methods. \n\nProxy这个类的作用是创建一个代理对象的类，它提供了很多方法，在这里我们只需要了解到newProxyInstance 即可：\n\n    public static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h) throws IllegalArgumentException\n    \n    loader:　　  一个ClassLoader对象，定义了由哪个ClassLoader对象来对生成的代理对象进行加载   \n    interfaces:  一个Interface对象的数组，表示的是我将要给我需要代理的对象提供一组什么接口，如果我提供了一组接口给它，那么这个代理对象就宣称实现了该接口(多态)，这样我就能调用这组接口中的方法了\n   \th:　　        一个InvocationHandler对象，表示的是当我这个动态代理对象在调用方法的时候，会关联到哪一个InvocationHandler对象上\n\nok，有了点概念，我们来继续举个具体点的栗子：\n\n定义一个people的接口：\n\n    public interface People{\n    \tpublic void countMoney();\n    }\n\nboss类去实现这个接口：\n\n    public class Boss implements people{\n\t\t@Override\n\t\tpublic void countMoney(){\n\t\t\tsystem.out.println(\"I have too money to burn.\");\n\t\t}\n    } \n\n定义一个代理类workers，前面说到了，每一个代理类必须实现InvocationHandler 这个接口：\n\n\tpublic class Workers implements InvocationHandler{\n\t\t//这个是我们要代理的真实对象\n\t\tprivate Object people;\n\n\t\t//构造方法，给我们要代理的真实对象赋值\n\t\tpublic workers(Object people){\n\t\t\tthis.people = people;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object invoke(Object object, Method method, Object[] args){\n\t\t\t\n\t\t\t//在代理真实对象之前加上一些操作\n\t\t\tsystem.out.println(\"I must word hard because I have no money.\");\n\n\t\t\t//调用真实对象的相关方法\n\t\t\tmethod.invoke(subject, args);\n\n\t\t\t//在代理真实对象之后加上一些操作\n\t\t\tsystem.out.println(\"Whether you have got money or not,it's wise for you to go back home for the Spring Festival.\");\n\t\t}\n\t} \n\n编写测试类：\n\n\tpublic class test{\n\t\t....\n\t\tBoss boss = new Boss;\n\t\tInvocationHandle handle = new Workers(boss);\n\t\tWorkers workers = (Workers) Proxy.newProxyInstance(handle.getClass().getClassLoader(),boss.getClass().getInterfaces(),handle);\n\t\t\n\t\tworkers.countMoney();\n\t\t\n\t}\n\n看一下输出结果：\n\n    I must word hard because I have no money.\n    I have too money to burn.\n    Whether you have got money or not,it's wise for you to go back home for the Spring Festival.\n\n结果很明显了，如果想了解其中的跳转原理，请查看源码，这里就不多作介绍了。\n\n## 开始Hook ##\n我们来看看onInstall方法的后半部分：\n\n\t# IActivityManagerHook.java\n\n\tpublic void onInstall(ClassLoader classLoader) throws Throwable {\n\t\t.....\n\n        if (IActivityManagerCompat.isIActivityManager(obj)) {\n            setOldObj(obj);\n            Class<?> objClass = mOldObj.getClass();\n            List<Class<?>> interfaces = Utils.getAllInterfaces(objClass);\n            Class[] ifs = interfaces != null && interfaces.size() > 0 ? interfaces.toArray(new Class[interfaces.size()]) : new Class[0];\n            Object proxiedActivityManager = MyProxy.newProxyInstance(objClass.getClassLoader(), ifs, this);\n            FieldUtils.writeStaticField(cls, \"gDefault\", proxiedActivityManager);\n            Log.i(TAG, \"Install ActivityManager Hook 1 old=%s,new=%s\", mOldObj, proxiedActivityManager);\n        } \n\n\t\t\t.......\n        }\n\n首先，判断上面获取找到系统的IActivityManager是否正确，然后setOldObj(obj)保存当前系统的IActivityManager对象，留意IActivityManagerHook类是继承ProxyHook，该类实现InvocationHandler接口，就是一个代理类的实体啊。ok，你应该留意到接下来的操作就是介绍如何一步步实现代理，并把代理对象写到ActivityManagerNative的gDefault变量中，这样就实现hook了：\n\n\tObject proxiedActivityManager = MyProxy.newProxyInstance(objClass.getClassLoader(), ifs, this);\n    FieldUtils.writeStaticField(cls, \"gDefault\", proxiedActivityManager);\n\nclassLoader和获取所有接口数组都是沿用mOldObj对象。\n\nhook之后就开始干坏事了，把目光转到ProxyHook类中的invoke方法：\n\n\t# ProxyHook.java\n\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\n        try {\n            if (!isEnable()) {\n                return method.invoke(mOldObj, args);\n            }\n            HookedMethodHandler hookedMethodHandler = mHookHandles.getHookedMethodHandler(method);\n            if (hookedMethodHandler != null) {\n                return hookedMethodHandler.doHookInner(mOldObj, method, args);\n            }\n            return method.invoke(mOldObj, args);\n        } catch (InvocationTargetException e) {\n            Throwable cause = e.getTargetException();\n         .......\n    }\t\n\n首先，isEnable()先判断一下这个函数是否可以hook，不可以的话直接返回mOldObj（系统）的原本方法；可以的话继续往下走：\n\n\t# ProxyHook.java\n\n\tHookedMethodHandler hookedMethodHandler = mHookHandles.getHookedMethodHandler(method);\n    if (hookedMethodHandler != null) {\n        return hookedMethodHandler.doHookInner(mOldObj, method, args);\n    }\n\treturn method.invoke(mOldObj, args);\n\n根据方法名字获取一个hookedMethodHandler，如果不为空，则执行hookedMethodHandler的doHookInner方法；如果为空，依旧返回系统的原本方法。\n\nhookedMethodHandler是什么鬼？还记得上面提到的IActivityManagerHookHandle的init()方法？是的，这里就要用到，先看一下之前的init()代码：\n\n\t# IActivityManagerHookHandle.java\n\n    protected void init() {\n        sHookedMethodHandlers.put(\"startActivity\", new startActivity(mHostContext));\n        sHookedMethodHandlers.put(\"startActivityAsUser\", new startActivityAsUser(mHostContext));\n        sHookedMethodHandlers.put(\"startActivityAsCaller\", new startActivityAsCaller(mHostContext));\n        sHookedMethodHandlers.put(\"startActivityAndWait\", new startActivityAndWait(mHostContext));\n        sHookedMethodHandlers.put(\"startActivityWithConfig\", new startActivityWithConfig(mHostContext));\n        sHookedMethodHandlers.put(\"startActivityIntentSender\", new startActivityIntentSender(mHostContext));\n        sHookedMethodHandlers.put(\"startVoiceActivity\", new startVoiceActivity(mHostContext));\n        sHookedMethodHandlers.put(\"startNextMatchingActivity\", new startNextMatchingActivity(mHostContext));\n        sHookedMethodHandlers.put(\"startActivityFromRecents\", new startActivityFromRecents(mHostContext));\n      ...........\n    }\n\n初始化把所有方法和对应的HookedMethodHandler处理类放在一起。\n\n我们假如传入一个方法名为startActivity，hookedMethodHandler存在，并进入doHookInner方法：\n\n\t# HookedMethodHandler.java\n\n    public synchronized Object doHookInner(Object receiver, Method method, Object[] args) throws Throwable {\n        long b = System.currentTimeMillis();\n        try {\n            mUseFakedResult = false;\n            mFakedResult = null;\n            boolean suc = beforeInvoke(receiver, method, args);\n            Object invokeResult = null;\n            if (!suc) {\n                invokeResult = method.invoke(receiver, args);\n            }\n            afterInvoke(receiver, method, args, invokeResult);\n            if (mUseFakedResult) {\n                return mFakedResult;\n            } else {\n                return invokeResult;\n            }\n        } \n\t.........\n    }\n\n从上面看到熟悉的动态代理，先执行beforeInvoke方法，如果结果为true，拦截了该事件；如果为false，还是会继续执行系统原本方法，最后调用afterInvoke方法。在HookedMethodHandler里面beforeInvoke方法默认返回false，afterInvoke方法并没有实现：\n\n\t# HookedMethodHandler.java\n\n    /**\n     * 在某个方法被调用之前执行，如果返回true，则不执行原始的方法，否则执行原始方法\n     */\n    protected boolean beforeInvoke(Object receiver, Method method, Object[] args) throws Throwable {\n        return false;\n    }\n\n    protected void afterInvoke(Object receiver, Method method, Object[] args, Object invokeResult) throws Throwable {\n    }\n\n如果需要实现肯定是在子类了，在IActivityManagerHookHandle的init()方法里面，以startActivity为例：\n\n    private static class startActivity extends HookedMethodHandler {\n\n        public startActivity(Context hostContext) {\n            super(hostContext);\n        }\n\t\t......\n        @Override\n        protected boolean beforeInvoke(Object receiver, Method method, Object[] args) throws Throwable {\n            if (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR2) {\n                //2.3\n        /*public int startActivity(IApplicationThread caller,\n            Intent intent, String resolvedType, Uri[] grantedUriPermissions,\n            int grantedMode, IBinder resultTo, String resultWho, int requestCode,\n            boolean onlyIfNeeded, boolean debug) throws RemoteException;*/\n\n                //api 15\n        /*public int startActivity(IApplicationThread caller,\n            Intent intent, String resolvedType, Uri[] grantedUriPermissions,\n            int grantedMode, IBinder resultTo, String resultWho, int requestCode,\n            boolean onlyIfNeeded, boolean debug, String profileFile,\n            ParcelFileDescriptor profileFd, boolean autoStopProfiler) throws RemoteException;*/\n\n                //api 16,17\n        /*  public int startActivity(IApplicationThread caller,\n            Intent intent, String resolvedType, IBinder resultTo, String resultWho,\n            int requestCode, int flags, String profileFile,\n            ParcelFileDescriptor profileFd, Bundle options) throws RemoteException;*/\n                doReplaceIntentForStartActivityAPILow(args);\n            } else {\n                //api 18,19\n         /*  public int startActivity(IApplicationThread caller, String callingPackage,\n            Intent intent, String resolvedType, IBinder resultTo, String resultWho,\n            int requestCode, int flags, String profileFile,\n            ParcelFileDescriptor profileFd, Bundle options) throws RemoteException;*/\n\n                //api 21\n        /*   public int startActivity(IApplicationThread caller, String callingPackage,\n            Intent intent, String resolvedType, IBinder resultTo, String resultWho,\n            int requestCode, int flags, ProfilerInfo profilerInfo,\n            Bundle options) throws RemoteException;*/\n                doReplaceIntentForStartActivityAPIHigh(args);\n            }\n            return super.beforeInvoke(receiver, method, args);\n        }\n    }\n\n至此，hook的过程应该已经介绍完毕，其中涉及比较高深的问题，小弟完美绕过。\n\n\n\n\n\n\n","source":"_posts/简析DroidPlugin之Hook.md","raw":"title: 简析DroidPlugin之Hook\ndate: 2016/6/14 17：55\n\ncategories:\n- Mobile\ntags:\n- android\n---\n\n# 前言 #\n被誉为“安卓黑科技”的开源框架DroidPlugin，是目前较为流行的安卓动态加载技术的典范。免安装和免修改运行第三方sdk，实现多团队协助开发，是360推出这个牛逼able框架的主打亮点。那么，它是如何一步步去实现这个神奇的框架的呢？又和我们常见的动态加载技术有何区别去值得我们学习的？由于目前国内对这个框架没太多的研究，很多地方只能做到点到即止。本文主要分享其hook的过程。<!-- more -->\n\n## 了解入口架构 ##\n\n首先，看到application的attachBaseContext方法里面做了这样一步：\n\n\t# PluginApplication.java\n\n    PluginHelper.getInstance().applicationAttachBaseContext(base);\n\n这一步并没有做太多操作，只是注册了crash之后的log发送之类的信息。这里不展开细说。\n\n在onCreate方法里有：\n\n\t# PluginApplication.java\n\n    PluginHelper.getInstance().applicationOnCreate(getBaseContext());\n\n这一步是核心操作，进行了一系列的初始化，本文也是从这里开始展开。跟代码找到了initPlugin方法：\n\n\t# PluginHelper.java\n\n    private void initPlugin(Context baseContext) {\n        long b = System.currentTimeMillis();\n        try {\n            try {\n                fixMiUiLbeSecurity();\n            } catch (Throwable e) {\n                Log.e(TAG, \"fixMiUiLbeSecurity has error\", e);\n            }\n \n            try {\n                PluginProcessManager.installHook(baseContext);\n            } catch (Throwable e) {\n                Log.e(TAG, \"installHook has error\", e);\n            }\n \t\t......\n    }\n\n看到了 PluginProcessManager.installHook(baseContext); 这是安装钩子函数（hook）相关的入口。接着往下看：\n\n\t# HookFactory.java\n\n    public final void installHook(Context context, ClassLoader classLoader) throws Throwable {\n        installHook(new IClipboardBinderHook(context), classLoader);\n        //for ISearchManager\n        installHook(new ISearchManagerBinderHook(context), classLoader);\n        //for INotificationManager\n        installHook(new INotificationManagerBinderHook(context), classLoader);\n \t\t..........\n \n        installHook(new IPackageManagerHook(context), classLoader);\n        installHook(new IActivityManagerHook(context), classLoader);\n        installHook(new PluginCallbackHook(context), classLoader);\n\t\t.......\n    }\n\n很明显，这里做了一系列系统组件的hook操作，这里以\n\n\t# HookFactory.java\n\n    installHook(new IActivityManagerHook(context), classLoader);\n\n为例，实例化 IActivityManagerHook ，这个类继承谁呢？查看该类hook的体系结构：\n\n    Hook\n    --| ProxyHook\n    ----| IActivityManagerHook\n\n基类Hook.java构造方法做了两步操作，一是初始化了hostContext，二是创建hookHandle：\n\n\t# Hook.java\n\t\n    protected Hook(Context hostContext) {\n        mHostContext = hostContext;\n        mHookHandles = createHookHandle();\n    }\n\n跟着代码走到了IActivityManagerHookHandle的init()方法。咦，代码看上去貌似很长，其实就是用一个Map去存放方法名和对应操作的键值对，这里先有个概念，后面会用到。\n\nIActivityManagerHook实例化完之后，就是installHook的方法，先贴上代码：\n\n\t# HookFactory.java \n\n    public void installHook(Hook hook, ClassLoader cl) {\n        try {\n            hook.onInstall(cl);\n            synchronized (mHookList) {\n                mHookList.add(hook);\n            }\n        } catch (Throwable throwable) {\n            Log.e(TAG, \"installHook %s error\", throwable, hook);\n        }\n    }\n\n首先，这里对刚才实例化的hook调用了onInstall方法，并传入一个classLoder，这里为空；然后把hook添加到一个List集合中去。我们看一下IActivityManagerHook的onInstall方法的前半部分：\n\n\t# IActivityManagerHook.java\n\n    public void onInstall(ClassLoader classLoader) throws Throwable {\n    \tClass cls = ActivityManagerNativeCompat.Class();\n    \tObject obj = FieldUtils.readStaticField(cls, \"gDefault\");\n   \t \tif (obj == null) {\n    \t\tActivityManagerNativeCompat.getDefault();\n    \t\tobj = FieldUtils.readStaticField(cls, \"gDefault\");\n   \t\t }\n    \n    \t.............\n    }\n\n整个onInstall方法做了两件事情：</br>\n1.找到系统的IActivityManager;</br>\n2.判断该IActivityManager是否为单例，做不同的处理\n\n## 找到Hook对象 ##\n\n我们看一下在IAcitivityManager里面\"gDefault\"这个变量是干嘛的，贴源码：\n\n\t# ActivityManagerNative.java\n\n    private static final Singleton<IActivityManager> gDefault = new Singleton<IActivityManager>() {\n        protected IActivityManager create() {\n            IBinder b = ServiceManager.getService(\"activity\");\n            if (false) {\n                Log.v(\"ActivityManager\", \"default service binder = \" + b);\n            }\n            IActivityManager am = asInterface(b);\n            if (false) {\n                Log.v(\"ActivityManager\", \"default service = \" + am);\n            }\n            return am;\n        }\n    };\n\n我们知道，Android中ActivityManager是与系统所有运行着的Activity进行交互，对系统所有运行的Activity进行管理和维护，但是这些信息真正维护并不是由ActivityManager来负责。读起来有点绕，RTFSC是王道，截取其中一段获取运行服务的方法：\n\n\t# ActivityManager.java\n\n    public List<RunningServiceInfo> getRunningServices(int maxNum)\n            throws SecurityException {\n        try {\n            return ActivityManagerNative.getDefault()\n                    .getServices(maxNum, 0);\n        } catch (RemoteException e) {\n            // System dead, we will be dead too soon!\n            return null;\n        }\n    }\n\n通过阅读ActivityManager的源码发现，所有的信息都是通过ActivityManagerNative.getDefault()来操作获取。哎呦，这里面到底是干了啥？我们先来看一幅Activity Manager相关类继承层次关系图：\n\n![](http://i.imgur.com/ToILsf2.jpg)\n\nActivityManagerProxy，见名思意，是一个代理类，同时也是ActivityManagerNative的内部类；ActivityManagerNative是一个抽象类，实现它的是ActivityManagerService，这是一个系统Service组件。\n从图中可以看出，使用ActivityManagerProxy，来代理ActivityManagerNative，实质就是代理它的实现类ActivityManagerService；ActivityManagerService是系统统一的Service，运行在独立的进程中，通过系统ServiceManger来获取。\n\n\n那么，问题来了，ActivityManager运行在一个进程里面，ActivityManagerService运行在另一个进程内，这里面涉及到跨进程的对象访问，毫无疑问，采用的是Binder机制实现。\n\n我们从刚刚截取的ActivityManagerNative.java中定义gDefault的方法可以看到，首先获取“activity”的IBinder\n\n\tIBinder b = ServiceManager.getService(\"activity\");\n\n这个可以从以下源码得知，其中sCache存放的是名字和对应IBinder的键值对Map\n\n\t# ServiceManager.java\n\n    /**\n     * Returns a reference to a service with the given name.\n     * \n     * @param name the name of the service to get\n     * @return a reference to the service, or <code>null</code> if the service doesn't exist\n     */\n    public static IBinder getService(String name) {\n        try {\n            IBinder service = sCache.get(name);\n            if (service != null) {\n                return service;\n            } else {\n                return getIServiceManager().getService(name);\n            }\n        } catch (RemoteException e) {\n            Log.e(TAG, \"error in getService\", e);\n        }\n        return null;\n    }\n\n然后通过 asInterface(b) 就获取了ActivityManagerService实例的本地代理对象ActivityManagerProxy实例：\n\n\n\t# ActivityManagerNative.java\n\n    /**\n     * Cast a Binder object into an activity manager interface, generating\n     * a proxy if needed.\n     */\n    static public IActivityManager asInterface(IBinder obj) {\n        if (obj == null) {\n            return null;\n        }\n        IActivityManager in =\n            (IActivityManager)obj.queryLocalInterface(descriptor);\n        if (in != null) {\n            return in;\n        }\n\n        return new ActivityManagerProxy(obj);\n    }\n\n贴上一图，让你瞬间有豁然开朗的感觉有木有：\n\n![](http://i.imgur.com/Au935XN.jpg)\n\nok，回到我们的最原点，找到系统的IActivityManager要干嘛？当然就是我们的劫持hook了，在说hook之前，要说说动态代理机制。\n\n## 动态代理机制 ##\n\n动态代理，是一种设计模式，可以为其他对象提供一种代理以控制对这个对象的访问。举一个肤浅的栗子：\n\n\n   \tpublic Object invoke( Object proxy, Method method, Object[] args ) throws Throwable   \n      {   \n    //1.在转调具体目标对象之前，可以执行一些功能处理\n\n    //2.转调具体目标对象的方法\n    return method.invoke( proxied, args);  \n    \n    //3.在转调具体目标对象之后，可以执行一些功能处理\n\n      }\n    } \n\n所谓代理，就是首先要获得被代理者的控制权，被代理者在正常调用的时候，代理可以在被代理者的所有方法前或后添加想要的操作。从上图简单地理解，就是在2方法（被代理者）添加1和3方法。可以看一下代理结构图：\n\n![](http://i.imgur.com/s0zRfSt.gif)\n\n在动态代理机制中，有两个重要的类，分别是InvocationHandler和Proxy。我们看一下API帮助文档是怎么对两个类做描述的：\n\nInvocationHandler：\n\n    InvocationHandler is the interface implemented by the invocation handler of a proxy instance. \n    \n    Each proxy instance has an associated invocation handler. When a method is invoked on a proxy instance, the method invocation is encoded and dispatched to the invoke method of its invocation handler.\n\n每一个动态代理类必须要实现InvocationHandler这个接口，而InvocationHandler这个接口只有唯一一个invoke方法：\n    \n    Object invoke(Object proxy, Method method, Object[] args) throws Throwable\n\n    proxy:　　指代我们所代理的那个真实对象\n    method:　 指代的是我们所要调用真实对象的某个方法的Method对象\n    args:　　 指代的是调用真实对象某个方法时接受的参数\n\nProxy：\n\n    Proxy provides static methods for creating dynamic proxy classes and instances, and it is also the superclass of all dynamic proxy classes created by those methods. \n\nProxy这个类的作用是创建一个代理对象的类，它提供了很多方法，在这里我们只需要了解到newProxyInstance 即可：\n\n    public static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h) throws IllegalArgumentException\n    \n    loader:　　  一个ClassLoader对象，定义了由哪个ClassLoader对象来对生成的代理对象进行加载   \n    interfaces:  一个Interface对象的数组，表示的是我将要给我需要代理的对象提供一组什么接口，如果我提供了一组接口给它，那么这个代理对象就宣称实现了该接口(多态)，这样我就能调用这组接口中的方法了\n   \th:　　        一个InvocationHandler对象，表示的是当我这个动态代理对象在调用方法的时候，会关联到哪一个InvocationHandler对象上\n\nok，有了点概念，我们来继续举个具体点的栗子：\n\n定义一个people的接口：\n\n    public interface People{\n    \tpublic void countMoney();\n    }\n\nboss类去实现这个接口：\n\n    public class Boss implements people{\n\t\t@Override\n\t\tpublic void countMoney(){\n\t\t\tsystem.out.println(\"I have too money to burn.\");\n\t\t}\n    } \n\n定义一个代理类workers，前面说到了，每一个代理类必须实现InvocationHandler 这个接口：\n\n\tpublic class Workers implements InvocationHandler{\n\t\t//这个是我们要代理的真实对象\n\t\tprivate Object people;\n\n\t\t//构造方法，给我们要代理的真实对象赋值\n\t\tpublic workers(Object people){\n\t\t\tthis.people = people;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object invoke(Object object, Method method, Object[] args){\n\t\t\t\n\t\t\t//在代理真实对象之前加上一些操作\n\t\t\tsystem.out.println(\"I must word hard because I have no money.\");\n\n\t\t\t//调用真实对象的相关方法\n\t\t\tmethod.invoke(subject, args);\n\n\t\t\t//在代理真实对象之后加上一些操作\n\t\t\tsystem.out.println(\"Whether you have got money or not,it's wise for you to go back home for the Spring Festival.\");\n\t\t}\n\t} \n\n编写测试类：\n\n\tpublic class test{\n\t\t....\n\t\tBoss boss = new Boss;\n\t\tInvocationHandle handle = new Workers(boss);\n\t\tWorkers workers = (Workers) Proxy.newProxyInstance(handle.getClass().getClassLoader(),boss.getClass().getInterfaces(),handle);\n\t\t\n\t\tworkers.countMoney();\n\t\t\n\t}\n\n看一下输出结果：\n\n    I must word hard because I have no money.\n    I have too money to burn.\n    Whether you have got money or not,it's wise for you to go back home for the Spring Festival.\n\n结果很明显了，如果想了解其中的跳转原理，请查看源码，这里就不多作介绍了。\n\n## 开始Hook ##\n我们来看看onInstall方法的后半部分：\n\n\t# IActivityManagerHook.java\n\n\tpublic void onInstall(ClassLoader classLoader) throws Throwable {\n\t\t.....\n\n        if (IActivityManagerCompat.isIActivityManager(obj)) {\n            setOldObj(obj);\n            Class<?> objClass = mOldObj.getClass();\n            List<Class<?>> interfaces = Utils.getAllInterfaces(objClass);\n            Class[] ifs = interfaces != null && interfaces.size() > 0 ? interfaces.toArray(new Class[interfaces.size()]) : new Class[0];\n            Object proxiedActivityManager = MyProxy.newProxyInstance(objClass.getClassLoader(), ifs, this);\n            FieldUtils.writeStaticField(cls, \"gDefault\", proxiedActivityManager);\n            Log.i(TAG, \"Install ActivityManager Hook 1 old=%s,new=%s\", mOldObj, proxiedActivityManager);\n        } \n\n\t\t\t.......\n        }\n\n首先，判断上面获取找到系统的IActivityManager是否正确，然后setOldObj(obj)保存当前系统的IActivityManager对象，留意IActivityManagerHook类是继承ProxyHook，该类实现InvocationHandler接口，就是一个代理类的实体啊。ok，你应该留意到接下来的操作就是介绍如何一步步实现代理，并把代理对象写到ActivityManagerNative的gDefault变量中，这样就实现hook了：\n\n\tObject proxiedActivityManager = MyProxy.newProxyInstance(objClass.getClassLoader(), ifs, this);\n    FieldUtils.writeStaticField(cls, \"gDefault\", proxiedActivityManager);\n\nclassLoader和获取所有接口数组都是沿用mOldObj对象。\n\nhook之后就开始干坏事了，把目光转到ProxyHook类中的invoke方法：\n\n\t# ProxyHook.java\n\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\n        try {\n            if (!isEnable()) {\n                return method.invoke(mOldObj, args);\n            }\n            HookedMethodHandler hookedMethodHandler = mHookHandles.getHookedMethodHandler(method);\n            if (hookedMethodHandler != null) {\n                return hookedMethodHandler.doHookInner(mOldObj, method, args);\n            }\n            return method.invoke(mOldObj, args);\n        } catch (InvocationTargetException e) {\n            Throwable cause = e.getTargetException();\n         .......\n    }\t\n\n首先，isEnable()先判断一下这个函数是否可以hook，不可以的话直接返回mOldObj（系统）的原本方法；可以的话继续往下走：\n\n\t# ProxyHook.java\n\n\tHookedMethodHandler hookedMethodHandler = mHookHandles.getHookedMethodHandler(method);\n    if (hookedMethodHandler != null) {\n        return hookedMethodHandler.doHookInner(mOldObj, method, args);\n    }\n\treturn method.invoke(mOldObj, args);\n\n根据方法名字获取一个hookedMethodHandler，如果不为空，则执行hookedMethodHandler的doHookInner方法；如果为空，依旧返回系统的原本方法。\n\nhookedMethodHandler是什么鬼？还记得上面提到的IActivityManagerHookHandle的init()方法？是的，这里就要用到，先看一下之前的init()代码：\n\n\t# IActivityManagerHookHandle.java\n\n    protected void init() {\n        sHookedMethodHandlers.put(\"startActivity\", new startActivity(mHostContext));\n        sHookedMethodHandlers.put(\"startActivityAsUser\", new startActivityAsUser(mHostContext));\n        sHookedMethodHandlers.put(\"startActivityAsCaller\", new startActivityAsCaller(mHostContext));\n        sHookedMethodHandlers.put(\"startActivityAndWait\", new startActivityAndWait(mHostContext));\n        sHookedMethodHandlers.put(\"startActivityWithConfig\", new startActivityWithConfig(mHostContext));\n        sHookedMethodHandlers.put(\"startActivityIntentSender\", new startActivityIntentSender(mHostContext));\n        sHookedMethodHandlers.put(\"startVoiceActivity\", new startVoiceActivity(mHostContext));\n        sHookedMethodHandlers.put(\"startNextMatchingActivity\", new startNextMatchingActivity(mHostContext));\n        sHookedMethodHandlers.put(\"startActivityFromRecents\", new startActivityFromRecents(mHostContext));\n      ...........\n    }\n\n初始化把所有方法和对应的HookedMethodHandler处理类放在一起。\n\n我们假如传入一个方法名为startActivity，hookedMethodHandler存在，并进入doHookInner方法：\n\n\t# HookedMethodHandler.java\n\n    public synchronized Object doHookInner(Object receiver, Method method, Object[] args) throws Throwable {\n        long b = System.currentTimeMillis();\n        try {\n            mUseFakedResult = false;\n            mFakedResult = null;\n            boolean suc = beforeInvoke(receiver, method, args);\n            Object invokeResult = null;\n            if (!suc) {\n                invokeResult = method.invoke(receiver, args);\n            }\n            afterInvoke(receiver, method, args, invokeResult);\n            if (mUseFakedResult) {\n                return mFakedResult;\n            } else {\n                return invokeResult;\n            }\n        } \n\t.........\n    }\n\n从上面看到熟悉的动态代理，先执行beforeInvoke方法，如果结果为true，拦截了该事件；如果为false，还是会继续执行系统原本方法，最后调用afterInvoke方法。在HookedMethodHandler里面beforeInvoke方法默认返回false，afterInvoke方法并没有实现：\n\n\t# HookedMethodHandler.java\n\n    /**\n     * 在某个方法被调用之前执行，如果返回true，则不执行原始的方法，否则执行原始方法\n     */\n    protected boolean beforeInvoke(Object receiver, Method method, Object[] args) throws Throwable {\n        return false;\n    }\n\n    protected void afterInvoke(Object receiver, Method method, Object[] args, Object invokeResult) throws Throwable {\n    }\n\n如果需要实现肯定是在子类了，在IActivityManagerHookHandle的init()方法里面，以startActivity为例：\n\n    private static class startActivity extends HookedMethodHandler {\n\n        public startActivity(Context hostContext) {\n            super(hostContext);\n        }\n\t\t......\n        @Override\n        protected boolean beforeInvoke(Object receiver, Method method, Object[] args) throws Throwable {\n            if (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR2) {\n                //2.3\n        /*public int startActivity(IApplicationThread caller,\n            Intent intent, String resolvedType, Uri[] grantedUriPermissions,\n            int grantedMode, IBinder resultTo, String resultWho, int requestCode,\n            boolean onlyIfNeeded, boolean debug) throws RemoteException;*/\n\n                //api 15\n        /*public int startActivity(IApplicationThread caller,\n            Intent intent, String resolvedType, Uri[] grantedUriPermissions,\n            int grantedMode, IBinder resultTo, String resultWho, int requestCode,\n            boolean onlyIfNeeded, boolean debug, String profileFile,\n            ParcelFileDescriptor profileFd, boolean autoStopProfiler) throws RemoteException;*/\n\n                //api 16,17\n        /*  public int startActivity(IApplicationThread caller,\n            Intent intent, String resolvedType, IBinder resultTo, String resultWho,\n            int requestCode, int flags, String profileFile,\n            ParcelFileDescriptor profileFd, Bundle options) throws RemoteException;*/\n                doReplaceIntentForStartActivityAPILow(args);\n            } else {\n                //api 18,19\n         /*  public int startActivity(IApplicationThread caller, String callingPackage,\n            Intent intent, String resolvedType, IBinder resultTo, String resultWho,\n            int requestCode, int flags, String profileFile,\n            ParcelFileDescriptor profileFd, Bundle options) throws RemoteException;*/\n\n                //api 21\n        /*   public int startActivity(IApplicationThread caller, String callingPackage,\n            Intent intent, String resolvedType, IBinder resultTo, String resultWho,\n            int requestCode, int flags, ProfilerInfo profilerInfo,\n            Bundle options) throws RemoteException;*/\n                doReplaceIntentForStartActivityAPIHigh(args);\n            }\n            return super.beforeInvoke(receiver, method, args);\n        }\n    }\n\n至此，hook的过程应该已经介绍完毕，其中涉及比较高深的问题，小弟完美绕过。\n\n\n\n\n\n\n","slug":"简析DroidPlugin之Hook","published":1,"updated":"2016-06-14T10:04:50.379Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cisn9io41000464vic49pe6zm","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>被誉为“安卓黑科技”的开源框架DroidPlugin，是目前较为流行的安卓动态加载技术的典范。免安装和免修改运行第三方sdk，实现多团队协助开发，是360推出这个牛逼able框架的主打亮点。那么，它是如何一步步去实现这个神奇的框架的呢？又和我们常见的动态加载技术有何区别去值得我们学习的？由于目前国内对这个框架没太多的研究，很多地方只能做到点到即止。本文主要分享其hook的过程。<a id=\"more\"></a></p>\n<h2 id=\"了解入口架构\"><a href=\"#了解入口架构\" class=\"headerlink\" title=\"了解入口架构\"></a>了解入口架构</h2><p>首先，看到application的attachBaseContext方法里面做了这样一步：</p>\n<pre><code># PluginApplication.java\n\nPluginHelper.getInstance().applicationAttachBaseContext(base);\n</code></pre><p>这一步并没有做太多操作，只是注册了crash之后的log发送之类的信息。这里不展开细说。</p>\n<p>在onCreate方法里有：</p>\n<pre><code># PluginApplication.java\n\nPluginHelper.getInstance().applicationOnCreate(getBaseContext());\n</code></pre><p>这一步是核心操作，进行了一系列的初始化，本文也是从这里开始展开。跟代码找到了initPlugin方法：</p>\n<pre><code># PluginHelper.java\n\nprivate void initPlugin(Context baseContext) {\n    long b = System.currentTimeMillis();\n    try {\n        try {\n            fixMiUiLbeSecurity();\n        } catch (Throwable e) {\n            Log.e(TAG, &quot;fixMiUiLbeSecurity has error&quot;, e);\n        }\n\n        try {\n            PluginProcessManager.installHook(baseContext);\n        } catch (Throwable e) {\n            Log.e(TAG, &quot;installHook has error&quot;, e);\n        }\n     ......\n}\n</code></pre><p>看到了 PluginProcessManager.installHook(baseContext); 这是安装钩子函数（hook）相关的入口。接着往下看：</p>\n<pre><code># HookFactory.java\n\npublic final void installHook(Context context, ClassLoader classLoader) throws Throwable {\n    installHook(new IClipboardBinderHook(context), classLoader);\n    //for ISearchManager\n    installHook(new ISearchManagerBinderHook(context), classLoader);\n    //for INotificationManager\n    installHook(new INotificationManagerBinderHook(context), classLoader);\n     ..........\n\n    installHook(new IPackageManagerHook(context), classLoader);\n    installHook(new IActivityManagerHook(context), classLoader);\n    installHook(new PluginCallbackHook(context), classLoader);\n    .......\n}\n</code></pre><p>很明显，这里做了一系列系统组件的hook操作，这里以</p>\n<pre><code># HookFactory.java\n\ninstallHook(new IActivityManagerHook(context), classLoader);\n</code></pre><p>为例，实例化 IActivityManagerHook ，这个类继承谁呢？查看该类hook的体系结构：</p>\n<pre><code>Hook\n--| ProxyHook\n----| IActivityManagerHook\n</code></pre><p>基类Hook.java构造方法做了两步操作，一是初始化了hostContext，二是创建hookHandle：</p>\n<pre><code># Hook.java\n\nprotected Hook(Context hostContext) {\n    mHostContext = hostContext;\n    mHookHandles = createHookHandle();\n}\n</code></pre><p>跟着代码走到了IActivityManagerHookHandle的init()方法。咦，代码看上去貌似很长，其实就是用一个Map去存放方法名和对应操作的键值对，这里先有个概念，后面会用到。</p>\n<p>IActivityManagerHook实例化完之后，就是installHook的方法，先贴上代码：</p>\n<pre><code># HookFactory.java \n\npublic void installHook(Hook hook, ClassLoader cl) {\n    try {\n        hook.onInstall(cl);\n        synchronized (mHookList) {\n            mHookList.add(hook);\n        }\n    } catch (Throwable throwable) {\n        Log.e(TAG, &quot;installHook %s error&quot;, throwable, hook);\n    }\n}\n</code></pre><p>首先，这里对刚才实例化的hook调用了onInstall方法，并传入一个classLoder，这里为空；然后把hook添加到一个List集合中去。我们看一下IActivityManagerHook的onInstall方法的前半部分：</p>\n<pre><code># IActivityManagerHook.java\n\npublic void onInstall(ClassLoader classLoader) throws Throwable {\n    Class cls = ActivityManagerNativeCompat.Class();\n    Object obj = FieldUtils.readStaticField(cls, &quot;gDefault&quot;);\n        if (obj == null) {\n        ActivityManagerNativeCompat.getDefault();\n        obj = FieldUtils.readStaticField(cls, &quot;gDefault&quot;);\n        }\n\n    .............\n}\n</code></pre><p>整个onInstall方法做了两件事情：<br><br>1.找到系统的IActivityManager;<br><br>2.判断该IActivityManager是否为单例，做不同的处理</p>\n<h2 id=\"找到Hook对象\"><a href=\"#找到Hook对象\" class=\"headerlink\" title=\"找到Hook对象\"></a>找到Hook对象</h2><p>我们看一下在IAcitivityManager里面”gDefault”这个变量是干嘛的，贴源码：</p>\n<pre><code># ActivityManagerNative.java\n\nprivate static final Singleton&lt;IActivityManager&gt; gDefault = new Singleton&lt;IActivityManager&gt;() {\n    protected IActivityManager create() {\n        IBinder b = ServiceManager.getService(&quot;activity&quot;);\n        if (false) {\n            Log.v(&quot;ActivityManager&quot;, &quot;default service binder = &quot; + b);\n        }\n        IActivityManager am = asInterface(b);\n        if (false) {\n            Log.v(&quot;ActivityManager&quot;, &quot;default service = &quot; + am);\n        }\n        return am;\n    }\n};\n</code></pre><p>我们知道，Android中ActivityManager是与系统所有运行着的Activity进行交互，对系统所有运行的Activity进行管理和维护，但是这些信息真正维护并不是由ActivityManager来负责。读起来有点绕，RTFSC是王道，截取其中一段获取运行服务的方法：</p>\n<pre><code># ActivityManager.java\n\npublic List&lt;RunningServiceInfo&gt; getRunningServices(int maxNum)\n        throws SecurityException {\n    try {\n        return ActivityManagerNative.getDefault()\n                .getServices(maxNum, 0);\n    } catch (RemoteException e) {\n        // System dead, we will be dead too soon!\n        return null;\n    }\n}\n</code></pre><p>通过阅读ActivityManager的源码发现，所有的信息都是通过ActivityManagerNative.getDefault()来操作获取。哎呦，这里面到底是干了啥？我们先来看一幅Activity Manager相关类继承层次关系图：</p>\n<p><img src=\"http://i.imgur.com/ToILsf2.jpg\" alt=\"\"></p>\n<p>ActivityManagerProxy，见名思意，是一个代理类，同时也是ActivityManagerNative的内部类；ActivityManagerNative是一个抽象类，实现它的是ActivityManagerService，这是一个系统Service组件。<br>从图中可以看出，使用ActivityManagerProxy，来代理ActivityManagerNative，实质就是代理它的实现类ActivityManagerService；ActivityManagerService是系统统一的Service，运行在独立的进程中，通过系统ServiceManger来获取。</p>\n<p>那么，问题来了，ActivityManager运行在一个进程里面，ActivityManagerService运行在另一个进程内，这里面涉及到跨进程的对象访问，毫无疑问，采用的是Binder机制实现。</p>\n<p>我们从刚刚截取的ActivityManagerNative.java中定义gDefault的方法可以看到，首先获取“activity”的IBinder</p>\n<pre><code>IBinder b = ServiceManager.getService(&quot;activity&quot;);\n</code></pre><p>这个可以从以下源码得知，其中sCache存放的是名字和对应IBinder的键值对Map</p>\n<pre><code># ServiceManager.java\n\n/**\n * Returns a reference to a service with the given name.\n * \n * @param name the name of the service to get\n * @return a reference to the service, or &lt;code&gt;null&lt;/code&gt; if the service doesn&apos;t exist\n */\npublic static IBinder getService(String name) {\n    try {\n        IBinder service = sCache.get(name);\n        if (service != null) {\n            return service;\n        } else {\n            return getIServiceManager().getService(name);\n        }\n    } catch (RemoteException e) {\n        Log.e(TAG, &quot;error in getService&quot;, e);\n    }\n    return null;\n}\n</code></pre><p>然后通过 asInterface(b) 就获取了ActivityManagerService实例的本地代理对象ActivityManagerProxy实例：</p>\n<pre><code># ActivityManagerNative.java\n\n/**\n * Cast a Binder object into an activity manager interface, generating\n * a proxy if needed.\n */\nstatic public IActivityManager asInterface(IBinder obj) {\n    if (obj == null) {\n        return null;\n    }\n    IActivityManager in =\n        (IActivityManager)obj.queryLocalInterface(descriptor);\n    if (in != null) {\n        return in;\n    }\n\n    return new ActivityManagerProxy(obj);\n}\n</code></pre><p>贴上一图，让你瞬间有豁然开朗的感觉有木有：</p>\n<p><img src=\"http://i.imgur.com/Au935XN.jpg\" alt=\"\"></p>\n<p>ok，回到我们的最原点，找到系统的IActivityManager要干嘛？当然就是我们的劫持hook了，在说hook之前，要说说动态代理机制。</p>\n<h2 id=\"动态代理机制\"><a href=\"#动态代理机制\" class=\"headerlink\" title=\"动态代理机制\"></a>动态代理机制</h2><p>动态代理，是一种设计模式，可以为其他对象提供一种代理以控制对这个对象的访问。举一个肤浅的栗子：</p>\n<pre><code>   public Object invoke( Object proxy, Method method, Object[] args ) throws Throwable   \n  {   \n//1.在转调具体目标对象之前，可以执行一些功能处理\n\n//2.转调具体目标对象的方法\nreturn method.invoke( proxied, args);  \n\n//3.在转调具体目标对象之后，可以执行一些功能处理\n\n  }\n} \n</code></pre><p>所谓代理，就是首先要获得被代理者的控制权，被代理者在正常调用的时候，代理可以在被代理者的所有方法前或后添加想要的操作。从上图简单地理解，就是在2方法（被代理者）添加1和3方法。可以看一下代理结构图：</p>\n<p><img src=\"http://i.imgur.com/s0zRfSt.gif\" alt=\"\"></p>\n<p>在动态代理机制中，有两个重要的类，分别是InvocationHandler和Proxy。我们看一下API帮助文档是怎么对两个类做描述的：</p>\n<p>InvocationHandler：</p>\n<pre><code>InvocationHandler is the interface implemented by the invocation handler of a proxy instance. \n\nEach proxy instance has an associated invocation handler. When a method is invoked on a proxy instance, the method invocation is encoded and dispatched to the invoke method of its invocation handler.\n</code></pre><p>每一个动态代理类必须要实现InvocationHandler这个接口，而InvocationHandler这个接口只有唯一一个invoke方法：</p>\n<pre><code>Object invoke(Object proxy, Method method, Object[] args) throws Throwable\n\nproxy:　　指代我们所代理的那个真实对象\nmethod:　 指代的是我们所要调用真实对象的某个方法的Method对象\nargs:　　 指代的是调用真实对象某个方法时接受的参数\n</code></pre><p>Proxy：</p>\n<pre><code>Proxy provides static methods for creating dynamic proxy classes and instances, and it is also the superclass of all dynamic proxy classes created by those methods. \n</code></pre><p>Proxy这个类的作用是创建一个代理对象的类，它提供了很多方法，在这里我们只需要了解到newProxyInstance 即可：</p>\n<pre><code>public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException\n\nloader:　　  一个ClassLoader对象，定义了由哪个ClassLoader对象来对生成的代理对象进行加载   \ninterfaces:  一个Interface对象的数组，表示的是我将要给我需要代理的对象提供一组什么接口，如果我提供了一组接口给它，那么这个代理对象就宣称实现了该接口(多态)，这样我就能调用这组接口中的方法了\n   h:　　        一个InvocationHandler对象，表示的是当我这个动态代理对象在调用方法的时候，会关联到哪一个InvocationHandler对象上\n</code></pre><p>ok，有了点概念，我们来继续举个具体点的栗子：</p>\n<p>定义一个people的接口：</p>\n<pre><code>public interface People{\n    public void countMoney();\n}\n</code></pre><p>boss类去实现这个接口：</p>\n<pre><code>public class Boss implements people{\n    @Override\n    public void countMoney(){\n        system.out.println(&quot;I have too money to burn.&quot;);\n    }\n} \n</code></pre><p>定义一个代理类workers，前面说到了，每一个代理类必须实现InvocationHandler 这个接口：</p>\n<pre><code>public class Workers implements InvocationHandler{\n    //这个是我们要代理的真实对象\n    private Object people;\n\n    //构造方法，给我们要代理的真实对象赋值\n    public workers(Object people){\n        this.people = people;\n    }\n\n    @Override\n    public Object invoke(Object object, Method method, Object[] args){\n\n        //在代理真实对象之前加上一些操作\n        system.out.println(&quot;I must word hard because I have no money.&quot;);\n\n        //调用真实对象的相关方法\n        method.invoke(subject, args);\n\n        //在代理真实对象之后加上一些操作\n        system.out.println(&quot;Whether you have got money or not,it&apos;s wise for you to go back home for the Spring Festival.&quot;);\n    }\n} \n</code></pre><p>编写测试类：</p>\n<pre><code>public class test{\n    ....\n    Boss boss = new Boss;\n    InvocationHandle handle = new Workers(boss);\n    Workers workers = (Workers) Proxy.newProxyInstance(handle.getClass().getClassLoader(),boss.getClass().getInterfaces(),handle);\n\n    workers.countMoney();\n\n}\n</code></pre><p>看一下输出结果：</p>\n<pre><code>I must word hard because I have no money.\nI have too money to burn.\nWhether you have got money or not,it&apos;s wise for you to go back home for the Spring Festival.\n</code></pre><p>结果很明显了，如果想了解其中的跳转原理，请查看源码，这里就不多作介绍了。</p>\n<h2 id=\"开始Hook\"><a href=\"#开始Hook\" class=\"headerlink\" title=\"开始Hook\"></a>开始Hook</h2><p>我们来看看onInstall方法的后半部分：</p>\n<pre><code># IActivityManagerHook.java\n\npublic void onInstall(ClassLoader classLoader) throws Throwable {\n    .....\n\n    if (IActivityManagerCompat.isIActivityManager(obj)) {\n        setOldObj(obj);\n        Class&lt;?&gt; objClass = mOldObj.getClass();\n        List&lt;Class&lt;?&gt;&gt; interfaces = Utils.getAllInterfaces(objClass);\n        Class[] ifs = interfaces != null &amp;&amp; interfaces.size() &gt; 0 ? interfaces.toArray(new Class[interfaces.size()]) : new Class[0];\n        Object proxiedActivityManager = MyProxy.newProxyInstance(objClass.getClassLoader(), ifs, this);\n        FieldUtils.writeStaticField(cls, &quot;gDefault&quot;, proxiedActivityManager);\n        Log.i(TAG, &quot;Install ActivityManager Hook 1 old=%s,new=%s&quot;, mOldObj, proxiedActivityManager);\n    } \n\n        .......\n    }\n</code></pre><p>首先，判断上面获取找到系统的IActivityManager是否正确，然后setOldObj(obj)保存当前系统的IActivityManager对象，留意IActivityManagerHook类是继承ProxyHook，该类实现InvocationHandler接口，就是一个代理类的实体啊。ok，你应该留意到接下来的操作就是介绍如何一步步实现代理，并把代理对象写到ActivityManagerNative的gDefault变量中，这样就实现hook了：</p>\n<pre><code>Object proxiedActivityManager = MyProxy.newProxyInstance(objClass.getClassLoader(), ifs, this);\nFieldUtils.writeStaticField(cls, &quot;gDefault&quot;, proxiedActivityManager);\n</code></pre><p>classLoader和获取所有接口数组都是沿用mOldObj对象。</p>\n<p>hook之后就开始干坏事了，把目光转到ProxyHook类中的invoke方法：</p>\n<pre><code># ProxyHook.java\n\npublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\n    try {\n        if (!isEnable()) {\n            return method.invoke(mOldObj, args);\n        }\n        HookedMethodHandler hookedMethodHandler = mHookHandles.getHookedMethodHandler(method);\n        if (hookedMethodHandler != null) {\n            return hookedMethodHandler.doHookInner(mOldObj, method, args);\n        }\n        return method.invoke(mOldObj, args);\n    } catch (InvocationTargetException e) {\n        Throwable cause = e.getTargetException();\n     .......\n}    \n</code></pre><p>首先，isEnable()先判断一下这个函数是否可以hook，不可以的话直接返回mOldObj（系统）的原本方法；可以的话继续往下走：</p>\n<pre><code># ProxyHook.java\n\nHookedMethodHandler hookedMethodHandler = mHookHandles.getHookedMethodHandler(method);\nif (hookedMethodHandler != null) {\n    return hookedMethodHandler.doHookInner(mOldObj, method, args);\n}\nreturn method.invoke(mOldObj, args);\n</code></pre><p>根据方法名字获取一个hookedMethodHandler，如果不为空，则执行hookedMethodHandler的doHookInner方法；如果为空，依旧返回系统的原本方法。</p>\n<p>hookedMethodHandler是什么鬼？还记得上面提到的IActivityManagerHookHandle的init()方法？是的，这里就要用到，先看一下之前的init()代码：</p>\n<pre><code># IActivityManagerHookHandle.java\n\nprotected void init() {\n    sHookedMethodHandlers.put(&quot;startActivity&quot;, new startActivity(mHostContext));\n    sHookedMethodHandlers.put(&quot;startActivityAsUser&quot;, new startActivityAsUser(mHostContext));\n    sHookedMethodHandlers.put(&quot;startActivityAsCaller&quot;, new startActivityAsCaller(mHostContext));\n    sHookedMethodHandlers.put(&quot;startActivityAndWait&quot;, new startActivityAndWait(mHostContext));\n    sHookedMethodHandlers.put(&quot;startActivityWithConfig&quot;, new startActivityWithConfig(mHostContext));\n    sHookedMethodHandlers.put(&quot;startActivityIntentSender&quot;, new startActivityIntentSender(mHostContext));\n    sHookedMethodHandlers.put(&quot;startVoiceActivity&quot;, new startVoiceActivity(mHostContext));\n    sHookedMethodHandlers.put(&quot;startNextMatchingActivity&quot;, new startNextMatchingActivity(mHostContext));\n    sHookedMethodHandlers.put(&quot;startActivityFromRecents&quot;, new startActivityFromRecents(mHostContext));\n  ...........\n}\n</code></pre><p>初始化把所有方法和对应的HookedMethodHandler处理类放在一起。</p>\n<p>我们假如传入一个方法名为startActivity，hookedMethodHandler存在，并进入doHookInner方法：</p>\n<pre><code># HookedMethodHandler.java\n\npublic synchronized Object doHookInner(Object receiver, Method method, Object[] args) throws Throwable {\n    long b = System.currentTimeMillis();\n    try {\n        mUseFakedResult = false;\n        mFakedResult = null;\n        boolean suc = beforeInvoke(receiver, method, args);\n        Object invokeResult = null;\n        if (!suc) {\n            invokeResult = method.invoke(receiver, args);\n        }\n        afterInvoke(receiver, method, args, invokeResult);\n        if (mUseFakedResult) {\n            return mFakedResult;\n        } else {\n            return invokeResult;\n        }\n    } \n.........\n}\n</code></pre><p>从上面看到熟悉的动态代理，先执行beforeInvoke方法，如果结果为true，拦截了该事件；如果为false，还是会继续执行系统原本方法，最后调用afterInvoke方法。在HookedMethodHandler里面beforeInvoke方法默认返回false，afterInvoke方法并没有实现：</p>\n<pre><code># HookedMethodHandler.java\n\n/**\n * 在某个方法被调用之前执行，如果返回true，则不执行原始的方法，否则执行原始方法\n */\nprotected boolean beforeInvoke(Object receiver, Method method, Object[] args) throws Throwable {\n    return false;\n}\n\nprotected void afterInvoke(Object receiver, Method method, Object[] args, Object invokeResult) throws Throwable {\n}\n</code></pre><p>如果需要实现肯定是在子类了，在IActivityManagerHookHandle的init()方法里面，以startActivity为例：</p>\n<pre><code>private static class startActivity extends HookedMethodHandler {\n\n    public startActivity(Context hostContext) {\n        super(hostContext);\n    }\n    ......\n    @Override\n    protected boolean beforeInvoke(Object receiver, Method method, Object[] args) throws Throwable {\n        if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.JELLY_BEAN_MR2) {\n            //2.3\n    /*public int startActivity(IApplicationThread caller,\n        Intent intent, String resolvedType, Uri[] grantedUriPermissions,\n        int grantedMode, IBinder resultTo, String resultWho, int requestCode,\n        boolean onlyIfNeeded, boolean debug) throws RemoteException;*/\n\n            //api 15\n    /*public int startActivity(IApplicationThread caller,\n        Intent intent, String resolvedType, Uri[] grantedUriPermissions,\n        int grantedMode, IBinder resultTo, String resultWho, int requestCode,\n        boolean onlyIfNeeded, boolean debug, String profileFile,\n        ParcelFileDescriptor profileFd, boolean autoStopProfiler) throws RemoteException;*/\n\n            //api 16,17\n    /*  public int startActivity(IApplicationThread caller,\n        Intent intent, String resolvedType, IBinder resultTo, String resultWho,\n        int requestCode, int flags, String profileFile,\n        ParcelFileDescriptor profileFd, Bundle options) throws RemoteException;*/\n            doReplaceIntentForStartActivityAPILow(args);\n        } else {\n            //api 18,19\n     /*  public int startActivity(IApplicationThread caller, String callingPackage,\n        Intent intent, String resolvedType, IBinder resultTo, String resultWho,\n        int requestCode, int flags, String profileFile,\n        ParcelFileDescriptor profileFd, Bundle options) throws RemoteException;*/\n\n            //api 21\n    /*   public int startActivity(IApplicationThread caller, String callingPackage,\n        Intent intent, String resolvedType, IBinder resultTo, String resultWho,\n        int requestCode, int flags, ProfilerInfo profilerInfo,\n        Bundle options) throws RemoteException;*/\n            doReplaceIntentForStartActivityAPIHigh(args);\n        }\n        return super.beforeInvoke(receiver, method, args);\n    }\n}\n</code></pre><p>至此，hook的过程应该已经介绍完毕，其中涉及比较高深的问题，小弟完美绕过。</p>\n","excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>被誉为“安卓黑科技”的开源框架DroidPlugin，是目前较为流行的安卓动态加载技术的典范。免安装和免修改运行第三方sdk，实现多团队协助开发，是360推出这个牛逼able框架的主打亮点。那么，它是如何一步步去实现这个神奇的框架的呢？又和我们常见的动态加载技术有何区别去值得我们学习的？由于目前国内对这个框架没太多的研究，很多地方只能做到点到即止。本文主要分享其hook的过程。","more":"</p>\n<h2 id=\"了解入口架构\"><a href=\"#了解入口架构\" class=\"headerlink\" title=\"了解入口架构\"></a>了解入口架构</h2><p>首先，看到application的attachBaseContext方法里面做了这样一步：</p>\n<pre><code># PluginApplication.java\n\nPluginHelper.getInstance().applicationAttachBaseContext(base);\n</code></pre><p>这一步并没有做太多操作，只是注册了crash之后的log发送之类的信息。这里不展开细说。</p>\n<p>在onCreate方法里有：</p>\n<pre><code># PluginApplication.java\n\nPluginHelper.getInstance().applicationOnCreate(getBaseContext());\n</code></pre><p>这一步是核心操作，进行了一系列的初始化，本文也是从这里开始展开。跟代码找到了initPlugin方法：</p>\n<pre><code># PluginHelper.java\n\nprivate void initPlugin(Context baseContext) {\n    long b = System.currentTimeMillis();\n    try {\n        try {\n            fixMiUiLbeSecurity();\n        } catch (Throwable e) {\n            Log.e(TAG, &quot;fixMiUiLbeSecurity has error&quot;, e);\n        }\n\n        try {\n            PluginProcessManager.installHook(baseContext);\n        } catch (Throwable e) {\n            Log.e(TAG, &quot;installHook has error&quot;, e);\n        }\n     ......\n}\n</code></pre><p>看到了 PluginProcessManager.installHook(baseContext); 这是安装钩子函数（hook）相关的入口。接着往下看：</p>\n<pre><code># HookFactory.java\n\npublic final void installHook(Context context, ClassLoader classLoader) throws Throwable {\n    installHook(new IClipboardBinderHook(context), classLoader);\n    //for ISearchManager\n    installHook(new ISearchManagerBinderHook(context), classLoader);\n    //for INotificationManager\n    installHook(new INotificationManagerBinderHook(context), classLoader);\n     ..........\n\n    installHook(new IPackageManagerHook(context), classLoader);\n    installHook(new IActivityManagerHook(context), classLoader);\n    installHook(new PluginCallbackHook(context), classLoader);\n    .......\n}\n</code></pre><p>很明显，这里做了一系列系统组件的hook操作，这里以</p>\n<pre><code># HookFactory.java\n\ninstallHook(new IActivityManagerHook(context), classLoader);\n</code></pre><p>为例，实例化 IActivityManagerHook ，这个类继承谁呢？查看该类hook的体系结构：</p>\n<pre><code>Hook\n--| ProxyHook\n----| IActivityManagerHook\n</code></pre><p>基类Hook.java构造方法做了两步操作，一是初始化了hostContext，二是创建hookHandle：</p>\n<pre><code># Hook.java\n\nprotected Hook(Context hostContext) {\n    mHostContext = hostContext;\n    mHookHandles = createHookHandle();\n}\n</code></pre><p>跟着代码走到了IActivityManagerHookHandle的init()方法。咦，代码看上去貌似很长，其实就是用一个Map去存放方法名和对应操作的键值对，这里先有个概念，后面会用到。</p>\n<p>IActivityManagerHook实例化完之后，就是installHook的方法，先贴上代码：</p>\n<pre><code># HookFactory.java \n\npublic void installHook(Hook hook, ClassLoader cl) {\n    try {\n        hook.onInstall(cl);\n        synchronized (mHookList) {\n            mHookList.add(hook);\n        }\n    } catch (Throwable throwable) {\n        Log.e(TAG, &quot;installHook %s error&quot;, throwable, hook);\n    }\n}\n</code></pre><p>首先，这里对刚才实例化的hook调用了onInstall方法，并传入一个classLoder，这里为空；然后把hook添加到一个List集合中去。我们看一下IActivityManagerHook的onInstall方法的前半部分：</p>\n<pre><code># IActivityManagerHook.java\n\npublic void onInstall(ClassLoader classLoader) throws Throwable {\n    Class cls = ActivityManagerNativeCompat.Class();\n    Object obj = FieldUtils.readStaticField(cls, &quot;gDefault&quot;);\n        if (obj == null) {\n        ActivityManagerNativeCompat.getDefault();\n        obj = FieldUtils.readStaticField(cls, &quot;gDefault&quot;);\n        }\n\n    .............\n}\n</code></pre><p>整个onInstall方法做了两件事情：</br><br>1.找到系统的IActivityManager;</br><br>2.判断该IActivityManager是否为单例，做不同的处理</p>\n<h2 id=\"找到Hook对象\"><a href=\"#找到Hook对象\" class=\"headerlink\" title=\"找到Hook对象\"></a>找到Hook对象</h2><p>我们看一下在IAcitivityManager里面”gDefault”这个变量是干嘛的，贴源码：</p>\n<pre><code># ActivityManagerNative.java\n\nprivate static final Singleton&lt;IActivityManager&gt; gDefault = new Singleton&lt;IActivityManager&gt;() {\n    protected IActivityManager create() {\n        IBinder b = ServiceManager.getService(&quot;activity&quot;);\n        if (false) {\n            Log.v(&quot;ActivityManager&quot;, &quot;default service binder = &quot; + b);\n        }\n        IActivityManager am = asInterface(b);\n        if (false) {\n            Log.v(&quot;ActivityManager&quot;, &quot;default service = &quot; + am);\n        }\n        return am;\n    }\n};\n</code></pre><p>我们知道，Android中ActivityManager是与系统所有运行着的Activity进行交互，对系统所有运行的Activity进行管理和维护，但是这些信息真正维护并不是由ActivityManager来负责。读起来有点绕，RTFSC是王道，截取其中一段获取运行服务的方法：</p>\n<pre><code># ActivityManager.java\n\npublic List&lt;RunningServiceInfo&gt; getRunningServices(int maxNum)\n        throws SecurityException {\n    try {\n        return ActivityManagerNative.getDefault()\n                .getServices(maxNum, 0);\n    } catch (RemoteException e) {\n        // System dead, we will be dead too soon!\n        return null;\n    }\n}\n</code></pre><p>通过阅读ActivityManager的源码发现，所有的信息都是通过ActivityManagerNative.getDefault()来操作获取。哎呦，这里面到底是干了啥？我们先来看一幅Activity Manager相关类继承层次关系图：</p>\n<p><img src=\"http://i.imgur.com/ToILsf2.jpg\" alt=\"\"></p>\n<p>ActivityManagerProxy，见名思意，是一个代理类，同时也是ActivityManagerNative的内部类；ActivityManagerNative是一个抽象类，实现它的是ActivityManagerService，这是一个系统Service组件。<br>从图中可以看出，使用ActivityManagerProxy，来代理ActivityManagerNative，实质就是代理它的实现类ActivityManagerService；ActivityManagerService是系统统一的Service，运行在独立的进程中，通过系统ServiceManger来获取。</p>\n<p>那么，问题来了，ActivityManager运行在一个进程里面，ActivityManagerService运行在另一个进程内，这里面涉及到跨进程的对象访问，毫无疑问，采用的是Binder机制实现。</p>\n<p>我们从刚刚截取的ActivityManagerNative.java中定义gDefault的方法可以看到，首先获取“activity”的IBinder</p>\n<pre><code>IBinder b = ServiceManager.getService(&quot;activity&quot;);\n</code></pre><p>这个可以从以下源码得知，其中sCache存放的是名字和对应IBinder的键值对Map</p>\n<pre><code># ServiceManager.java\n\n/**\n * Returns a reference to a service with the given name.\n * \n * @param name the name of the service to get\n * @return a reference to the service, or &lt;code&gt;null&lt;/code&gt; if the service doesn&apos;t exist\n */\npublic static IBinder getService(String name) {\n    try {\n        IBinder service = sCache.get(name);\n        if (service != null) {\n            return service;\n        } else {\n            return getIServiceManager().getService(name);\n        }\n    } catch (RemoteException e) {\n        Log.e(TAG, &quot;error in getService&quot;, e);\n    }\n    return null;\n}\n</code></pre><p>然后通过 asInterface(b) 就获取了ActivityManagerService实例的本地代理对象ActivityManagerProxy实例：</p>\n<pre><code># ActivityManagerNative.java\n\n/**\n * Cast a Binder object into an activity manager interface, generating\n * a proxy if needed.\n */\nstatic public IActivityManager asInterface(IBinder obj) {\n    if (obj == null) {\n        return null;\n    }\n    IActivityManager in =\n        (IActivityManager)obj.queryLocalInterface(descriptor);\n    if (in != null) {\n        return in;\n    }\n\n    return new ActivityManagerProxy(obj);\n}\n</code></pre><p>贴上一图，让你瞬间有豁然开朗的感觉有木有：</p>\n<p><img src=\"http://i.imgur.com/Au935XN.jpg\" alt=\"\"></p>\n<p>ok，回到我们的最原点，找到系统的IActivityManager要干嘛？当然就是我们的劫持hook了，在说hook之前，要说说动态代理机制。</p>\n<h2 id=\"动态代理机制\"><a href=\"#动态代理机制\" class=\"headerlink\" title=\"动态代理机制\"></a>动态代理机制</h2><p>动态代理，是一种设计模式，可以为其他对象提供一种代理以控制对这个对象的访问。举一个肤浅的栗子：</p>\n<pre><code>   public Object invoke( Object proxy, Method method, Object[] args ) throws Throwable   \n  {   \n//1.在转调具体目标对象之前，可以执行一些功能处理\n\n//2.转调具体目标对象的方法\nreturn method.invoke( proxied, args);  \n\n//3.在转调具体目标对象之后，可以执行一些功能处理\n\n  }\n} \n</code></pre><p>所谓代理，就是首先要获得被代理者的控制权，被代理者在正常调用的时候，代理可以在被代理者的所有方法前或后添加想要的操作。从上图简单地理解，就是在2方法（被代理者）添加1和3方法。可以看一下代理结构图：</p>\n<p><img src=\"http://i.imgur.com/s0zRfSt.gif\" alt=\"\"></p>\n<p>在动态代理机制中，有两个重要的类，分别是InvocationHandler和Proxy。我们看一下API帮助文档是怎么对两个类做描述的：</p>\n<p>InvocationHandler：</p>\n<pre><code>InvocationHandler is the interface implemented by the invocation handler of a proxy instance. \n\nEach proxy instance has an associated invocation handler. When a method is invoked on a proxy instance, the method invocation is encoded and dispatched to the invoke method of its invocation handler.\n</code></pre><p>每一个动态代理类必须要实现InvocationHandler这个接口，而InvocationHandler这个接口只有唯一一个invoke方法：</p>\n<pre><code>Object invoke(Object proxy, Method method, Object[] args) throws Throwable\n\nproxy:　　指代我们所代理的那个真实对象\nmethod:　 指代的是我们所要调用真实对象的某个方法的Method对象\nargs:　　 指代的是调用真实对象某个方法时接受的参数\n</code></pre><p>Proxy：</p>\n<pre><code>Proxy provides static methods for creating dynamic proxy classes and instances, and it is also the superclass of all dynamic proxy classes created by those methods. \n</code></pre><p>Proxy这个类的作用是创建一个代理对象的类，它提供了很多方法，在这里我们只需要了解到newProxyInstance 即可：</p>\n<pre><code>public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException\n\nloader:　　  一个ClassLoader对象，定义了由哪个ClassLoader对象来对生成的代理对象进行加载   \ninterfaces:  一个Interface对象的数组，表示的是我将要给我需要代理的对象提供一组什么接口，如果我提供了一组接口给它，那么这个代理对象就宣称实现了该接口(多态)，这样我就能调用这组接口中的方法了\n   h:　　        一个InvocationHandler对象，表示的是当我这个动态代理对象在调用方法的时候，会关联到哪一个InvocationHandler对象上\n</code></pre><p>ok，有了点概念，我们来继续举个具体点的栗子：</p>\n<p>定义一个people的接口：</p>\n<pre><code>public interface People{\n    public void countMoney();\n}\n</code></pre><p>boss类去实现这个接口：</p>\n<pre><code>public class Boss implements people{\n    @Override\n    public void countMoney(){\n        system.out.println(&quot;I have too money to burn.&quot;);\n    }\n} \n</code></pre><p>定义一个代理类workers，前面说到了，每一个代理类必须实现InvocationHandler 这个接口：</p>\n<pre><code>public class Workers implements InvocationHandler{\n    //这个是我们要代理的真实对象\n    private Object people;\n\n    //构造方法，给我们要代理的真实对象赋值\n    public workers(Object people){\n        this.people = people;\n    }\n\n    @Override\n    public Object invoke(Object object, Method method, Object[] args){\n\n        //在代理真实对象之前加上一些操作\n        system.out.println(&quot;I must word hard because I have no money.&quot;);\n\n        //调用真实对象的相关方法\n        method.invoke(subject, args);\n\n        //在代理真实对象之后加上一些操作\n        system.out.println(&quot;Whether you have got money or not,it&apos;s wise for you to go back home for the Spring Festival.&quot;);\n    }\n} \n</code></pre><p>编写测试类：</p>\n<pre><code>public class test{\n    ....\n    Boss boss = new Boss;\n    InvocationHandle handle = new Workers(boss);\n    Workers workers = (Workers) Proxy.newProxyInstance(handle.getClass().getClassLoader(),boss.getClass().getInterfaces(),handle);\n\n    workers.countMoney();\n\n}\n</code></pre><p>看一下输出结果：</p>\n<pre><code>I must word hard because I have no money.\nI have too money to burn.\nWhether you have got money or not,it&apos;s wise for you to go back home for the Spring Festival.\n</code></pre><p>结果很明显了，如果想了解其中的跳转原理，请查看源码，这里就不多作介绍了。</p>\n<h2 id=\"开始Hook\"><a href=\"#开始Hook\" class=\"headerlink\" title=\"开始Hook\"></a>开始Hook</h2><p>我们来看看onInstall方法的后半部分：</p>\n<pre><code># IActivityManagerHook.java\n\npublic void onInstall(ClassLoader classLoader) throws Throwable {\n    .....\n\n    if (IActivityManagerCompat.isIActivityManager(obj)) {\n        setOldObj(obj);\n        Class&lt;?&gt; objClass = mOldObj.getClass();\n        List&lt;Class&lt;?&gt;&gt; interfaces = Utils.getAllInterfaces(objClass);\n        Class[] ifs = interfaces != null &amp;&amp; interfaces.size() &gt; 0 ? interfaces.toArray(new Class[interfaces.size()]) : new Class[0];\n        Object proxiedActivityManager = MyProxy.newProxyInstance(objClass.getClassLoader(), ifs, this);\n        FieldUtils.writeStaticField(cls, &quot;gDefault&quot;, proxiedActivityManager);\n        Log.i(TAG, &quot;Install ActivityManager Hook 1 old=%s,new=%s&quot;, mOldObj, proxiedActivityManager);\n    } \n\n        .......\n    }\n</code></pre><p>首先，判断上面获取找到系统的IActivityManager是否正确，然后setOldObj(obj)保存当前系统的IActivityManager对象，留意IActivityManagerHook类是继承ProxyHook，该类实现InvocationHandler接口，就是一个代理类的实体啊。ok，你应该留意到接下来的操作就是介绍如何一步步实现代理，并把代理对象写到ActivityManagerNative的gDefault变量中，这样就实现hook了：</p>\n<pre><code>Object proxiedActivityManager = MyProxy.newProxyInstance(objClass.getClassLoader(), ifs, this);\nFieldUtils.writeStaticField(cls, &quot;gDefault&quot;, proxiedActivityManager);\n</code></pre><p>classLoader和获取所有接口数组都是沿用mOldObj对象。</p>\n<p>hook之后就开始干坏事了，把目光转到ProxyHook类中的invoke方法：</p>\n<pre><code># ProxyHook.java\n\npublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\n    try {\n        if (!isEnable()) {\n            return method.invoke(mOldObj, args);\n        }\n        HookedMethodHandler hookedMethodHandler = mHookHandles.getHookedMethodHandler(method);\n        if (hookedMethodHandler != null) {\n            return hookedMethodHandler.doHookInner(mOldObj, method, args);\n        }\n        return method.invoke(mOldObj, args);\n    } catch (InvocationTargetException e) {\n        Throwable cause = e.getTargetException();\n     .......\n}    \n</code></pre><p>首先，isEnable()先判断一下这个函数是否可以hook，不可以的话直接返回mOldObj（系统）的原本方法；可以的话继续往下走：</p>\n<pre><code># ProxyHook.java\n\nHookedMethodHandler hookedMethodHandler = mHookHandles.getHookedMethodHandler(method);\nif (hookedMethodHandler != null) {\n    return hookedMethodHandler.doHookInner(mOldObj, method, args);\n}\nreturn method.invoke(mOldObj, args);\n</code></pre><p>根据方法名字获取一个hookedMethodHandler，如果不为空，则执行hookedMethodHandler的doHookInner方法；如果为空，依旧返回系统的原本方法。</p>\n<p>hookedMethodHandler是什么鬼？还记得上面提到的IActivityManagerHookHandle的init()方法？是的，这里就要用到，先看一下之前的init()代码：</p>\n<pre><code># IActivityManagerHookHandle.java\n\nprotected void init() {\n    sHookedMethodHandlers.put(&quot;startActivity&quot;, new startActivity(mHostContext));\n    sHookedMethodHandlers.put(&quot;startActivityAsUser&quot;, new startActivityAsUser(mHostContext));\n    sHookedMethodHandlers.put(&quot;startActivityAsCaller&quot;, new startActivityAsCaller(mHostContext));\n    sHookedMethodHandlers.put(&quot;startActivityAndWait&quot;, new startActivityAndWait(mHostContext));\n    sHookedMethodHandlers.put(&quot;startActivityWithConfig&quot;, new startActivityWithConfig(mHostContext));\n    sHookedMethodHandlers.put(&quot;startActivityIntentSender&quot;, new startActivityIntentSender(mHostContext));\n    sHookedMethodHandlers.put(&quot;startVoiceActivity&quot;, new startVoiceActivity(mHostContext));\n    sHookedMethodHandlers.put(&quot;startNextMatchingActivity&quot;, new startNextMatchingActivity(mHostContext));\n    sHookedMethodHandlers.put(&quot;startActivityFromRecents&quot;, new startActivityFromRecents(mHostContext));\n  ...........\n}\n</code></pre><p>初始化把所有方法和对应的HookedMethodHandler处理类放在一起。</p>\n<p>我们假如传入一个方法名为startActivity，hookedMethodHandler存在，并进入doHookInner方法：</p>\n<pre><code># HookedMethodHandler.java\n\npublic synchronized Object doHookInner(Object receiver, Method method, Object[] args) throws Throwable {\n    long b = System.currentTimeMillis();\n    try {\n        mUseFakedResult = false;\n        mFakedResult = null;\n        boolean suc = beforeInvoke(receiver, method, args);\n        Object invokeResult = null;\n        if (!suc) {\n            invokeResult = method.invoke(receiver, args);\n        }\n        afterInvoke(receiver, method, args, invokeResult);\n        if (mUseFakedResult) {\n            return mFakedResult;\n        } else {\n            return invokeResult;\n        }\n    } \n.........\n}\n</code></pre><p>从上面看到熟悉的动态代理，先执行beforeInvoke方法，如果结果为true，拦截了该事件；如果为false，还是会继续执行系统原本方法，最后调用afterInvoke方法。在HookedMethodHandler里面beforeInvoke方法默认返回false，afterInvoke方法并没有实现：</p>\n<pre><code># HookedMethodHandler.java\n\n/**\n * 在某个方法被调用之前执行，如果返回true，则不执行原始的方法，否则执行原始方法\n */\nprotected boolean beforeInvoke(Object receiver, Method method, Object[] args) throws Throwable {\n    return false;\n}\n\nprotected void afterInvoke(Object receiver, Method method, Object[] args, Object invokeResult) throws Throwable {\n}\n</code></pre><p>如果需要实现肯定是在子类了，在IActivityManagerHookHandle的init()方法里面，以startActivity为例：</p>\n<pre><code>private static class startActivity extends HookedMethodHandler {\n\n    public startActivity(Context hostContext) {\n        super(hostContext);\n    }\n    ......\n    @Override\n    protected boolean beforeInvoke(Object receiver, Method method, Object[] args) throws Throwable {\n        if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.JELLY_BEAN_MR2) {\n            //2.3\n    /*public int startActivity(IApplicationThread caller,\n        Intent intent, String resolvedType, Uri[] grantedUriPermissions,\n        int grantedMode, IBinder resultTo, String resultWho, int requestCode,\n        boolean onlyIfNeeded, boolean debug) throws RemoteException;*/\n\n            //api 15\n    /*public int startActivity(IApplicationThread caller,\n        Intent intent, String resolvedType, Uri[] grantedUriPermissions,\n        int grantedMode, IBinder resultTo, String resultWho, int requestCode,\n        boolean onlyIfNeeded, boolean debug, String profileFile,\n        ParcelFileDescriptor profileFd, boolean autoStopProfiler) throws RemoteException;*/\n\n            //api 16,17\n    /*  public int startActivity(IApplicationThread caller,\n        Intent intent, String resolvedType, IBinder resultTo, String resultWho,\n        int requestCode, int flags, String profileFile,\n        ParcelFileDescriptor profileFd, Bundle options) throws RemoteException;*/\n            doReplaceIntentForStartActivityAPILow(args);\n        } else {\n            //api 18,19\n     /*  public int startActivity(IApplicationThread caller, String callingPackage,\n        Intent intent, String resolvedType, IBinder resultTo, String resultWho,\n        int requestCode, int flags, String profileFile,\n        ParcelFileDescriptor profileFd, Bundle options) throws RemoteException;*/\n\n            //api 21\n    /*   public int startActivity(IApplicationThread caller, String callingPackage,\n        Intent intent, String resolvedType, IBinder resultTo, String resultWho,\n        int requestCode, int flags, ProfilerInfo profilerInfo,\n        Bundle options) throws RemoteException;*/\n            doReplaceIntentForStartActivityAPIHigh(args);\n        }\n        return super.beforeInvoke(receiver, method, args);\n    }\n}\n</code></pre><p>至此，hook的过程应该已经介绍完毕，其中涉及比较高深的问题，小弟完美绕过。</p>"},{"title":"Hexo搭建优化部署","date":"2016-09-03T14:56:45.289Z","_content":"\n\n# 前言\n作为一名专业的技术码农，经验积累和技术分享是一项必不可少的软技能。俗话说，好记性不如烂笔头，在平时工作中遇到的各种奇葩问题和学习感悟用文档记录是个很好的习惯，同时也可以用做分享，让别人或者自己少走弯路。目前网上各种技术博客可谓百花齐放，诸如CSDN、51blog和不少公司定制的分享博客等，当然也有不少公司内部分享的.md记录文档。当然了，如果\n<!-- more -->\n你是一名“异类”的程序猿，不满足于现有的博客框架，不妨考虑下本文介绍的Github pages+Hexo+Nodejs搭建个人blog。\n\n# 概要说明\n\n网上对于这种博客的搭建应该是有相当多的介绍了，[简单的搭建](http://cstsinghua.github.io/2016/06/16/Github%20pages+Hexo+Nodejs%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BAblog/#建站\")或者换一个皮肤相信也难不到大家。但是大家在使用的过程中应该会发现，框架的搭建是依赖于当前的电脑，假如电脑要重装或者直接挂了要换一台新的，这样原本的记录岂不是全没了？我一直都相信，高手在人间，发现这个问题的早有人在，而解决的办法总比问题多，本文的介绍就是参考网上的配置做法做点补充：[参考文章](http://crazymilk.github.io/2015/12/28/GitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/#more)\n\n# 搭建流程\n\n参考上面提供文章链接中的第四点 **优化部署与管理**，笔者在配置过程出现了几个问题导致一直配置失败，在这里分享下希望有同样问题的读者可以参考，过程大同小异：\n\n1. 创建仓库，hellokugo.github.io.git；<br>\n2. 创建两个分支：master 与 hexo；<br>\n3. 设置hexo为默认分支（因为我们只需要手动管理这个分支上的Hexo网站文件）；<br>\n4. 使用git clone git@github.com:hellokugo/hellokugo.github.io.git拷贝仓库；<br>\n5. hellokugo.github.io文件夹下通过Git bash依次执行npm install hexo、hexo init、npm install 和 npm install hexo-deployer-git（此时当前分支应显示为hexo）;<br>\n\n\t**注意1：笔者在这里踩了坑，在执行hexo init的时候会把第二步clone下来的文件.git给删掉，导致在下面做代码提交步骤时一直报找不到.git文件错误，所以，在执行第五步或者执行hexo init前把.git文件放到上级目录（或者在执行完第五步再把.git文件放回来，这个没有做测试），这样就不会出现这样的错误了。这里可以用git branch来检查下当前分支会否为hexo**<br>\n\n6. 修改_config.yml中的deploy参数，分支应为master（可用git branch命令来检查）；\n7. 依次执行git add .、git commit -m “…”、git push origin hexo提交网站相关的文件；\n\n\t**注意2：这里最后一步git push origin hexo，对于还没习惯git工具的读者可能会直接按照这个命令输入，然后就抛出origin未定义的错误，这个如果有点git工具使用经验的读者来说，是应该在这命令前先定义origin，即git remote add origin git@github.com:hellokugo/hellokugo.github.io.git（这里是你的仓库github地址）**<br>\n\n8. 执行hexo generate -d生成网站并部署到GitHub上。\n\n\t**注意3：有些读者可能走到这一步时就抛出FATE Deploy failed: git，这个问题在于执行第五步的最后一句命令npm install hexo-deployer-git没有把相关文件记录下来导致出错，不过这可能不是每个人都会出现，如果出现了，再执行npm install hexo-deployer-git --save,，然后再部署即可。**<br>\n\n# 最后\n\n其实上述步骤完全可以写一个简单的python脚本实现（有需要可以提供一个参数输入，用于填写提交日志），这里就不累赘了。最后，感谢参考文章中笔者提供这种思路去巧妙解决电脑各种丢失数据而导致的问题，真心想说一句，站在巨人的肩上，技术路上不孤单。","source":"_posts/Hexo搭建优化部署.md","raw":"title: Hexo搭建优化部署\ndate: 2016/9/4 00：17\n\ncategories:\n- Others\ntags:\n- other\n---\n\n\n# 前言\n作为一名专业的技术码农，经验积累和技术分享是一项必不可少的软技能。俗话说，好记性不如烂笔头，在平时工作中遇到的各种奇葩问题和学习感悟用文档记录是个很好的习惯，同时也可以用做分享，让别人或者自己少走弯路。目前网上各种技术博客可谓百花齐放，诸如CSDN、51blog和不少公司定制的分享博客等，当然也有不少公司内部分享的.md记录文档。当然了，如果\n<!-- more -->\n你是一名“异类”的程序猿，不满足于现有的博客框架，不妨考虑下本文介绍的Github pages+Hexo+Nodejs搭建个人blog。\n\n# 概要说明\n\n网上对于这种博客的搭建应该是有相当多的介绍了，[简单的搭建](http://cstsinghua.github.io/2016/06/16/Github%20pages+Hexo+Nodejs%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BAblog/#建站\")或者换一个皮肤相信也难不到大家。但是大家在使用的过程中应该会发现，框架的搭建是依赖于当前的电脑，假如电脑要重装或者直接挂了要换一台新的，这样原本的记录岂不是全没了？我一直都相信，高手在人间，发现这个问题的早有人在，而解决的办法总比问题多，本文的介绍就是参考网上的配置做法做点补充：[参考文章](http://crazymilk.github.io/2015/12/28/GitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/#more)\n\n# 搭建流程\n\n参考上面提供文章链接中的第四点 **优化部署与管理**，笔者在配置过程出现了几个问题导致一直配置失败，在这里分享下希望有同样问题的读者可以参考，过程大同小异：\n\n1. 创建仓库，hellokugo.github.io.git；<br>\n2. 创建两个分支：master 与 hexo；<br>\n3. 设置hexo为默认分支（因为我们只需要手动管理这个分支上的Hexo网站文件）；<br>\n4. 使用git clone git@github.com:hellokugo/hellokugo.github.io.git拷贝仓库；<br>\n5. hellokugo.github.io文件夹下通过Git bash依次执行npm install hexo、hexo init、npm install 和 npm install hexo-deployer-git（此时当前分支应显示为hexo）;<br>\n\n\t**注意1：笔者在这里踩了坑，在执行hexo init的时候会把第二步clone下来的文件.git给删掉，导致在下面做代码提交步骤时一直报找不到.git文件错误，所以，在执行第五步或者执行hexo init前把.git文件放到上级目录（或者在执行完第五步再把.git文件放回来，这个没有做测试），这样就不会出现这样的错误了。这里可以用git branch来检查下当前分支会否为hexo**<br>\n\n6. 修改_config.yml中的deploy参数，分支应为master（可用git branch命令来检查）；\n7. 依次执行git add .、git commit -m “…”、git push origin hexo提交网站相关的文件；\n\n\t**注意2：这里最后一步git push origin hexo，对于还没习惯git工具的读者可能会直接按照这个命令输入，然后就抛出origin未定义的错误，这个如果有点git工具使用经验的读者来说，是应该在这命令前先定义origin，即git remote add origin git@github.com:hellokugo/hellokugo.github.io.git（这里是你的仓库github地址）**<br>\n\n8. 执行hexo generate -d生成网站并部署到GitHub上。\n\n\t**注意3：有些读者可能走到这一步时就抛出FATE Deploy failed: git，这个问题在于执行第五步的最后一句命令npm install hexo-deployer-git没有把相关文件记录下来导致出错，不过这可能不是每个人都会出现，如果出现了，再执行npm install hexo-deployer-git --save,，然后再部署即可。**<br>\n\n# 最后\n\n其实上述步骤完全可以写一个简单的python脚本实现（有需要可以提供一个参数输入，用于填写提交日志），这里就不累赘了。最后，感谢参考文章中笔者提供这种思路去巧妙解决电脑各种丢失数据而导致的问题，真心想说一句，站在巨人的肩上，技术路上不孤单。","slug":"Hexo搭建优化部署","published":1,"updated":"2016-09-04T11:55:27.644Z","_id":"cisne204x00005svit7c51b4p","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>作为一名专业的技术码农，经验积累和技术分享是一项必不可少的软技能。俗话说，好记性不如烂笔头，在平时工作中遇到的各种奇葩问题和学习感悟用文档记录是个很好的习惯，同时也可以用做分享，让别人或者自己少走弯路。目前网上各种技术博客可谓百花齐放，诸如CSDN、51blog和不少公司定制的分享博客等，当然也有不少公司内部分享的.md记录文档。当然了，如果<br><a id=\"more\"></a><br>你是一名“异类”的程序猿，不满足于现有的博客框架，不妨考虑下本文介绍的Github pages+Hexo+Nodejs搭建个人blog。</p>\n<h1 id=\"概要说明\"><a href=\"#概要说明\" class=\"headerlink\" title=\"概要说明\"></a>概要说明</h1><p>网上对于这种博客的搭建应该是有相当多的介绍了，<a href=\"http://cstsinghua.github.io/2016/06/16/Github%20pages+Hexo+Nodejs%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BAblog/#建站&quot;\" target=\"_blank\" rel=\"external\">简单的搭建</a>或者换一个皮肤相信也难不到大家。但是大家在使用的过程中应该会发现，框架的搭建是依赖于当前的电脑，假如电脑要重装或者直接挂了要换一台新的，这样原本的记录岂不是全没了？我一直都相信，高手在人间，发现这个问题的早有人在，而解决的办法总比问题多，本文的介绍就是参考网上的配置做法做点补充：<a href=\"http://crazymilk.github.io/2015/12/28/GitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/#more\" target=\"_blank\" rel=\"external\">参考文章</a></p>\n<h1 id=\"搭建流程\"><a href=\"#搭建流程\" class=\"headerlink\" title=\"搭建流程\"></a>搭建流程</h1><p>参考上面提供文章链接中的第四点 <strong>优化部署与管理</strong>，笔者在配置过程出现了几个问题导致一直配置失败，在这里分享下希望有同样问题的读者可以参考，过程大同小异：</p>\n<ol>\n<li>创建仓库，hellokugo.github.io.git；<br></li>\n<li>创建两个分支：master 与 hexo；<br></li>\n<li>设置hexo为默认分支（因为我们只需要手动管理这个分支上的Hexo网站文件）；<br></li>\n<li>使用git clone git@github.com:hellokugo/hellokugo.github.io.git拷贝仓库；<br></li>\n<li><p>hellokugo.github.io文件夹下通过Git bash依次执行npm install hexo、hexo init、npm install 和 npm install hexo-deployer-git（此时当前分支应显示为hexo）;<br></p>\n<p> <strong>注意1：笔者在这里踩了坑，在执行hexo init的时候会把第二步clone下来的文件.git给删掉，导致在下面做代码提交步骤时一直报找不到.git文件错误，所以，在执行第五步或者执行hexo init前把.git文件放到上级目录（或者在执行完第五步再把.git文件放回来，这个没有做测试），这样就不会出现这样的错误了。这里可以用git branch来检查下当前分支会否为hexo</strong><br></p>\n</li>\n<li><p>修改_config.yml中的deploy参数，分支应为master（可用git branch命令来检查）；</p>\n</li>\n<li><p>依次执行git add .、git commit -m “…”、git push origin hexo提交网站相关的文件；</p>\n<p> <strong>注意2：这里最后一步git push origin hexo，对于还没习惯git工具的读者可能会直接按照这个命令输入，然后就抛出origin未定义的错误，这个如果有点git工具使用经验的读者来说，是应该在这命令前先定义origin，即git remote add origin git@github.com:hellokugo/hellokugo.github.io.git（这里是你的仓库github地址）</strong><br></p>\n</li>\n<li><p>执行hexo generate -d生成网站并部署到GitHub上。</p>\n<p> <strong>注意3：有些读者可能走到这一步时就抛出FATE Deploy failed: git，这个问题在于执行第五步的最后一句命令npm install hexo-deployer-git没有把相关文件记录下来导致出错，不过这可能不是每个人都会出现，如果出现了，再执行npm install hexo-deployer-git –save,，然后再部署即可。</strong><br></p>\n</li>\n</ol>\n<h1 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h1><p>其实上述步骤完全可以写一个简单的python脚本实现（有需要可以提供一个参数输入，用于填写提交日志），这里就不累赘了。最后，感谢参考文章中笔者提供这种思路去巧妙解决电脑各种丢失数据而导致的问题，真心想说一句，站在巨人的肩上，技术路上不孤单。</p>\n","excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>作为一名专业的技术码农，经验积累和技术分享是一项必不可少的软技能。俗话说，好记性不如烂笔头，在平时工作中遇到的各种奇葩问题和学习感悟用文档记录是个很好的习惯，同时也可以用做分享，让别人或者自己少走弯路。目前网上各种技术博客可谓百花齐放，诸如CSDN、51blog和不少公司定制的分享博客等，当然也有不少公司内部分享的.md记录文档。当然了，如果<br>","more":"<br>你是一名“异类”的程序猿，不满足于现有的博客框架，不妨考虑下本文介绍的Github pages+Hexo+Nodejs搭建个人blog。</p>\n<h1 id=\"概要说明\"><a href=\"#概要说明\" class=\"headerlink\" title=\"概要说明\"></a>概要说明</h1><p>网上对于这种博客的搭建应该是有相当多的介绍了，<a href=\"http://cstsinghua.github.io/2016/06/16/Github%20pages+Hexo+Nodejs%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BAblog/#建站&quot;\">简单的搭建</a>或者换一个皮肤相信也难不到大家。但是大家在使用的过程中应该会发现，框架的搭建是依赖于当前的电脑，假如电脑要重装或者直接挂了要换一台新的，这样原本的记录岂不是全没了？我一直都相信，高手在人间，发现这个问题的早有人在，而解决的办法总比问题多，本文的介绍就是参考网上的配置做法做点补充：<a href=\"http://crazymilk.github.io/2015/12/28/GitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/#more\">参考文章</a></p>\n<h1 id=\"搭建流程\"><a href=\"#搭建流程\" class=\"headerlink\" title=\"搭建流程\"></a>搭建流程</h1><p>参考上面提供文章链接中的第四点 <strong>优化部署与管理</strong>，笔者在配置过程出现了几个问题导致一直配置失败，在这里分享下希望有同样问题的读者可以参考，过程大同小异：</p>\n<ol>\n<li>创建仓库，hellokugo.github.io.git；<br></li>\n<li>创建两个分支：master 与 hexo；<br></li>\n<li>设置hexo为默认分支（因为我们只需要手动管理这个分支上的Hexo网站文件）；<br></li>\n<li>使用git clone git@github.com:hellokugo/hellokugo.github.io.git拷贝仓库；<br></li>\n<li><p>hellokugo.github.io文件夹下通过Git bash依次执行npm install hexo、hexo init、npm install 和 npm install hexo-deployer-git（此时当前分支应显示为hexo）;<br></p>\n<p> <strong>注意1：笔者在这里踩了坑，在执行hexo init的时候会把第二步clone下来的文件.git给删掉，导致在下面做代码提交步骤时一直报找不到.git文件错误，所以，在执行第五步或者执行hexo init前把.git文件放到上级目录（或者在执行完第五步再把.git文件放回来，这个没有做测试），这样就不会出现这样的错误了。这里可以用git branch来检查下当前分支会否为hexo</strong><br></p>\n</li>\n<li><p>修改_config.yml中的deploy参数，分支应为master（可用git branch命令来检查）；</p>\n</li>\n<li><p>依次执行git add .、git commit -m “…”、git push origin hexo提交网站相关的文件；</p>\n<p> <strong>注意2：这里最后一步git push origin hexo，对于还没习惯git工具的读者可能会直接按照这个命令输入，然后就抛出origin未定义的错误，这个如果有点git工具使用经验的读者来说，是应该在这命令前先定义origin，即git remote add origin git@github.com:hellokugo/hellokugo.github.io.git（这里是你的仓库github地址）</strong><br></p>\n</li>\n<li><p>执行hexo generate -d生成网站并部署到GitHub上。</p>\n<p> <strong>注意3：有些读者可能走到这一步时就抛出FATE Deploy failed: git，这个问题在于执行第五步的最后一句命令npm install hexo-deployer-git没有把相关文件记录下来导致出错，不过这可能不是每个人都会出现，如果出现了，再执行npm install hexo-deployer-git –save,，然后再部署即可。</strong><br></p>\n</li>\n</ol>\n<h1 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h1><p>其实上述步骤完全可以写一个简单的python脚本实现（有需要可以提供一个参数输入，用于填写提交日志），这里就不累赘了。最后，感谢参考文章中笔者提供这种思路去巧妙解决电脑各种丢失数据而导致的问题，真心想说一句，站在巨人的肩上，技术路上不孤单。</p>"}],"PostAsset":[],"PostCategory":[{"post_id":"cisn9io3d000064viu2mvomi3","category_id":"cisn9io3t000264viviekyef4","_id":"cisn9io46000864vi55wyf9qw"},{"post_id":"cisn9io3p000164vi4me0qlih","category_id":"cisn9io3t000264viviekyef4","_id":"cisn9io49000c64via9jaz94u"},{"post_id":"cisn9io41000464vic49pe6zm","category_id":"cisn9io3t000264viviekyef4","_id":"cisn9io4a000e64videwm340o"},{"post_id":"cisne204x00005svit7c51b4p","category_id":"cisneb6qn00004kvifx0dkp5m","_id":"cisneb6r200034kvir52q1xei"}],"PostTag":[{"post_id":"cisn9io3d000064viu2mvomi3","tag_id":"cisn9io40000364vi3pmt7z20","_id":"cisn9io45000764vi54ta7ptv"},{"post_id":"cisn9io3p000164vi4me0qlih","tag_id":"cisn9io40000364vi3pmt7z20","_id":"cisn9io48000b64viqcpsl8ly"},{"post_id":"cisn9io41000464vic49pe6zm","tag_id":"cisn9io40000364vi3pmt7z20","_id":"cisn9io4a000d64vi71t13vm9"},{"post_id":"cisne204x00005svit7c51b4p","tag_id":"cisneb6r200014kvihoocilol","_id":"cisneb6r200024kvinuacg7i4"}],"Tag":[{"name":"android","_id":"cisn9io40000364vi3pmt7z20"},{"name":"other","_id":"cisneb6r200014kvihoocilol"}]}}